declare function Uint8Array_new(length: int): Uint8Array;

declare class Uint8Array {
  length: int;
  operator [] (index: int): byte;
  operator []= (index: int, value: byte): void;
}

class ByteArray {
  _data: Uint8Array;
  _length: int;

  length(): int {
    return this._length;
  }

  get(index: int): byte {
    assert((index as uint) < (this._length as uint));
    return this._data[index];
  }

  set(index: int, value: byte): void {
    assert((index as uint) < (this._length as uint));
    this._data[index] = value;
  }

  append(value: byte): void {
    var index = this._length;
    this._resize(index + 1);
    this._data[index] = value;
  }

  _resize(length: int): void {
    if (length > (this._data != null ? this._data.length : 0)) {
      var capacity = length * 2;
      var data = Uint8Array_new(capacity);
      var source = this._data;
      var limit = this._length;
      var i = 0;

      // Copy the old bytes over
      while (i < limit) {
        data[i] = source[i];
        i = i + 1;
      }

      // Swap in the new bytes
      this._data = data;
    }

    this._length = length;
  }
}
function ByteArray_set16(array: ByteArray, index: int, value: int): void {
  array.set(index, value as byte);
  array.set(index + 1, (value >> 8) as byte);
}

function ByteArray_set32(array: ByteArray, index: int, value: int): void {
  array.set(index, value as byte);
  array.set(index + 1, (value >> 8) as byte);
  array.set(index + 2, (value >> 16) as byte);
  array.set(index + 3, (value >> 24) as byte);
}

function ByteArray_append32(array: ByteArray, value: int): void {
  array.append(value as byte);
  array.append((value >> 8) as byte);
  array.append((value >> 16) as byte);
  array.append((value >> 24) as byte);
}
class CheckContext {
  log: Log;
  isUnsafeAllowed: bool;
  currentReturnType: Type;
  nextGlobalVariableOffset: int;

  // Native types
  boolType: Type;
  byteType: Type;
  errorType: Type;
  intType: Type;
  nullType: Type;
  shortType: Type;
  stringType: Type;
  ubyteType: Type;
  uintType: Type;
  ushortType: Type;
  voidType: Type;

  allocateGlobalVariableOffset(sizeOf: int, alignmentOf: int): int {
    var offset = alignToNextMultipleOf(this.nextGlobalVariableOffset, alignmentOf);
    this.nextGlobalVariableOffset = offset + sizeOf;
    return offset;
  }
}

function addScopeToSymbol(symbol: Symbol, parentScope: Scope): void {
  var scope = new Scope();
  scope.parent = parentScope;
  scope.symbol = symbol;
  symbol.scope = scope;
}

function linkSymbolToNode(symbol: Symbol, node: Node): void {
  node.symbol = symbol;
  node.scope = symbol.scope;
  symbol.range = node.internalRange != null ? node.internalRange : node.range;
  symbol.node = node;
}

function initialize(context: CheckContext, node: Node, parentScope: Scope): void {
  if (node.parent != null) {
    var kind = node.kind;
    var parentKind = node.parent.kind;

    // Validate node placement
    if (kind != NodeKind.VARIABLE && kind != NodeKind.VARIABLES && (kind != NodeKind.FUNCTION || parentKind != NodeKind.CLASS) &&
        (parentKind == NodeKind.GLOBAL) != (kind == NodeKind.CLASS || kind == NodeKind.ENUM || kind == NodeKind.FUNCTION || kind == NodeKind.CONSTANTS)) {
      context.log.error(node.range, String_new("This statement is not allowed here"));
    }
  }

  // Global
  if (node.kind == NodeKind.GLOBAL) {
    assert(parentScope == null);

    var symbol = new Symbol();
    symbol.kind = SymbolKind.TYPE_GLOBAL;
    symbol.name = String_new("<global>");
    symbol.resolvedType = new Type();
    symbol.resolvedType.symbol = symbol;
    symbol.state = SymbolState.INITIALIZED;
    addScopeToSymbol(symbol, parentScope);
    linkSymbolToNode(symbol, node);
    parentScope = symbol.scope;

    // Initialize native types
    context.boolType = parentScope.defineNativeType(context.log, "bool", 1);
    context.errorType = parentScope.defineNativeType(context.log, "<error>", 0);
    context.nullType = parentScope.defineNativeType(context.log, "null", 0);
    context.stringType = parentScope.defineNativeType(context.log, "string", POINTER_SIZE);
    context.voidType = parentScope.defineNativeType(context.log, "void", 0);

    // Native integer types
    context.byteType = parentScope.defineNativeIntegerType(context.log, "byte", 1, false);
    context.intType = parentScope.defineNativeIntegerType(context.log, "int", 4, false);
    context.shortType = parentScope.defineNativeIntegerType(context.log, "short", 2, false);
    context.ubyteType = parentScope.defineNativeIntegerType(context.log, "byte", 1, true);
    context.uintType = parentScope.defineNativeIntegerType(context.log, "uint", 4, true);
    context.ushortType = parentScope.defineNativeIntegerType(context.log, "ushort", 2, true);
  }

  // Class
  else if (node.kind == NodeKind.CLASS || node.kind == NodeKind.ENUM) {
    var symbol = new Symbol();
    symbol.kind = node.kind == NodeKind.CLASS ? SymbolKind.TYPE_CLASS : SymbolKind.TYPE_ENUM;
    symbol.name = node.stringValue;
    addScopeToSymbol(symbol, parentScope);
    linkSymbolToNode(symbol, node);
    parentScope.define(context.log, symbol);
    parentScope = symbol.scope;
  }

  // Function
  else if (node.kind == NodeKind.FUNCTION) {
    var symbol = new Symbol();
    symbol.kind =
      node.parent.kind == NodeKind.CLASS ? SymbolKind.FUNCTION_INSTANCE :
      SymbolKind.FUNCTION_GLOBAL;
    symbol.name = node.stringValue;
    addScopeToSymbol(symbol, parentScope);
    linkSymbolToNode(symbol, node);
    parentScope.define(context.log, symbol);
    parentScope = symbol.scope;

    // All instance functions have a special "this" type
    if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
      var parent = symbol.parent();
      assert(parent.kind == SymbolKind.TYPE_CLASS);
      initializeSymbol(context, parent);
      node.insertChildBefore(node.firstChild, createVariable(String_new("this"), createType(parent.resolvedType), null));
    }
  }

  // Variable
  else if (node.kind == NodeKind.VARIABLE) {
    var symbol = new Symbol();
    symbol.kind =
      node.parent.kind == NodeKind.CLASS ? SymbolKind.VARIABLE_INSTANCE :
      node.parent.kind == NodeKind.FUNCTION ? SymbolKind.VARIABLE_ARGUMENT :
      node.parent.kind == NodeKind.CONSTANTS || node.parent.kind == NodeKind.ENUM ? SymbolKind.VARIABLE_CONSTANT :
      node.parent.kind == NodeKind.VARIABLES && node.parent.parent.kind == NodeKind.GLOBAL ? SymbolKind.VARIABLE_GLOBAL :
      SymbolKind.VARIABLE_LOCAL;
    symbol.name = node.stringValue;
    symbol.scope = parentScope;
    linkSymbolToNode(symbol, node);
    parentScope.define(context.log, symbol);
  }

  // Block
  else if (node.kind == NodeKind.BLOCK) {
    if (node.parent.kind != NodeKind.FUNCTION) {
      var scope = new Scope();
      scope.parent = parentScope;
      parentScope = scope;
    }
    node.scope = parentScope;
  }

  // Children
  var child = node.firstChild;
  while (child != null) {
    initialize(context, child, parentScope);
    child = child.nextSibling;
  }
}

function forbidFlag(context: CheckContext, node: Node, flag: int, text: string): void {
  if ((node.flags & flag) != 0) {
    var range = rangeForFlag(node.firstFlag, flag);

    if (range != null) {
      node.flags = node.flags & ~flag;
      context.log.error(range, String_new(text));
    }
  }
}

function requireFlag(context: CheckContext, node: Node, flag: int, text: string): void {
  if ((node.flags & flag) == 0) {
    node.flags = node.flags | flag;
    context.log.error(node.range, String_new(text));
  }
}

function initializeSymbol(context: CheckContext, symbol: Symbol): void {
  if (symbol.state == SymbolState.INITIALIZED) {
    assert(symbol.resolvedType != null);
    return;
  }

  assert(symbol.state == SymbolState.UNINITIALIZED);
  assert(symbol.resolvedType == null);
  symbol.state = SymbolState.INITIALIZING;

  // Most flags aren't supported yet
  var node = symbol.node;
  forbidFlag(context, node, NODE_FLAG_EXPORT, "Unsupported flag 'export'");
  forbidFlag(context, node, NODE_FLAG_GET, "Unsupported flag 'get'");
  forbidFlag(context, node, NODE_FLAG_PRIVATE, "Unsupported flag 'private'");
  forbidFlag(context, node, NODE_FLAG_PROTECTED, "Unsupported flag 'protected'");
  forbidFlag(context, node, NODE_FLAG_PUBLIC, "Unsupported flag 'public'");
  forbidFlag(context, node, NODE_FLAG_SET, "Unsupported flag 'set'");
  forbidFlag(context, node, NODE_FLAG_STATIC, "Unsupported flag 'static'");

  // Class
  if (symbol.kind == SymbolKind.TYPE_CLASS) {
    symbol.resolvedType = new Type();
    symbol.resolvedType.symbol = symbol;
  }

  // Enum
  else if (symbol.kind == SymbolKind.TYPE_ENUM) {
    symbol.resolvedType = new Type();
    symbol.resolvedType.symbol = symbol;
    var underlyingSymbol = symbol.resolvedType.underlyingType(context).symbol;
    symbol.byteSize = underlyingSymbol.byteSize;
    symbol.maxAlignment = underlyingSymbol.maxAlignment;
  }

  // Function
  else if (isFunction(symbol.kind)) {
    var body = node.functionBody();
    var returnType = node.functionReturnType();
    resolveAsType(context, returnType, symbol.scope.parent);

    var offset = 0;
    var child = node.firstChild;
    while (child != returnType) {
      assert(child.kind == NodeKind.VARIABLE);
      assert(child.symbol.kind == SymbolKind.VARIABLE_ARGUMENT);
      initializeSymbol(context, child.symbol);
      child.symbol.offset = offset;
      offset = offset + 1;
      child = child.nextSibling;
    }

    symbol.resolvedType = new Type();
    symbol.resolvedType.symbol = symbol;

    if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
      forbidFlag(context, node, NODE_FLAG_EXTERN, "Cannot use 'extern' on an instance function");
      forbidFlag(context, node, NODE_FLAG_DECLARE, "Cannot use 'declare' on an instance function");

      // Functions inside declared classes are automatically declared
      if (symbol.parent().node.isDeclare()) {
        node.flags = node.flags | NODE_FLAG_DECLARE;

        // Prevent declared functions on declared classes for simplicity
        if (body != null) {
          context.log.error(body.range, String_new("Cannot implement a function on a declared class"));
        }
      }

      // Require implementations for functions not on declared classes
      else if (body == null) {
        context.log.error(node.lastChild.range, String_new("Must implement this function"));
      }
    }

    // Imported functions require a modifier for consistency with TypeScript
    else if (body == null) {
      forbidFlag(context, node, NODE_FLAG_EXTERN, "Cannot use 'extern' on an unimplemented function");
      requireFlag(context, node, NODE_FLAG_DECLARE, "Declared functions must be prefixed with 'declare'");
    }

    else {
      forbidFlag(context, node, NODE_FLAG_DECLARE, "Cannot use 'declare' on a function with an implementation");
    }
  }

  // Variable
  else if (isVariable(symbol.kind)) {
    var type = node.variableType();
    var value = node.variableValue();

    if (type != null) {
      resolveAsType(context, type, symbol.scope);
      symbol.resolvedType = type.resolvedType;
    }

    else if (value != null) {
      resolveAsExpression(context, value, symbol.scope);
      symbol.resolvedType = value.resolvedType;
    }

    else {
      context.log.error(node.internalRange, String_new("Cannot create untyped variables"));
      symbol.resolvedType = context.errorType;
    }

    // Validate the variable type
    if (symbol.resolvedType == context.voidType || symbol.resolvedType == context.nullType) {
      context.log.error(node.internalRange, String_appendNew(String_append(
        String_new("Cannot create a variable with type '"),
        symbol.resolvedType.toString()),
        "'"));
      symbol.resolvedType = context.errorType;
    }

    // Resolve constant values at initialization time
    if (symbol.kind == SymbolKind.VARIABLE_CONSTANT) {
      if (value != null) {
        resolveAsExpression(context, value, symbol.scope);
        checkConversion(context, value, symbol.resolvedTypeUnderlyingIfEnumValue(context), ConversionKind.IMPLICIT);

        if (value.kind == NodeKind.INT || value.kind == NodeKind.BOOL) {
          symbol.offset = value.intValue;
        }

        else if (value.resolvedType != context.errorType) {
          context.log.error(value.range, String_new("Invalid constant initializer"));
          symbol.resolvedType = context.errorType;
        }
      }

      // Automatically initialize enum values using the previous enum
      else if (symbol.isEnumValue()) {
        if (node.previousSibling != null) {
          var previousSymbol = node.previousSibling.symbol;
          initializeSymbol(context, previousSymbol);
          symbol.offset = previousSymbol.offset + 1;
        } else {
          symbol.offset = 0;
        }
      }

      else {
        context.log.error(node.internalRange, String_new("Constants must be initialized"));
      }
    }

    // Disallow shadowing at function scope
    if (symbol.scope.symbol == null) {
      var scope = symbol.scope.parent;
      while (scope != null) {
        var shadowed = scope.findLocal(symbol.name);
        if (shadowed != null) {
          context.log.error(node.internalRange, String_appendNew(String_append(
            String_new("The symbol '"),
            symbol.name),
            "' shadows another symbol with the same name in a parent scope"));
          break;
        }

        // Stop when we pass through a function scope
        if (scope.symbol != null) {
          break;
        }
        scope = scope.parent;
      }
    }
  }

  else {
    assert(false);
  }

  assert(symbol.resolvedType != null);
  symbol.state = SymbolState.INITIALIZED;
}

function resolveChildren(context: CheckContext, node: Node, parentScope: Scope): void {
  var child = node.firstChild;
  while (child != null) {
    resolve(context, child, parentScope);
    child = child.nextSibling;
  }
}

function resolveChildrenAsExpressions(context: CheckContext, node: Node, parentScope: Scope): void {
  var child = node.firstChild;
  while (child != null) {
    resolveAsExpression(context, child, parentScope);
    child = child.nextSibling;
  }
}

function resolveAsExpression(context: CheckContext, node: Node, parentScope: Scope): void {
  assert(isExpression(node));
  resolve(context, node, parentScope);

  if (node.resolvedType != context.errorType && node.isType()) {
    context.log.error(node.range, String_new("Expected expression but found type"));
    node.resolvedType = context.errorType;
  }
}

function resolveAsType(context: CheckContext, node: Node, parentScope: Scope): void {
  assert(isExpression(node));
  resolve(context, node, parentScope);

  if (node.resolvedType != context.errorType && !node.isType()) {
    context.log.error(node.range, String_new("Expected type but found expression"));
    node.resolvedType = context.errorType;
  }
}

function checkConversion(context: CheckContext, node: Node, to: Type, kind: ConversionKind): void {
  var from = node.resolvedType;
  var canCast = false;

  assert(isExpression(node));
  assert(from != null);
  assert(to != null);

  // Early-out if the types are identical or errors
  if (from == to || from == context.errorType || to == context.errorType) {
    return;
  }

  // Allow conversions from null
  else if (from == context.nullType && to.isReference(context)) {
    return;
  }

  // Allow explicit conversions between references in unsafe mode
  else if (context.isUnsafeAllowed && (from.isReference(context) || to.isReference(context))) {
    if (kind == ConversionKind.EXPLICIT) {
      return;
    }

    canCast = true;
  }

  // Check integer conversions
  else if (from.isInteger() && to.isInteger()) {
    var mask = to.integerBitMask();

    // Only allow lossless conversions implicitly
    if (kind == ConversionKind.EXPLICIT || from.symbol.byteSize < to.symbol.byteSize ||
        node.kind == NodeKind.INT && (to.isUnsigned()
          ? node.intValue >= 0 && node.intValue as uint <= mask
          : node.intValue >= (~mask as int >> 1) && node.intValue <= (mask >> 1) as int)) {
      return;
    }

    canCast = true;
  }

  // All other conversions are an error
  var message = String_appendNew(String_append(String_appendNew(String_append(
    String_new("Cannot convert from type '"),
    from.toString()),
    "' to type '"),
    to.toString()),
    "'");
  context.log.error(node.range, canCast ? String_appendNew(message, " without a cast") : message);

  // Prevent further errors
  node.resolvedType = context.errorType;
}

function checkStorage(context: CheckContext, target: Node): void {
  assert(isExpression(target));

  if (target.resolvedType != context.errorType && target.kind != NodeKind.INDEX && (target.kind != NodeKind.NAME && target.kind != NodeKind.DOT ||
      target.symbol != null && (!isVariable(target.symbol.kind) || target.symbol.kind == SymbolKind.VARIABLE_CONSTANT))) {
    context.log.error(target.range, String_new("Cannot store to this location"));
    target.resolvedType = context.errorType;
  }
}

function createDefaultValueForType(context: CheckContext, type: Type): Node {
  if (type.isInteger()) {
    return createInt(0);
  }

  if (type == context.boolType) {
    return createBool(false);
  }

  assert(type.isReference(context));
  return createNull();
}

function simplifyBinary(node: Node): void {
  var left = node.binaryLeft();
  var right = node.binaryRight();

  // Canonicalize commutative operators
  if ((node.kind == NodeKind.ADD || node.kind == NodeKind.MULTIPLY ||
      node.kind == NodeKind.BITWISE_AND || node.kind == NodeKind.BITWISE_OR || node.kind == NodeKind.BITWISE_XOR) &&
      left.kind == NodeKind.INT && right.kind != NodeKind.INT) {
    left.remove();
    node.appendChild(left);
    left = node.binaryLeft();
    right = node.binaryRight();
  }

  // Convert multiplication or division by a power of 2 into a shift
  if ((node.kind == NodeKind.MULTIPLY || (node.kind == NodeKind.DIVIDE || node.kind == NodeKind.REMAINDER) && node.resolvedType.isUnsigned()) &&
      right.kind == NodeKind.INT && isPositivePowerOf2(right.intValue)) {
    // Extract the shift from the value
    var shift = -1;
    var value = right.intValue;
    while (value != 0) {
      value = value >> 1;
      shift = shift + 1;
    }

    // "x * 16" => "x << 4"
    if (node.kind == NodeKind.MULTIPLY) {
      node.kind = NodeKind.SHIFT_LEFT;
      right.intValue = shift;
    }

    // "x / 16" => "x >> 4" when x is unsigned
    else if (node.kind == NodeKind.DIVIDE) {
      node.kind = NodeKind.SHIFT_RIGHT;
      right.intValue = shift;
    }

    // "x % 16" => "x & 15" when x is unsigned
    else if (node.kind == NodeKind.REMAINDER) {
      node.kind = NodeKind.BITWISE_AND;
      right.intValue = right.intValue - 1;
    }

    else {
      assert(false);
    }
  }

  // Flip addition with negation into subtraction
  else if (node.kind == NodeKind.ADD && right.kind == NodeKind.NEGATIVE) {
    var value = right.unaryValue();
    node.kind = NodeKind.SUBTRACT;
    value.remove();
    right.replaceWith(value);
  }

  // Flip addition with negative constants into subtraction
  else if (node.kind == NodeKind.ADD && right.isNegativeInteger()) {
    node.kind = NodeKind.SUBTRACT;
    right.intValue = -right.intValue;
  }
}

function binaryHasUnsignedArguments(node: Node): bool {
  var left = node.binaryLeft();
  var right = node.binaryRight();
  var leftType = left.resolvedType;
  var rightType = right.resolvedType;

  return
    leftType.isUnsigned() && rightType.isUnsigned() ||
    leftType.isUnsigned() && right.isNonNegativeInteger() ||
    left.isNonNegativeInteger() && rightType.isUnsigned();
}

function isSymbolAccessAllowed(context: CheckContext, symbol: Symbol, range: Range): bool {
  if (symbol.isUnsafe() && !context.isUnsafeAllowed) {
    context.log.error(range, String_appendNew(String_append(
      String_new("Cannot use symbol '"),
      symbol.name),
      "' outside an unsafe block"));
    return false;
  }

  return true;
}

function resolve(context: CheckContext, node: Node, parentScope: Scope): void {
  assert(node.kind == NodeKind.GLOBAL || parentScope != null);

  if (node.resolvedType != null) {
    return;
  }

  node.resolvedType = context.errorType;

  if (node.kind == NodeKind.GLOBAL) {
    resolveChildren(context, node, node.scope);
  }

  else if (node.kind == NodeKind.CLASS) {
    initializeSymbol(context, node.symbol);
    resolveChildren(context, node, node.scope);
    node.symbol.determineClassLayout(context);
  }

  else if (node.kind == NodeKind.ENUM) {
    initializeSymbol(context, node.symbol);
    resolveChildren(context, node, node.scope);
  }

  else if (node.kind == NodeKind.FUNCTION) {
    var body = node.functionBody();
    initializeSymbol(context, node.symbol);

    if (body != null) {
      var oldReturnType = context.currentReturnType;
      var oldUnsafeAllowed = context.isUnsafeAllowed;
      context.currentReturnType = node.functionReturnType().resolvedType;
      context.isUnsafeAllowed = node.isUnsafe();
      resolveChildren(context, body, node.scope);
      context.currentReturnType = oldReturnType;
      context.isUnsafeAllowed = oldUnsafeAllowed;
    }
  }

  else if (node.kind == NodeKind.VARIABLE) {
    var symbol = node.symbol;
    initializeSymbol(context, symbol);

    var value = node.variableValue();
    if (value != null) {
      resolveAsExpression(context, value, parentScope);
      checkConversion(context, value, symbol.resolvedTypeUnderlyingIfEnumValue(context), ConversionKind.IMPLICIT);

      // Variable initializers must be compile-time constants
      if (symbol.kind == SymbolKind.VARIABLE_GLOBAL && value.kind != NodeKind.INT && value.kind != NodeKind.BOOL && value.kind != NodeKind.NULL) {
        context.log.error(value.range, String_new("Global initializers must be compile-time constants"));
      }
    }

    else if (symbol.resolvedType != context.errorType) {
      value = createDefaultValueForType(context, symbol.resolvedType);
      resolveAsExpression(context, value, parentScope);
      node.appendChild(value);
    }

    // Allocate global variables
    if (symbol.kind == SymbolKind.VARIABLE_GLOBAL && symbol.resolvedType != context.errorType) {
      symbol.offset = context.allocateGlobalVariableOffset(symbol.resolvedType.variableSizeOf(), symbol.resolvedType.variableAlignmentOf());
    }
  }

  else if (node.kind == NodeKind.BREAK || node.kind == NodeKind.CONTINUE) {
    var found = false;
    var n = node;
    while (n != null) {
      if (n.kind == NodeKind.WHILE) {
        found = true;
        break;
      }
      n = n.parent;
    }
    if (!found) {
      context.log.error(node.range, String_new("Cannot use this statement outside of a loop"));
    }
  }

  else if (node.kind == NodeKind.BLOCK) {
    var oldUnsafeAllowed = context.isUnsafeAllowed;
    if (node.isUnsafe()) context.isUnsafeAllowed = true;
    resolveChildren(context, node, node.scope);
    context.isUnsafeAllowed = oldUnsafeAllowed;
  }

  else if (node.kind == NodeKind.CONSTANTS || node.kind == NodeKind.VARIABLES) {
    resolveChildren(context, node, parentScope);
  }

  else if (node.kind == NodeKind.INT) {
    node.resolvedType = node.intValue < 0 ? context.uintType : context.intType;
  }

  else if (node.kind == NodeKind.STRING) {
    node.resolvedType = context.stringType;
  }

  else if (node.kind == NodeKind.BOOL) {
    node.resolvedType = context.boolType;
  }

  else if (node.kind == NodeKind.NULL) {
    node.resolvedType = context.nullType;
  }

  else if (node.kind == NodeKind.INDEX) {
    resolveChildrenAsExpressions(context, node, parentScope);

    var target = node.indexTarget();
    var type = target.resolvedType;

    if (type != context.errorType) {
      var symbol = type.isClass() ? type.findMember(String_new("[]")) : null;

      if (symbol == null) {
        context.log.error(node.internalRange, String_appendNew(String_append(
          String_new("Cannot index into type '"),
          target.resolvedType.toString()),
          "'"));
      }

      else {
        assert(symbol.kind == SymbolKind.FUNCTION_INSTANCE);

        // Convert to a regular function call and resolve that instead
        node.kind = NodeKind.CALL;
        target.remove();
        node.insertChildBefore(node.firstChild, createMemberReference(target, symbol));
        node.resolvedType = null;
        resolveAsExpression(context, node, parentScope);
      }
    }
  }

  else if (node.kind == NodeKind.ALIGN_OF) {
    var type = node.alignOfType();
    resolveAsType(context, type, parentScope);
    node.resolvedType = context.intType;

    if (type.resolvedType != context.errorType) {
      node.becomeIntegerConstant(type.resolvedType.allocationAlignmentOf());
    }
  }

  else if (node.kind == NodeKind.SIZE_OF) {
    var type = node.sizeOfType();
    resolveAsType(context, type, parentScope);
    node.resolvedType = context.intType;

    if (type.resolvedType != context.errorType) {
      node.becomeIntegerConstant(type.resolvedType.allocationSizeOf());
    }
  }

  else if (node.kind == NodeKind.THIS) {
    var symbol = parentScope.findNested(String_new("this"), FindNested.NORMAL);
    if (symbol == null) {
      context.log.error(node.range, String_new("Cannot use 'this' here"));
    } else {
      node.becomeSymbolReference(symbol);
    }
  }

  else if (node.kind == NodeKind.PARSE_ERROR) {
    node.resolvedType = context.errorType;
  }

  else if (node.kind == NodeKind.NAME) {
    var name = node.stringValue;
    var symbol = parentScope.findNested(name, FindNested.NORMAL);

    if (symbol == null) {
      var message = String_appendNew(String_append(
        String_new("No symbol named '"),
        name),
        "' here");

      // In JavaScript, "this." before instance symbols is required
      symbol = parentScope.findNested(name, FindNested.ALLOW_INSTANCE_ERRORS);
      if (symbol != null) {
        message = String_appendNew(String_append(String_appendNew(
          message,
          ", did you mean 'this."),
          symbol.name),
          "'?");
      }

      // People may try to use types from TypeScript
      else if (String_equalNew(name, "number")) message = String_appendNew(message, ", did you mean 'int'?");
      else if (String_equalNew(name, "boolean")) message = String_appendNew(message, ", did you mean 'bool'?");

      context.log.error(node.range, message);
    }

    else if (symbol.state == SymbolState.INITIALIZING) {
      context.log.error(node.range, String_appendNew(String_append(
        String_new("Cyclic reference to symbol '"),
        name),
        "' here"));
    }

    else if (isFunction(symbol.kind) && (node.parent.kind != NodeKind.CALL || node != node.parent.callValue())) {
      context.log.error(node.range, String_new("Bare function references are not allowed"));
    }

    else if (isSymbolAccessAllowed(context, symbol, node.range)) {
      initializeSymbol(context, symbol);
      node.symbol = symbol;
      node.resolvedType = symbol.resolvedType;

      // Inline constants
      if (symbol.kind == SymbolKind.VARIABLE_CONSTANT) {
        if (symbol.resolvedType == context.boolType) {
          node.becomeBooleanConstant(symbol.offset != 0);
        } else {
          node.becomeIntegerConstant(symbol.offset);
        }
      }
    }
  }

  else if (node.kind == NodeKind.CAST) {
    var value = node.castValue();
    var type = node.castType();
    resolveAsExpression(context, value, parentScope);
    resolveAsType(context, type, parentScope);
    var castedType = type.resolvedType;
    checkConversion(context, value, castedType, ConversionKind.EXPLICIT);
    node.resolvedType = castedType;

    // Automatically fold constants
    if (value.kind == NodeKind.INT && castedType.isInteger()) {
      var result = value.intValue;
      var shift = 32 - castedType.integerBitCount();
      node.becomeIntegerConstant(castedType.isUnsigned()
        ? castedType.integerBitMask() as int & result
        : result << shift >> shift);
    }
  }

  else if (node.kind == NodeKind.DOT) {
    var target = node.dotTarget();
    resolve(context, target, parentScope);

    if (target.resolvedType != context.errorType) {
      if (target.isType() && target.resolvedType.isEnum() ||
          !target.isType() && target.resolvedType.isClass()) {
        var child = target.resolvedType.symbol.node.firstChild;
        var name = node.stringValue;

        // Empty names are left over from parse errors that have already been reported
        if (String_length(name) > 0) {
          var symbol = target.resolvedType.findMember(name);

          if (symbol == null) {
            context.log.error(node.internalRange, String_appendNew(String_append(String_appendNew(String_append(
              String_new("No member named '"),
              name),
              "' on type '"),
              target.resolvedType.toString()),
              "'"));
          }

          else if (isSymbolAccessAllowed(context, symbol, node.internalRange)) {
            initializeSymbol(context, symbol);
            node.symbol = symbol;
            node.resolvedType = symbol.resolvedType;

            // Inline constants
            if (symbol.kind == SymbolKind.VARIABLE_CONSTANT) {
              node.becomeIntegerConstant(symbol.offset);
            }
          }
        }
      }

      else {
        context.log.error(node.internalRange, String_appendNew(String_append(
          String_new("The type '"),
          target.resolvedType.toString()),
          "' has no members"));
      }
    }
  }

  else if (node.kind == NodeKind.CALL) {
    var value = node.callValue();
    resolveAsExpression(context, value, parentScope);

    if (value.resolvedType != context.errorType) {
      var symbol = value.symbol;

      // Only functions are callable
      if (symbol == null || !isFunction(symbol.kind)) {
        context.log.error(value.range, String_appendNew(String_append(
          String_new("Cannot call value of type '"),
          value.resolvedType.toString()),
          "'"));
      }

      else {
        initializeSymbol(context, symbol);

        var returnType = symbol.node.functionReturnType();
        var argumentVariable = symbol.node.functionFirstArgumentIgnoringThis();
        var argumentValue = value.nextSibling;

        // Match argument values with variables
        while (argumentVariable != returnType && argumentValue != null) {
          resolveAsExpression(context, argumentValue, parentScope);
          checkConversion(context, argumentValue, argumentVariable.symbol.resolvedType, ConversionKind.IMPLICIT);
          argumentVariable = argumentVariable.nextSibling;
          argumentValue = argumentValue.nextSibling;
        }

        // Not enough arguments?
        if (argumentVariable != returnType) {
          context.log.error(node.internalRange, String_appendNew(String_append(
            String_new("Not enough arguments for function '"),
            symbol.name),
            "'"));
        }

        // Too many arguments?
        else if (argumentValue != null) {
          while (argumentValue != null) {
            resolveAsExpression(context, argumentValue, parentScope);
            argumentValue = argumentValue.nextSibling;
          }
          context.log.error(node.internalRange, String_appendNew(String_append(
            String_new("Too many arguments for function '"),
            symbol.name),
            "'"));
        }

        // Pass the return type along
        node.resolvedType = returnType.resolvedType;
      }
    }
  }

  else if (node.kind == NodeKind.RETURN) {
    var value = node.returnValue();

    if (value != null) {
      resolveAsExpression(context, value, parentScope);

      if (context.currentReturnType != null) {
        if (context.currentReturnType != context.voidType) {
          checkConversion(context, value, context.currentReturnType, ConversionKind.IMPLICIT);
        }

        else {
          context.log.error(value.range, String_new("Unexpected return value in function returning 'void'"));
        }
      }
    }

    else if (context.currentReturnType != null && context.currentReturnType != context.voidType) {
      context.log.error(node.range, String_appendNew(String_append(
        String_new("Expected return value in function returning '"),
        context.currentReturnType.toString()),
        "'"));
    }
  }

  else if (node.kind == NodeKind.EMPTY) {
  }

  else if (node.kind == NodeKind.EXPRESSION) {
    resolveAsExpression(context, node.expressionValue(), parentScope);
  }

  else if (node.kind == NodeKind.WHILE) {
    var value = node.whileValue();
    var body = node.whileBody();
    resolveAsExpression(context, value, parentScope);
    checkConversion(context, value, context.boolType, ConversionKind.IMPLICIT);
    resolve(context, body, parentScope);
  }

  else if (node.kind == NodeKind.IF) {
    var value = node.ifValue();
    var yes = node.ifTrue();
    var no = node.ifFalse();
    resolveAsExpression(context, value, parentScope);
    checkConversion(context, value, context.boolType, ConversionKind.IMPLICIT);
    resolve(context, yes, parentScope);
    if (no != null) {
      resolve(context, no, parentScope);
    }
  }

  else if (node.kind == NodeKind.HOOK) {
    var value = node.hookValue();
    var yes = node.hookTrue();
    var no = node.hookFalse();
    resolveAsExpression(context, value, parentScope);
    checkConversion(context, value, context.boolType, ConversionKind.IMPLICIT);
    resolve(context, yes, parentScope);
    resolve(context, no, parentScope);
    var commonType = (yes.resolvedType == context.nullType ? no : yes).resolvedType;
    if (yes.resolvedType != commonType && (yes.resolvedType != context.nullType || !commonType.isReference(context)) &&
        no.resolvedType != commonType && (no.resolvedType != context.nullType || !commonType.isReference(context))) {
      context.log.error(spanRanges(yes.range, no.range), String_appendNew(String_append(String_appendNew(String_append(
        String_new("Type '"),
        yes.resolvedType.toString()),
        "' is not the same as type '"),
        no.resolvedType.toString()),
        "'"));
    }
    node.resolvedType = commonType;
  }

  else if (node.kind == NodeKind.ASSIGN) {
    var left = node.binaryLeft();
    var right = node.binaryRight();

    if (left.kind == NodeKind.INDEX) {
      resolveChildrenAsExpressions(context, left, parentScope);

      var target = left.indexTarget();
      var type = target.resolvedType;

      if (type != context.errorType) {
        var symbol = type.isClass() ? type.findMember(String_new("[]=")) : null;

        if (symbol == null) {
          context.log.error(left.internalRange, String_appendNew(String_append(
            String_new("Cannot index into type '"),
            target.resolvedType.toString()),
            "'"));
        }

        else {
          assert(symbol.kind == SymbolKind.FUNCTION_INSTANCE);

          // Convert to a regular function call and resolve that instead
          node.kind = NodeKind.CALL;
          target.remove();
          left.remove();
          while (left.lastChild != null) {
            var value = left.lastChild;
            value.remove();
            node.insertChildBefore(node.firstChild, value);
          }
          node.insertChildBefore(node.firstChild, createMemberReference(target, symbol));
          node.internalRange = spanRanges(left.internalRange, right.range);
          node.resolvedType = null;
          resolveAsExpression(context, node, parentScope);
          return;
        }
      }
    }

    resolveAsExpression(context, left, parentScope);
    resolveAsExpression(context, right, parentScope);
    checkConversion(context, right, left.resolvedType, ConversionKind.IMPLICIT);
    checkStorage(context, left);
    node.resolvedType = left.resolvedType;
  }

  else if (
      node.kind == NodeKind.ADD || node.kind == NodeKind.SUBTRACT || node.kind == NodeKind.MULTIPLY || node.kind == NodeKind.DIVIDE || node.kind == NodeKind.REMAINDER ||
      node.kind == NodeKind.BITWISE_AND || node.kind == NodeKind.BITWISE_OR || node.kind == NodeKind.BITWISE_XOR ||
      node.kind == NodeKind.SHIFT_LEFT || node.kind == NodeKind.SHIFT_RIGHT) {
    var left = node.binaryLeft();
    var right = node.binaryRight();

    resolveAsExpression(context, left, parentScope);
    resolveAsExpression(context, right, parentScope);

    var commonType = binaryHasUnsignedArguments(node) ? context.uintType : context.intType;
    if (commonType == context.uintType) {
      node.flags = node.flags | NODE_FLAG_UNSIGNED_OPERATOR;
    }
    checkConversion(context, left, commonType, ConversionKind.IMPLICIT);
    checkConversion(context, right, commonType, ConversionKind.IMPLICIT);
    node.resolvedType = commonType;

    // Automatically fold constants
    if (left.kind == NodeKind.INT && right.kind == NodeKind.INT) {
      var inputLeft = left.intValue;
      var inputRight = right.intValue;
      var output = 0;
      if (node.kind == NodeKind.ADD) output = inputLeft + inputRight;
      else if (node.kind == NodeKind.BITWISE_AND) output = inputLeft & inputRight;
      else if (node.kind == NodeKind.BITWISE_OR) output = inputLeft | inputRight;
      else if (node.kind == NodeKind.BITWISE_XOR) output = inputLeft ^ inputRight;
      else if (node.kind == NodeKind.DIVIDE) output = inputLeft / inputRight;
      else if (node.kind == NodeKind.MULTIPLY) output = inputLeft * inputRight;
      else if (node.kind == NodeKind.REMAINDER) output = inputLeft % inputRight;
      else if (node.kind == NodeKind.SHIFT_LEFT) output = inputLeft << inputRight;
      else if (node.kind == NodeKind.SHIFT_RIGHT) output = inputLeft >> inputRight;
      else if (node.kind == NodeKind.SUBTRACT) output = inputLeft - inputRight;
      else return;
      node.becomeIntegerConstant(output);
    }

    else {
      simplifyBinary(node);
    }
  }

  else if (
      node.kind == NodeKind.LESS_THAN || node.kind == NodeKind.LESS_THAN_EQUAL ||
      node.kind == NodeKind.GREATER_THAN || node.kind == NodeKind.GREATER_THAN_EQUAL) {
    var left = node.binaryLeft();
    var right = node.binaryRight();
    resolveAsExpression(context, left, parentScope);
    resolveAsExpression(context, right, parentScope);
    var leftType = left.resolvedType;
    var rightType = right.resolvedType;
    var expectedType =
      leftType == rightType && leftType.isEnum() ? leftType :
      binaryHasUnsignedArguments(node) ? context.uintType :
      context.intType;
    if (expectedType == context.uintType) {
      node.flags = node.flags | NODE_FLAG_UNSIGNED_OPERATOR;
    }
    checkConversion(context, left, expectedType, ConversionKind.IMPLICIT);
    checkConversion(context, right, expectedType, ConversionKind.IMPLICIT);
    node.resolvedType = context.boolType;
  }

  else if (node.kind == NodeKind.LOGICAL_OR || node.kind == NodeKind.LOGICAL_AND) {
    var left = node.binaryLeft();
    var right = node.binaryRight();
    resolveAsExpression(context, left, parentScope);
    resolveAsExpression(context, right, parentScope);
    checkConversion(context, left, context.boolType, ConversionKind.IMPLICIT);
    checkConversion(context, right, context.boolType, ConversionKind.IMPLICIT);
    node.resolvedType = context.boolType;
  }

  else if (node.kind == NodeKind.EQUAL || node.kind == NodeKind.NOT_EQUAL) {
    var left = node.binaryLeft();
    var right = node.binaryRight();
    resolveAsExpression(context, left, parentScope);
    resolveAsExpression(context, right, parentScope);
    node.resolvedType = context.boolType;

    var leftType = left.resolvedType;
    var rightType = right.resolvedType;

    if (leftType != context.errorType && rightType != context.errorType && (leftType == rightType ? leftType == context.voidType :
        (leftType != context.nullType || !rightType.isReference(context)) &&
        (rightType != context.nullType || !leftType.isReference(context)) &&
        (!leftType.isUnsigned() || !right.isNonNegativeInteger()) &&
        (!rightType.isUnsigned() || !left.isNonNegativeInteger()))) {
      context.log.error(node.range, String_appendNew(String_append(String_appendNew(String_append(
        String_new("Cannot compare type '"),
        leftType.toString()),
        "' with type '"),
        rightType.toString()),
        "'"));
    }
  }

  else if (node.kind == NodeKind.COMPLEMENT || node.kind == NodeKind.NEGATIVE || node.kind == NodeKind.POSITIVE) {
    var value = node.unaryValue();
    resolveAsExpression(context, value, parentScope);
    var expectedType = value.resolvedType.isUnsigned() ? context.uintType : context.intType;
    checkConversion(context, value, expectedType, ConversionKind.IMPLICIT);
    node.resolvedType = node.kind == NodeKind.NEGATIVE ? context.intType : expectedType;

    // Automatically fold constants
    if (value.kind == NodeKind.INT) {
      var input = value.intValue;
      var output = input;
      if (node.kind == NodeKind.COMPLEMENT) output = ~input;
      else if (node.kind == NodeKind.NEGATIVE) output = -input;
      node.becomeIntegerConstant(output);
    }
  }

  else if (node.kind == NodeKind.POSTFIX_DECREMENT || node.kind == NodeKind.POSTFIX_INCREMENT ||
      node.kind == NodeKind.PREFIX_DECREMENT || node.kind == NodeKind.PREFIX_INCREMENT) {
    context.log.error(node.range, String_new("This operator is currently unsupported"));
  }

  else if (node.kind == NodeKind.NOT) {
    var value = node.unaryValue();
    resolveAsExpression(context, value, parentScope);
    checkConversion(context, value, context.boolType, ConversionKind.IMPLICIT);
    node.resolvedType = context.boolType;
  }

  else if (node.kind == NodeKind.NEW) {
    var type = node.newType();
    resolveAsType(context, type, parentScope);

    if (type.resolvedType != context.errorType) {
      if (!type.resolvedType.isClass()) {
        context.log.error(type.range, String_appendNew(String_append(
          String_new("Cannot construct type '"),
          type.resolvedType.toString()),
          "'"));
      }

      else {
        node.resolvedType = type.resolvedType;
      }
    }

    // TODO: Constructors
    if (type.nextSibling != null) {
      context.log.error(node.internalRange, String_new("Constructors with arguments are not supported yet"));
    }
  }

  else {
    assert(false);
  }
}

function check(global: Node, log: Log): CheckContext {
  var context = new CheckContext();
  context.log = log;
  initialize(context, global, null);
  resolve(context, global, null);
  return context;
}
enum CompileTarget {
  NONE,
  JAVASCRIPT,
  WEBASSEMBLY,
}

class Compiler {
  log: Log;
  global: Node;
  target: CompileTarget;
  context: CheckContext;
  wasm: ByteArray;
  js: String;

  initialize(target: CompileTarget): void {
    assert(this.log == null);
    this.log = new Log();
    this.global = new Node();
    this.global.kind = NodeKind.GLOBAL;
    this.target = target;

    if (target == CompileTarget.WEBASSEMBLY) {
      this.addInput(String_new("<native>"), String_new(libraryForWebAssembly()));
    }
  }

  addInput(name: String, contents: String): void {
    var source = new Source();
    source.name = name;
    source.contents = contents;

    var firstToken = tokenize(source, this.log);
    if (firstToken != null) {
      var file = parse(firstToken, this.log);

      if (file != null) {
        while (file.firstChild != null) {
          var child = file.firstChild;
          child.remove();
          this.global.appendChild(child);
        }
      }
    }
  }

  finish(): bool {
    assert(this.context == null);
    this.context = check(this.global, this.log);

    if (this.log.first != null) {
      return false;
    }

    if (this.target == CompileTarget.JAVASCRIPT) {
      this.js = jsEmit(this.global, this.context);
    }

    else if (this.target == CompileTarget.WEBASSEMBLY) {
      this.wasm = new ByteArray();
      wasmEmit(this.global, this.context, this.wasm);
    }

    return true;
  }
}

extern function Compiler_addInput(compiler: Compiler, name: String, contents: String): void {
  compiler.addInput(name, contents);
}

extern function Compiler_finish(compiler: Compiler): void {
  compiler.finish();
}

extern function Compiler_wasm(compiler: Compiler): ByteArray {
  return compiler.wasm;
}

extern function Compiler_js(compiler: Compiler): String {
  return compiler.js;
}

extern function Compiler_log(compiler: Compiler): String {
  return compiler.log.toString();
}
extern function Compiler_new(target: CompileTarget): Compiler {
  var compiler = new Compiler();
  compiler.initialize(target);
  return compiler;
}
declare function assert(truth: bool): void;

// An external string handle for now
class String {}

declare function String_new(text: string): String;
declare function String_newLength(text: string, length: int): String;
declare function String_length(self: String): int;
declare function String_get(self: String, index: int): int;
declare function String_append(self: String, other: String): String;
declare function String_appendNew(self: String, other: string): String;
declare function String_equal(self: String, other: String): bool;
declare function String_equalNew(self: String, other: string): bool;
declare function String_slice(self: String, start: int, end: int): String;
declare function String_toStringSigned(value: int): String;
declare function String_toStringUnsigned(value: uint): String;
declare function String_quote(self: String): String;

function isPositivePowerOf2(value: int): bool {
  return value > 0 && (value & (value - 1)) == 0;
}

function alignToNextMultipleOf(offset: int, alignment: int): int {
  assert(isPositivePowerOf2(alignment));
  return (offset + alignment - 1) & -alignment;
}
enum EmitBinary {
  NORMAL,
  CAST_TO_INT,
}

class JsResult {
  context: CheckContext;
  code: String;
  indent: int;
  foundMultiply: bool;
  previousNode: Node;

  emitIndent(): void {
    var i = this.indent;
    while (i > 0) {
      this.code = String_appendNew(this.code, "  ");
      i = i - 1;
    }
  }

  emitText(text: string): void {
    this.code = String_appendNew(this.code, text);
  }

  emitString(text: String): void {
    this.code = String_append(this.code, text);
  }

  emitNewlineBefore(node: Node): void {
    if (this.previousNode != null && (!jsIsCompactNodeKind(this.previousNode.kind) || !jsIsCompactNodeKind(node.kind))) {
      this.emitText("\n");
    }
    this.previousNode = null;
  }

  emitNewlineAfter(node: Node): void {
    this.previousNode = node;
  }

  emitStatements(node: Node): void {
    while (node != null) {
      this.emitStatement(node);
      node = node.nextSibling;
    }
  }

  emitBlock(node: Node): void {
    this.previousNode = null;
    this.emitText("{\n");
    this.indent = this.indent + 1;
    this.emitStatements(node.firstChild);
    this.indent = this.indent - 1;
    this.emitIndent();
    this.emitText("}");
    this.previousNode = null;
  }

  emitUnary(node: Node, parentPrecedence: Precedence, operator: string): void {
    var isPostfix = isUnaryPostfix(node.kind);
    var operatorPrecedence = isPostfix ? Precedence.UNARY_POSTFIX : Precedence.UNARY_PREFIX;

    if (parentPrecedence > operatorPrecedence) {
      this.emitText("(");
    }

    if (!isPostfix) {
      this.emitText(operator);
    }

    this.emitExpression(node.unaryValue(), operatorPrecedence);

    if (isPostfix) {
      this.emitText(operator);
    }

    if (parentPrecedence > operatorPrecedence) {
      this.emitText(")");
    }
  }

  emitBinary(node: Node, parentPrecedence: Precedence, operator: string, operatorPrecedence: Precedence, mode: EmitBinary): void {
    var isRightAssociative = node.kind == NodeKind.ASSIGN;
    var parentKind = node.parent.kind;
    var isUnsigned = node.isUnsignedOperator();

    // Avoid casting when the parent operator already does a cast
    var shouldCastToInt = mode == EmitBinary.CAST_TO_INT && (isUnsigned ||
      parentKind != NodeKind.SHIFT_LEFT && parentKind != NodeKind.SHIFT_RIGHT &&
      parentKind != NodeKind.BITWISE_OR && parentKind != NodeKind.BITWISE_AND && parentKind != NodeKind.BITWISE_XOR);
    var selfPrecedence = shouldCastToInt ? isUnsigned ? Precedence.SHIFT : Precedence.BITWISE_OR : parentPrecedence;

    if (parentPrecedence > selfPrecedence) {
      this.emitText("(");
    }

    if (selfPrecedence > operatorPrecedence) {
      this.emitText("(");
    }

    this.emitExpression(node.binaryLeft(), isRightAssociative ? (operatorPrecedence as int + 1) as Precedence : operatorPrecedence);
    this.emitText(operator);
    this.emitExpression(node.binaryRight(), isRightAssociative ? operatorPrecedence : (operatorPrecedence as int + 1) as Precedence);

    if (selfPrecedence > operatorPrecedence) {
      this.emitText(")");
    }

    if (shouldCastToInt) {
      this.emitText(isUnsigned ? " >>> 0" : " | 0");
    }

    if (parentPrecedence > selfPrecedence) {
      this.emitText(")");
    }
  }

  emitCommaSeparatedExpressions(start: Node, stop: Node): void {
    while (start != stop) {
      this.emitExpression(start, Precedence.LOWEST);
      start = start.nextSibling;

      if (start != stop) {
        this.emitText(", ");
      }
    }
  }

  emitExpression(node: Node, parentPrecedence: Precedence): void {
    assert(node.resolvedType != null);

    if (node.kind == NodeKind.NAME) {
      var symbol = node.symbol;
      if (symbol.kind == SymbolKind.FUNCTION_GLOBAL && symbol.node.isDeclare()) {
        this.emitText("globals.");
      }
      this.emitString(symbol.name);
    }

    else if (node.kind == NodeKind.NULL) {
      this.emitText("null");
    }

    else if (node.kind == NodeKind.BOOL) {
      this.emitText(node.intValue != 0 ? "true" : "false");
    }

    else if (node.kind == NodeKind.INT) {
      this.emitString(node.resolvedType.isUnsigned()
        ? String_toStringUnsigned(node.intValue as uint)
        : String_toStringSigned(node.intValue));
    }

    else if (node.kind == NodeKind.STRING) {
      this.emitString(String_quote(node.stringValue));
    }

    else if (node.kind == NodeKind.CAST) {
      var context = this.context;
      var value = node.castValue();
      var from = value.resolvedType.underlyingType(context);
      var type = node.resolvedType.underlyingType(context);

      // The cast isn't needed if it's to a wider integer type
      if (from == type || from.symbol.byteSize < type.symbol.byteSize) {
        this.emitExpression(value, parentPrecedence);
      }

      else {
        // Sign-extend
        if (type == context.byteType || type == context.shortType) {
          if (parentPrecedence > Precedence.SHIFT) {
            this.emitText("(");
          }

          var shift = String_toStringSigned(32 - type.symbol.byteSize * 8);
          this.emitExpression(value, Precedence.SHIFT);
          this.emitText(" << ");
          this.emitString(shift);
          this.emitText(" >> ");
          this.emitString(shift);

          if (parentPrecedence > Precedence.SHIFT) {
            this.emitText(")");
          }
        }

        // Mask
        else if (type == context.ubyteType || type == context.ushortType) {
          if (parentPrecedence > Precedence.BITWISE_AND) {
            this.emitText("(");
          }

          this.emitExpression(value, Precedence.BITWISE_AND);
          this.emitText(" & ");
          this.emitString(String_toStringUnsigned(type.integerBitMask()));

          if (parentPrecedence > Precedence.BITWISE_AND) {
            this.emitText(")");
          }
        }

        // Truncate signed
        else if (type == context.intType) {
          if (parentPrecedence > Precedence.BITWISE_OR) {
            this.emitText("(");
          }

          this.emitExpression(value, Precedence.BITWISE_OR);
          this.emitText(" | 0");

          if (parentPrecedence > Precedence.BITWISE_OR) {
            this.emitText(")");
          }
        }

        // Truncate unsigned
        else if (type == context.uintType) {
          if (parentPrecedence > Precedence.SHIFT) {
            this.emitText("(");
          }

          this.emitExpression(value, Precedence.SHIFT);
          this.emitText(" >>> 0");

          if (parentPrecedence > Precedence.SHIFT) {
            this.emitText(")");
          }
        }

        // No cast needed
        else {
          this.emitExpression(value, parentPrecedence);
        }
      }
    }

    else if (node.kind == NodeKind.DOT) {
      this.emitExpression(node.dotTarget(), Precedence.MEMBER);
      this.emitSymbolAccess(node.symbol);
    }

    else if (node.kind == NodeKind.HOOK) {
      if (parentPrecedence > Precedence.ASSIGN) {
        this.emitText("(");
      }

      this.emitExpression(node.hookValue(), Precedence.LOGICAL_OR);
      this.emitText(" ? ");
      this.emitExpression(node.hookTrue(), Precedence.ASSIGN);
      this.emitText(" : ");
      this.emitExpression(node.hookFalse(), Precedence.ASSIGN);

      if (parentPrecedence > Precedence.ASSIGN) {
        this.emitText(")");
      }
    }

    else if (node.kind == NodeKind.CALL) {
      var value = node.callValue();
      var isDeclaredInstance = value.kind == NodeKind.DOT && value.symbol.node.isDeclare();

      if (isDeclaredInstance && String_equalNew(value.symbol.name, "[]")) {
        this.emitExpression(value.dotTarget(), Precedence.UNARY_POSTFIX);
        this.emitText("[");
        this.emitCommaSeparatedExpressions(value.nextSibling, null);
        this.emitText("]");
      }

      else if (isDeclaredInstance && String_equalNew(value.symbol.name, "[]=")) {
        if (parentPrecedence > Precedence.ASSIGN) {
          this.emitText("(");
        }

        this.emitExpression(value.dotTarget(), Precedence.UNARY_POSTFIX);
        this.emitText("[");
        this.emitCommaSeparatedExpressions(value.nextSibling, node.lastChild);
        this.emitText("] = ");
        this.emitExpression(node.lastChild, Precedence.ASSIGN);

        if (parentPrecedence > Precedence.ASSIGN) {
          this.emitText(")");
        }
      }

      else {
        this.emitExpression(value, Precedence.UNARY_POSTFIX);
        this.emitText("(");
        this.emitCommaSeparatedExpressions(value.nextSibling, null);
        this.emitText(")");
      }
    }

    else if (node.kind == NodeKind.NEW) {
      this.emitText("new ");
      this.emitExpression(node.newType(), Precedence.UNARY_POSTFIX);
      this.emitText("()");
    }

    else if (node.kind == NodeKind.COMPLEMENT) this.emitUnary(node, parentPrecedence, "~");
    else if (node.kind == NodeKind.NEGATIVE) this.emitUnary(node, parentPrecedence, "-");
    else if (node.kind == NodeKind.NOT) this.emitUnary(node, parentPrecedence, "!");
    else if (node.kind == NodeKind.POSITIVE) this.emitUnary(node, parentPrecedence, "+");
    else if (node.kind == NodeKind.PREFIX_INCREMENT) this.emitUnary(node, parentPrecedence, "++");
    else if (node.kind == NodeKind.PREFIX_DECREMENT) this.emitUnary(node, parentPrecedence, "--");
    else if (node.kind == NodeKind.POSTFIX_INCREMENT) this.emitUnary(node, parentPrecedence, "++");
    else if (node.kind == NodeKind.POSTFIX_DECREMENT) this.emitUnary(node, parentPrecedence, "--");

    else if (node.kind == NodeKind.ADD) this.emitBinary(node, parentPrecedence, " + ", Precedence.ADD, EmitBinary.CAST_TO_INT);
    else if (node.kind == NodeKind.ASSIGN) this.emitBinary(node, parentPrecedence, " = ", Precedence.ASSIGN, EmitBinary.NORMAL);
    else if (node.kind == NodeKind.BITWISE_AND) this.emitBinary(node, parentPrecedence, " & ", Precedence.BITWISE_AND, EmitBinary.NORMAL);
    else if (node.kind == NodeKind.BITWISE_OR) this.emitBinary(node, parentPrecedence, " | ", Precedence.BITWISE_OR, EmitBinary.NORMAL);
    else if (node.kind == NodeKind.BITWISE_XOR) this.emitBinary(node, parentPrecedence, " ^ ", Precedence.BITWISE_XOR, EmitBinary.NORMAL);
    else if (node.kind == NodeKind.DIVIDE) this.emitBinary(node, parentPrecedence, " / ", Precedence.MULTIPLY, EmitBinary.CAST_TO_INT);
    else if (node.kind == NodeKind.EQUAL) this.emitBinary(node, parentPrecedence, " === ", Precedence.EQUAL, EmitBinary.NORMAL);
    else if (node.kind == NodeKind.GREATER_THAN) this.emitBinary(node, parentPrecedence, " > ", Precedence.COMPARE, EmitBinary.NORMAL);
    else if (node.kind == NodeKind.GREATER_THAN_EQUAL) this.emitBinary(node, parentPrecedence, " >= ", Precedence.COMPARE, EmitBinary.NORMAL);
    else if (node.kind == NodeKind.LESS_THAN) this.emitBinary(node, parentPrecedence, " < ", Precedence.COMPARE, EmitBinary.NORMAL);
    else if (node.kind == NodeKind.LESS_THAN_EQUAL) this.emitBinary(node, parentPrecedence, " <= ", Precedence.COMPARE, EmitBinary.NORMAL);
    else if (node.kind == NodeKind.LOGICAL_AND) this.emitBinary(node, parentPrecedence, " && ", Precedence.LOGICAL_AND, EmitBinary.NORMAL);
    else if (node.kind == NodeKind.LOGICAL_OR) this.emitBinary(node, parentPrecedence, " || ", Precedence.LOGICAL_OR, EmitBinary.NORMAL);
    else if (node.kind == NodeKind.NOT_EQUAL) this.emitBinary(node, parentPrecedence, " !== ", Precedence.EQUAL, EmitBinary.NORMAL);
    else if (node.kind == NodeKind.REMAINDER) this.emitBinary(node, parentPrecedence, " % ", Precedence.MULTIPLY, EmitBinary.CAST_TO_INT);
    else if (node.kind == NodeKind.SHIFT_LEFT) this.emitBinary(node, parentPrecedence, " << ", Precedence.SHIFT, EmitBinary.NORMAL);
    else if (node.kind == NodeKind.SHIFT_RIGHT) this.emitBinary(node, parentPrecedence, node.isUnsignedOperator() ? " >>> " : " >> ", Precedence.SHIFT, EmitBinary.NORMAL);
    else if (node.kind == NodeKind.SUBTRACT) this.emitBinary(node, parentPrecedence, " - ", Precedence.ADD, EmitBinary.CAST_TO_INT);

    else if (node.kind == NodeKind.MULTIPLY) {
      var left = node.binaryLeft();
      var right = node.binaryRight();
      var isUnsigned = node.isUnsignedOperator();

      if (isUnsigned && parentPrecedence > Precedence.SHIFT) {
        this.emitText("(");
      }

      this.emitText("__imul(");
      this.emitExpression(left, Precedence.LOWEST);
      this.emitText(", ");
      this.emitExpression(right, Precedence.LOWEST);
      this.emitText(")");
      this.foundMultiply = true;

      if (isUnsigned) {
        this.emitText(" >>> 0");

        if (parentPrecedence > Precedence.SHIFT) {
          this.emitText(")");
        }
      }
    }

    else {
      assert(false);
    }
  }

  emitSymbolAccess(symbol: Symbol): void {
    var c = String_get(symbol.name, 0);

    if (isAlpha(c)) {
      this.emitText(".");
      this.emitString(symbol.name);
    }

    else {
      this.emitText("[");
      this.emitString(String_quote(symbol.name));
      this.emitText("]");
    }
  }

  emitStatement(node: Node): void {
    if (node.kind == NodeKind.FUNCTION) {
      var body = node.functionBody();
      if (body == null) {
        return;
      }

      var symbol = node.symbol;
      var needsSemicolon = false;
      this.emitNewlineBefore(node);
      this.emitIndent();

      if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
        this.emitString(symbol.parent().name);
        this.emitText(".prototype");
        this.emitSymbolAccess(symbol);
        this.emitText(" = function");
        needsSemicolon = true;
      }

      else if (node.isExtern()) {
        this.emitText("var ");
        this.emitString(symbol.name);
        this.emitText(" = exports.");
        this.emitString(symbol.name);
        this.emitText(" = function");
        needsSemicolon = true;
      }

      else {
        this.emitText("function ");
        this.emitString(symbol.name);
      }

      this.emitText("(");

      var returnType = node.functionReturnType();
      var child = node.functionFirstArgumentIgnoringThis();

      while (child != returnType) {
        assert(child.kind == NodeKind.VARIABLE);
        this.emitString(child.symbol.name);
        child = child.nextSibling;
        if (child != returnType) {
          this.emitText(", ");
        }
      }

      this.emitText(") ");
      this.emitBlock(node.functionBody());
      this.emitText(needsSemicolon ? ";\n" : "\n");
      this.emitNewlineAfter(node);
    }

    else if (node.kind == NodeKind.IF) {
      this.emitNewlineBefore(node);
      this.emitIndent();
      while (true) {
        this.emitText("if (");
        this.emitExpression(node.ifValue(), Precedence.LOWEST);
        this.emitText(") ");
        this.emitBlock(node.ifTrue());
        var no = node.ifFalse();
        if (no == null) {
          this.emitText("\n");
          break;
        }
        this.emitText("\n\n");
        this.emitIndent();
        this.emitText("else ");
        if (no.firstChild == null || no.firstChild != no.lastChild || no.firstChild.kind != NodeKind.IF) {
          this.emitBlock(no);
          this.emitText("\n");
          break;
        }
        node = no.firstChild;
      }
      this.emitNewlineAfter(node);
    }

    else if (node.kind == NodeKind.WHILE) {
      this.emitNewlineBefore(node);
      this.emitIndent();
      this.emitText("while (");
      this.emitExpression(node.whileValue(), Precedence.LOWEST);
      this.emitText(") ");
      this.emitBlock(node.whileBody());
      this.emitText("\n");
      this.emitNewlineAfter(node);
    }

    else if (node.kind == NodeKind.BREAK) {
      this.emitNewlineBefore(node);
      this.emitIndent();
      this.emitText("break;\n");
      this.emitNewlineAfter(node);
    }

    else if (node.kind == NodeKind.CONTINUE) {
      this.emitNewlineBefore(node);
      this.emitIndent();
      this.emitText("continue;\n");
      this.emitNewlineAfter(node);
    }

    else if (node.kind == NodeKind.EXPRESSION) {
      this.emitNewlineBefore(node);
      this.emitIndent();
      this.emitExpression(node.expressionValue(), Precedence.LOWEST);
      this.emitText(";\n");
      this.emitNewlineAfter(node);
    }

    else if (node.kind == NodeKind.EMPTY) {
    }

    else if (node.kind == NodeKind.RETURN) {
      var value = node.returnValue();
      this.emitNewlineBefore(node);
      this.emitIndent();
      if (value != null) {
        this.emitText("return ");
        this.emitExpression(value, Precedence.LOWEST);
        this.emitText(";\n");
      } else {
        this.emitText("return;\n");
      }
      this.emitNewlineAfter(node);
    }

    else if (node.kind == NodeKind.BLOCK) {
      if (node.parent.kind == NodeKind.BLOCK) {
        this.emitStatements(node.firstChild);
      } else {
        this.emitNewlineBefore(node);
        this.emitIndent();
        this.emitBlock(node);
        this.emitText("\n");
        this.emitNewlineAfter(node);
      }
    }

    else if (node.kind == NodeKind.VARIABLES) {
      this.emitNewlineBefore(node);
      this.emitIndent();
      this.emitText("var ");
      var child = node.firstChild;
      while (child != null) {
        var value = child.variableValue();
        this.emitString(child.symbol.name);
        child = child.nextSibling;
        if (child != null) {
          this.emitText(", ");
        }
        assert(value != null);
        this.emitText(" = ");
        this.emitExpression(value, Precedence.LOWEST);
      }
      this.emitText(";\n");
      this.emitNewlineAfter(node);
    }

    else if (node.kind == NodeKind.CLASS) {
      if (node.isDeclare()) {
        return;
      }

      this.emitNewlineBefore(node);
      this.emitIndent();
      this.emitText("function ");
      this.emitString(node.symbol.name);
      this.emitText("() {\n");
      this.indent = this.indent + 1;

      // Emit constructor body
      var child = node.firstChild;
      while (child != null) {
        if (child.kind == NodeKind.VARIABLE) {
          this.emitIndent();
          this.emitText("this.");
          this.emitString(child.symbol.name);
          this.emitText(" = ");
          this.emitExpression(child.variableValue(), Precedence.LOWEST);
          this.emitText(";\n");
        }
        child = child.nextSibling;
      }

      this.indent = this.indent - 1;
      this.emitIndent();
      this.emitText("}\n");
      this.emitNewlineAfter(node);

      // Emit instance functions
      child = node.firstChild;
      while (child != null) {
        if (child.kind == NodeKind.FUNCTION) {
          this.emitStatement(child);
        }
        child = child.nextSibling;
      }
    }

    else if (node.kind == NodeKind.CONSTANTS || node.kind == NodeKind.ENUM) {
    }

    else {
      assert(false);
    }
  }
}

function jsIsCompactNodeKind(kind: NodeKind): bool {
  return
    kind == NodeKind.CONSTANTS ||
    kind == NodeKind.EXPRESSION ||
    kind == NodeKind.VARIABLES;
}

function jsEmit(global: Node, context: CheckContext): String {
  var result = new JsResult();
  result.context = context;
  result.code = String_new("");
  result.emitStatements(global.firstChild);

  if (result.foundMultiply) {
    result.emitText("\nvar __imul = Math.imul || function(a, b) {\n");
    result.emitText("  return (a * (b >>> 16) << 16) + a * (b & 65535) | 0;\n");
    result.emitText("};\n");
  }

  return result.code;
}
enum TokenKind {
  END_OF_FILE,

  // Literals
  CHARACTER,
  IDENTIFIER,
  INT,
  STRING,

  // Punctuation
  ASSIGN,
  BITWISE_AND,
  BITWISE_OR,
  BITWISE_XOR,
  COLON,
  COMMA,
  COMPLEMENT,
  DIVIDE,
  DOT,
  EQUAL,
  GREATER_THAN,
  GREATER_THAN_EQUAL,
  LEFT_BRACE,
  LEFT_BRACKET,
  LEFT_PARENTHESIS,
  LESS_THAN,
  LESS_THAN_EQUAL,
  LOGICAL_AND,
  LOGICAL_OR,
  MINUS,
  MINUS_MINUS,
  MULTIPLY,
  NOT,
  NOT_EQUAL,
  PLUS,
  PLUS_PLUS,
  QUESTION_MARK,
  REMAINDER,
  RIGHT_BRACE,
  RIGHT_BRACKET,
  RIGHT_PARENTHESIS,
  SEMICOLON,
  SHIFT_LEFT,
  SHIFT_RIGHT,

  // Keywords
  ALIGNOF,
  AS,
  BREAK,
  CLASS,
  CONST,
  CONTINUE,
  DECLARE,
  ELSE,
  ENUM,
  EXPORT,
  EXTENDS,
  EXTERN,
  FALSE,
  FUNCTION,
  IF,
  IMPLEMENTS,
  IMPORT,
  INTERFACE,
  LET,
  NEW,
  NULL,
  OPERATOR,
  PRIVATE,
  PROTECTED,
  PUBLIC,
  RETURN,
  SIZEOF,
  STATIC,
  THIS,
  TRUE,
  UNSAFE,
  VAR,
  WHILE,
}

function isKeyword(kind: TokenKind): bool {
  return kind >= TokenKind.ALIGNOF && kind <= TokenKind.WHILE;
}

class Token {
  kind: TokenKind;
  range: Range;
  next: Token;
}

function tokenToString(token: TokenKind): string {
  if (token == TokenKind.END_OF_FILE) return "end of file";

  // Literals
  if (token == TokenKind.CHARACTER) return "character literal";
  if (token == TokenKind.IDENTIFIER) return "identifier";
  if (token == TokenKind.INT) return "integer literal";
  if (token == TokenKind.STRING) return "string literal";

  // Punctuation
  if (token == TokenKind.ASSIGN) return "'='";
  if (token == TokenKind.BITWISE_AND) return "'&'";
  if (token == TokenKind.BITWISE_OR) return "'|'";
  if (token == TokenKind.BITWISE_XOR) return "'^'";
  if (token == TokenKind.COLON) return "':'";
  if (token == TokenKind.COMMA) return "','";
  if (token == TokenKind.COMPLEMENT) return "'~'";
  if (token == TokenKind.DIVIDE) return "'/'";
  if (token == TokenKind.DOT) return "'.'";
  if (token == TokenKind.EQUAL) return "'=='";
  if (token == TokenKind.GREATER_THAN) return "'>'";
  if (token == TokenKind.GREATER_THAN_EQUAL) return "'>='";
  if (token == TokenKind.LEFT_BRACE) return "'{'";
  if (token == TokenKind.LEFT_BRACKET) return "'['";
  if (token == TokenKind.LEFT_PARENTHESIS) return "'('";
  if (token == TokenKind.LESS_THAN) return "'<'";
  if (token == TokenKind.LESS_THAN_EQUAL) return "'<='";
  if (token == TokenKind.LOGICAL_AND) return "'&&'";
  if (token == TokenKind.LOGICAL_OR) return "'||'";
  if (token == TokenKind.MINUS) return "'-'";
  if (token == TokenKind.MINUS_MINUS) return "'--'";
  if (token == TokenKind.MULTIPLY) return "'*'";
  if (token == TokenKind.NOT) return "'!'";
  if (token == TokenKind.NOT_EQUAL) return "'!='";
  if (token == TokenKind.PLUS) return "'+'";
  if (token == TokenKind.PLUS_PLUS) return "'++'";
  if (token == TokenKind.QUESTION_MARK) return "'?'";
  if (token == TokenKind.REMAINDER) return "'%'";
  if (token == TokenKind.RIGHT_BRACE) return "'}'";
  if (token == TokenKind.RIGHT_BRACKET) return "']'";
  if (token == TokenKind.RIGHT_PARENTHESIS) return "')'";
  if (token == TokenKind.SEMICOLON) return "';'";
  if (token == TokenKind.SHIFT_LEFT) return "'<<'";
  if (token == TokenKind.SHIFT_RIGHT) return "'>>'";

  // Keywords
  if (token == TokenKind.ALIGNOF) return "'alignof'";
  if (token == TokenKind.AS) return "'as'";
  if (token == TokenKind.BREAK) return "'break'";
  if (token == TokenKind.CLASS) return "'class'";
  if (token == TokenKind.CONST) return "'const'";
  if (token == TokenKind.CONTINUE) return "'continue'";
  if (token == TokenKind.DECLARE) return "'declare'";
  if (token == TokenKind.ELSE) return "'else'";
  if (token == TokenKind.ENUM) return "'enum'";
  if (token == TokenKind.EXPORT) return "'export'";
  if (token == TokenKind.EXTENDS) return "'extends'";
  if (token == TokenKind.EXTERN) return "'extern'";
  if (token == TokenKind.FALSE) return "'false'";
  if (token == TokenKind.FUNCTION) return "'function'";
  if (token == TokenKind.IF) return "'if'";
  if (token == TokenKind.IMPLEMENTS) return "'implements'";
  if (token == TokenKind.IMPORT) return "'import'";
  if (token == TokenKind.INTERFACE) return "'interface'";
  if (token == TokenKind.LET) return "'let'";
  if (token == TokenKind.NEW) return "'new'";
  if (token == TokenKind.NULL) return "'null'";
  if (token == TokenKind.OPERATOR) return "'operator'";
  if (token == TokenKind.PRIVATE) return "'private'";
  if (token == TokenKind.PROTECTED) return "'protected'";
  if (token == TokenKind.PUBLIC) return "'public'";
  if (token == TokenKind.RETURN) return "'return'";
  if (token == TokenKind.SIZEOF) return "'sizeof'";
  if (token == TokenKind.STATIC) return "'static'";
  if (token == TokenKind.THIS) return "'this'";
  if (token == TokenKind.TRUE) return "'true'";
  if (token == TokenKind.UNSAFE) return "'unsafe'";
  if (token == TokenKind.VAR) return "'var'";
  if (token == TokenKind.WHILE) return "'while'";

  assert(false);
  return null;
}

function isAlpha(c: int): bool {
  return
    c >= 'a' && c <= 'z' ||
    c >= 'A' && c <= 'Z' ||
    c == '_';
}

function isNumber(c: int): bool {
  return c >= '0' && c <= '9';
}

function isDigit(c: int, base: int): bool {
  if (base == 16) {
    return isNumber(c) || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f';
  }
  return c >= '0' && c < '0' + base;
}

function tokenize(source: Source, log: Log): Token {
  var first: Token = null;
  var last: Token = null;
  var contents = source.contents;
  var limit = String_length(contents);
  var i = 0;

  while (i < limit) {
    var start = i;
    var c = String_get(contents, i);
    i = i + 1;

    if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
      continue;
    }

    var kind = TokenKind.END_OF_FILE;

    // Identifier
    if (isAlpha(c)) {
      kind = TokenKind.IDENTIFIER;

      while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
        i = i + 1;
      }

      // Keywords
      var text = String_slice(contents, start, i);
      if (String_equalNew(text, "alignof")) kind = TokenKind.ALIGNOF;
      else if (String_equalNew(text, "as")) kind = TokenKind.AS;
      else if (String_equalNew(text, "break")) kind = TokenKind.BREAK;
      else if (String_equalNew(text, "class")) kind = TokenKind.CLASS;
      else if (String_equalNew(text, "const")) kind = TokenKind.CONST;
      else if (String_equalNew(text, "continue")) kind = TokenKind.CONTINUE;
      else if (String_equalNew(text, "declare")) kind = TokenKind.DECLARE;
      else if (String_equalNew(text, "else")) kind = TokenKind.ELSE;
      else if (String_equalNew(text, "enum")) kind = TokenKind.ENUM;
      else if (String_equalNew(text, "export")) kind = TokenKind.EXPORT;
      else if (String_equalNew(text, "extends")) kind = TokenKind.EXTENDS;
      else if (String_equalNew(text, "extern")) kind = TokenKind.EXTERN;
      else if (String_equalNew(text, "false")) kind = TokenKind.FALSE;
      else if (String_equalNew(text, "function")) kind = TokenKind.FUNCTION;
      else if (String_equalNew(text, "if")) kind = TokenKind.IF;
      else if (String_equalNew(text, "implements")) kind = TokenKind.IMPLEMENTS;
      else if (String_equalNew(text, "import")) kind = TokenKind.IMPORT;
      else if (String_equalNew(text, "interface")) kind = TokenKind.INTERFACE;
      else if (String_equalNew(text, "let")) kind = TokenKind.LET;
      else if (String_equalNew(text, "new")) kind = TokenKind.NEW;
      else if (String_equalNew(text, "null")) kind = TokenKind.NULL;
      else if (String_equalNew(text, "private")) kind = TokenKind.PRIVATE;
      else if (String_equalNew(text, "protected")) kind = TokenKind.PROTECTED;
      else if (String_equalNew(text, "public")) kind = TokenKind.PUBLIC;
      else if (String_equalNew(text, "return")) kind = TokenKind.RETURN;
      else if (String_equalNew(text, "sizeof")) kind = TokenKind.SIZEOF;
      else if (String_equalNew(text, "static")) kind = TokenKind.STATIC;
      else if (String_equalNew(text, "this")) kind = TokenKind.THIS;
      else if (String_equalNew(text, "true")) kind = TokenKind.TRUE;
      else if (String_equalNew(text, "unsafe")) kind = TokenKind.UNSAFE;
      else if (String_equalNew(text, "var")) kind = TokenKind.VAR;
      else if (String_equalNew(text, "while")) kind = TokenKind.WHILE;
    }

    // Integer
    else if (isNumber(c)) {
      kind = TokenKind.INT;

      if (i < limit) {
        var next = String_get(contents, i);
        var base = 10;

        // Handle binary, octal, and hexadecimal prefixes
        if (c == '0' && i + 1 < limit) {
          if (next == 'b' || next == 'B') base = 2;
          else if (next == 'o' || next == 'O') base = 8;
          else if (next == 'x' || next == 'X') base = 16;
          if (base != 10) {
            if (isDigit(String_get(contents, i + 1), base)) i = i + 2;
            else base = 10;
          }
        }

        // Scan the payload
        while (i < limit && isDigit(String_get(contents, i), base)) {
          i = i + 1;
        }

        // Extra letters after the end is an error
        if (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
          i = i + 1;

          while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
            i = i + 1;
          }

          log.error(createRange(source, start, i), String_appendNew(String_append(
            String_new("Invalid integer literal: '"),
            String_slice(contents, start, i)),
            "'"));
          return null;
        }
      }
    }

    // Character or string
    else if (c == '"' || c == '\'' || c == '`') {
      while (i < limit) {
        var next = String_get(contents, i);

        // Escape any character including newlines
        if (i + 1 < limit && next == '\\') {
          i = i + 2;
        }

        // Only allow newlines in template literals
        else if (next == '\n' && c != '`') {
          break;
        }

        // Handle a normal character
        else {
          i = i + 1;

          // End the string with a matching quote character
          if (next == c) {
            kind = c == '\'' ? TokenKind.CHARACTER : TokenKind.STRING;
            break;
          }
        }
      }

      // It's an error if we didn't find a matching quote character
      if (kind == TokenKind.END_OF_FILE) {
        log.error(createRange(source, start, i), String_new(
          c == '\'' ? "Unterminated character literal" :
          c == '`' ? "Unterminated template literal" :
          "Unterminated string literal"));
        return null;
      }
    }

    // Operators
    else if (c == '%') kind = TokenKind.REMAINDER;
    else if (c == '(') kind = TokenKind.LEFT_PARENTHESIS;
    else if (c == ')') kind = TokenKind.RIGHT_PARENTHESIS;
    else if (c == '*') kind = TokenKind.MULTIPLY;
    else if (c == ',') kind = TokenKind.COMMA;
    else if (c == '.') kind = TokenKind.DOT;
    else if (c == ':') kind = TokenKind.COLON;
    else if (c == ';') kind = TokenKind.SEMICOLON;
    else if (c == '?') kind = TokenKind.QUESTION_MARK;
    else if (c == '[') kind = TokenKind.LEFT_BRACKET;
    else if (c == ']') kind = TokenKind.RIGHT_BRACKET;
    else if (c == '^') kind = TokenKind.BITWISE_XOR;
    else if (c == '{') kind = TokenKind.LEFT_BRACE;
    else if (c == '}') kind = TokenKind.RIGHT_BRACE;
    else if (c == '~') kind = TokenKind.COMPLEMENT;

    // / or // or /*
    else if (c == '/') {
      kind = TokenKind.DIVIDE;

      // Single-line comments
      if (i < limit && String_get(contents, i) == '/') {
        i = i + 1;

        while (i < limit && String_get(contents, i) != '\n') {
          i = i + 1;
        }

        continue;
      }

      // Multi-line comments
      if (i < limit && String_get(contents, i) == '*') {
        i = i + 1;
        var foundEnd = false;

        while (i < limit) {
          var next = String_get(contents, i);

          if (next == '*' && i + 1 < limit && String_get(contents, i + 1) == '/') {
            foundEnd = true;
            i = i + 2;
            break;
          }

          i = i + 1;
        }

        if (!foundEnd) {
          log.error(createRange(source, start, start + 2), String_new("Unterminated multi-line comment"));
          return null;
        }

        continue;
      }
    }

    // ! or !=
    else if (c == '!') {
      kind = TokenKind.NOT;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.NOT_EQUAL;
        i = i + 1;

        // Recover from !==
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '!=' instead of '!=='"));
        }
      }
    }

    // = or ==
    else if (c == '=') {
      kind = TokenKind.ASSIGN;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.EQUAL;
        i = i + 1;

        // Recover from ===
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '==' instead of '==='"));
        }
      }
    }

    // + or ++
    else if (c == '+') {
      kind = TokenKind.PLUS;

      if (i < limit && String_get(contents, i) == '+') {
        kind = TokenKind.PLUS_PLUS;
        i = i + 1;
      }
    }

    // - or --
    else if (c == '-') {
      kind = TokenKind.MINUS;

      if (i < limit && String_get(contents, i) == '-') {
        kind = TokenKind.MINUS_MINUS;
        i = i + 1;
      }
    }

    // & or &&
    else if (c == '&') {
      kind = TokenKind.BITWISE_AND;

      if (i < limit && String_get(contents, i) == '&') {
        kind = TokenKind.LOGICAL_AND;
        i = i + 1;
      }
    }

    // | or ||
    else if (c == '|') {
      kind = TokenKind.BITWISE_OR;

      if (i < limit && String_get(contents, i) == '|') {
        kind = TokenKind.LOGICAL_OR;
        i = i + 1;
      }
    }

    // < or << or <=
    else if (c == '<') {
      kind = TokenKind.LESS_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '<') {
          kind = TokenKind.SHIFT_LEFT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.LESS_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    // > or >> or >=
    else if (c == '>') {
      kind = TokenKind.GREATER_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '>') {
          kind = TokenKind.SHIFT_RIGHT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.GREATER_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    var range = createRange(source, start, i);

    if (kind == TokenKind.END_OF_FILE) {
      log.error(range,
        String_appendNew(
          String_append(
            String_new("Syntax error: '"),
            String_slice(contents, start, start + 1)),
          "'"));
      return null;
    }

    var token = new Token();
    token.kind = kind;
    token.range = range;

    if (first == null) first = token;
    else last.next = token;
    last = token;
  }

  var eof = new Token();
  eof.kind = TokenKind.END_OF_FILE;
  eof.range = createRange(source, limit, limit);

  if (first == null) first = eof;
  else last.next = eof;
  last = eof;

  return first;
}
function libraryForWebAssembly(): string {
  return `
// Casting to this enables writing to arbitrary locations in memory
unsafe class UBytePtr {
  value: byte;
}

// These will be filled in by the WebAssembly code generator
unsafe var currentHeapPointer: uint = 0;
unsafe var originalHeapPointer: uint = 0;

unsafe function malloc(sizeOf: uint): uint {
  // Align all allocations to 8 bytes
  var offset = (currentHeapPointer + 7) & ~7 as uint;

  // Use a simple bump allocator for now
  currentHeapPointer = offset + sizeOf;

  // Make sure the memory starts off at zero
  var ptr = offset;
  while (sizeOf != 0) {
    (ptr as UBytePtr).value = 0;
    sizeOf = sizeOf - 1;
    ptr = ptr + 1;
  }

  return offset;
}
`;
}
class Source {
  name: String;
  contents: String;
}

class Range {
  source: Source;
  start: int;
  end: int;

  toString(): String {
    return String_slice(this.source.contents, this.start, this.end);
  }

  equals(other: Range): bool {
    return
      this.source == other.source &&
      this.start == other.start &&
      this.end == other.end;
  }

  enclosingLine(): Range {
    var contents = this.source.contents;
    var start = this.start;
    var end = this.start;

    while (start > 0 && String_get(contents, start - 1) != '\n') {
      start = start - 1;
    }

    while (end + 1 < String_length(contents) && String_get(contents, end) != '\n') {
      end = end + 1;
    }

    return createRange(this.source, start, end);
  }
}

function createRange(source: Source, start: int, end: int): Range {
  assert(start <= end);
  var range = new Range();
  range.source = source;
  range.start = start;
  range.end = end;
  return range;
}

function spanRanges(left: Range, right: Range): Range {
  assert(left.source == right.source);
  assert(left.end <= right.start);
  return createRange(left.source, left.start, right.end);
}

class Diagnostic {
  range: Range;
  message: String;
  next: Diagnostic;
}

class Log {
  first: Diagnostic;
  last: Diagnostic;

  error(range: Range, message: String): void {
    var diagnostic = new Diagnostic();
    diagnostic.range = range;
    diagnostic.message = message;
    this.append(diagnostic);
  }

  append(diagnostic: Diagnostic): void {
    if (this.first == null) this.first = diagnostic;
    else this.last.next = diagnostic;
    this.last = diagnostic;
  }

  toString(): String {
    var result = String_new("");
    var d = this.first;

    while (d != null) {
      var lineRange = d.range.enclosingLine();
      var column = d.range.start - lineRange.start;
      var line = 0;

      var i = 0;
      while (i < lineRange.start) {
        if (String_get(lineRange.source.contents, i) == '\n') {
          line = line + 1;
        }
        i = i + 1;
      }

      result = String_append(result, d.range.source.name);
      result = String_appendNew(result, ":");
      result = String_append(result, String_toStringSigned(line + 1));
      result = String_appendNew(result, ":");
      result = String_append(result, String_toStringSigned(column + 1));
      result = String_appendNew(result, ": error: ");
      result = String_append(result, d.message);
      result = String_appendNew(result, "\n");
      result = String_append(result, lineRange.toString());
      result = String_appendNew(result, "\n");

      i = 0;
      while (i < column) {
        result = String_appendNew(result, " ");
        i = i + 1;
      }

      if (d.range.end - d.range.start <= 1) {
        result = String_appendNew(result, "^");
      } else {
        i = d.range.start;
        while (i < d.range.end && i < lineRange.end) {
          result = String_appendNew(result, "~");
          i = i + 1;
        }
      }

      result = String_appendNew(result, "\n");
      d = d.next;
    }

    return result;
  }
}
enum NodeKind {
  // Other
  GLOBAL,
  VARIABLE,

  // Statements
  BLOCK,
  BREAK,
  CLASS,
  CONSTANTS,
  CONTINUE,
  EMPTY,
  ENUM,
  EXPRESSION,
  FUNCTION,
  IF,
  RETURN,
  UNSAFE,
  VARIABLES,
  WHILE,

  // Expressions
  ALIGN_OF,
  BOOL,
  CALL,
  CAST,
  DOT,
  HOOK,
  INDEX,
  INT,
  NAME,
  NEW,
  NULL,
  PARSE_ERROR,
  SIZE_OF,
  STRING,
  THIS,
  TYPE,

  // Unary expressions
  COMPLEMENT,
  NEGATIVE,
  NOT,
  POSITIVE,
  POSTFIX_DECREMENT,
  POSTFIX_INCREMENT,
  PREFIX_DECREMENT,
  PREFIX_INCREMENT,

  // Binary expressions
  ADD,
  ASSIGN,
  BITWISE_AND,
  BITWISE_OR,
  BITWISE_XOR,
  DIVIDE,
  EQUAL,
  GREATER_THAN,
  GREATER_THAN_EQUAL,
  LESS_THAN,
  LESS_THAN_EQUAL,
  LOGICAL_AND,
  LOGICAL_OR,
  MULTIPLY,
  NOT_EQUAL,
  REMAINDER,
  SHIFT_LEFT,
  SHIFT_RIGHT,
  SUBTRACT,
}

function isUnary(kind: NodeKind): bool {
  return kind >= NodeKind.COMPLEMENT && kind <= NodeKind.PREFIX_INCREMENT;
}

function isUnaryPostfix(kind: NodeKind): bool {
  return kind >= NodeKind.POSTFIX_DECREMENT && kind <= NodeKind.POSTFIX_INCREMENT;
}

function isBinary(kind: NodeKind): bool {
  return kind >= NodeKind.ADD && kind <= NodeKind.SUBTRACT;
}

function isExpression(node: Node): bool {
  return node.kind >= NodeKind.ALIGN_OF && node.kind <= NodeKind.SUBTRACT;
}

const NODE_FLAG_DECLARE = 1 << 0;
const NODE_FLAG_EXPORT = 1 << 1;
const NODE_FLAG_EXTERN = 1 << 2;
const NODE_FLAG_GET = 1 << 3;
const NODE_FLAG_PRIVATE = 1 << 4;
const NODE_FLAG_PROTECTED = 1 << 5;
const NODE_FLAG_PUBLIC = 1 << 6;
const NODE_FLAG_SET = 1 << 7;
const NODE_FLAG_STATIC = 1 << 8;
const NODE_FLAG_UNSAFE = 1 << 9;
const NODE_FLAG_UNSIGNED_OPERATOR = 1 << 10;

class NodeFlag {
  flag: int;
  range: Range;
  next: NodeFlag;
}

function appendFlag(first: NodeFlag, flag: int, range: Range): NodeFlag {
  var link = new NodeFlag();
  link.flag = flag;
  link.range = range;

  // Is the list empty?
  if (first == null) {
    return link;
  }

  // Append the flag to the end of the list
  var secondToLast = first;
  while (secondToLast.next != null) {
    secondToLast = secondToLast.next;
  }
  secondToLast.next = link;
  return first;
}

function allFlags(link: NodeFlag): int {
  var all = 0;
  while (link != null) {
    all = all | link.flag;
    link = link.next;
  }
  return all;
}

function rangeForFlag(link: NodeFlag, flag: int): Range {
  while (link != null) {
    if (link.flag == flag) {
      return link.range;
    }
    link = link.next;
  }
  return null;
}

class Node {
  kind: NodeKind;
  flags: int;
  firstFlag: NodeFlag;
  range: Range;
  internalRange: Range;
  parent: Node;
  firstChild: Node;
  lastChild: Node;
  previousSibling: Node;
  nextSibling: Node;
  intValue: int;
  stringValue: String;
  resolvedType: Type;
  symbol: Symbol;
  scope: Scope;

  isNegativeInteger(): bool {
    return this.kind == NodeKind.INT && this.intValue < 0;
  }

  isNonNegativeInteger(): bool {
    return this.kind == NodeKind.INT && this.intValue >= 0;
  }

  isDeclare(): bool {
    return (this.flags & NODE_FLAG_DECLARE) != 0;
  }

  isExtern(): bool {
    return (this.flags & NODE_FLAG_EXTERN) != 0;
  }

  isUnsafe(): bool {
    return (this.flags & NODE_FLAG_UNSAFE) != 0;
  }

  isUnsignedOperator(): bool {
    return (this.flags & NODE_FLAG_UNSIGNED_OPERATOR) != 0;
  }

  childCount(): int {
    var count = 0;
    var child = this.firstChild;
    while (child != null) {
      count = count + 1;
      child = child.nextSibling;
    }
    return count;
  }

  appendChild(child: Node): void {
    child.parent = this;

    if (this.firstChild == null) {
      this.firstChild = child;
    }

    else {
      child.previousSibling = this.lastChild;
      this.lastChild.nextSibling = child;
    }

    this.lastChild = child;
  }

  prependChild(child: Node): void {
    this.insertChildBefore(this.firstChild, child);
  }

  insertChildBefore(after: Node, before: Node): void {
    if (before == null) {
      return;
    }

    assert(before != after);
    assert(before.parent == null);
    assert(before.previousSibling == null);
    assert(before.nextSibling == null);
    assert(after == null || after.parent == this);

    if (after == null) {
      this.appendChild(before);
      return;
    }

    before.parent = this;
    before.previousSibling = after.previousSibling;
    before.nextSibling = after;

    if (after.previousSibling != null) {
      assert(after == after.previousSibling.nextSibling);
      after.previousSibling.nextSibling = before;
    } else {
      assert(after == this.firstChild);
      this.firstChild = before;
    }

    after.previousSibling = before;
  }

  remove(): void {
    assert(this.parent != null);

    if (this.previousSibling != null) {
      assert(this.previousSibling.nextSibling == this);
      this.previousSibling.nextSibling = this.nextSibling;
    } else {
      assert(this.parent.firstChild == this);
      this.parent.firstChild = this.nextSibling;
    }

    if (this.nextSibling != null) {
      assert(this.nextSibling.previousSibling == this);
      this.nextSibling.previousSibling = this.previousSibling;
    } else {
      assert(this.parent.lastChild == this);
      this.parent.lastChild = this.previousSibling;
    }

    this.parent = null;
    this.previousSibling = null;
    this.nextSibling = null;
  }

  removeChildren(): void {
    while (this.lastChild != null) {
      this.lastChild.remove();
    }
  }

  replaceWith(node: Node): void {
    assert(node != this);
    assert(this.parent != null);
    assert(node.parent == null);
    assert(node.previousSibling == null);
    assert(node.nextSibling == null);

    node.parent = this.parent;
    node.previousSibling = this.previousSibling;
    node.nextSibling = this.nextSibling;

    if (this.previousSibling != null) {
      assert(this.previousSibling.nextSibling == this);
      this.previousSibling.nextSibling = node;
    } else {
      assert(this.parent.firstChild == this);
      this.parent.firstChild = node;
    }

    if (this.nextSibling != null) {
      assert(this.nextSibling.previousSibling == this);
      this.nextSibling.previousSibling = node;
    } else {
      assert(this.parent.lastChild == this);
      this.parent.lastChild = node;
    }

    this.parent = null;
    this.previousSibling = null;
    this.nextSibling = null;
  }

  becomeSymbolReference(symbol: Symbol): void {
    this.kind = NodeKind.NAME;
    this.symbol = symbol;
    this.stringValue = symbol.name;
    this.resolvedType = symbol.resolvedType;
    this.removeChildren();
  }

  becomeIntegerConstant(value: int): void {
    this.kind = NodeKind.INT;
    this.symbol = null;
    this.intValue = value;
    this.removeChildren();
  }

  becomeBooleanConstant(value: bool): void {
    this.kind = NodeKind.BOOL;
    this.symbol = null;
    this.intValue = value ? 1 : 0;
    this.removeChildren();
  }

  isType(): bool {
    return this.kind == NodeKind.TYPE || this.symbol != null && isType(this.symbol.kind);
  }

  withRange(range: Range): Node {
    this.range = range;
    return this;
  }

  withInternalRange(range: Range): Node {
    this.internalRange = range;
    return this;
  }

  functionFirstArgumentIgnoringThis(): Node {
    assert(this.kind == NodeKind.FUNCTION);
    assert(this.childCount() >= 2);
    assert(this.symbol != null);
    return this.symbol.kind == SymbolKind.FUNCTION_INSTANCE ? this.firstChild.nextSibling : this.firstChild;
  }

  functionReturnType(): Node {
    assert(this.kind == NodeKind.FUNCTION);
    assert(this.childCount() >= 2);
    assert(isExpression(this.lastChild.previousSibling));
    return this.lastChild.previousSibling;
  }

  functionBody(): Node {
    assert(this.kind == NodeKind.FUNCTION);
    assert(this.childCount() >= 2);
    assert(this.lastChild.kind == NodeKind.BLOCK || this.lastChild.kind == NodeKind.EMPTY);
    var body = this.lastChild;
    return body.kind == NodeKind.BLOCK ? body : null;
  }

  newType(): Node {
    assert(this.kind == NodeKind.NEW);
    assert(this.childCount() >= 1);
    assert(isExpression(this.firstChild));
    return this.firstChild;
  }

  callValue(): Node {
    assert(this.kind == NodeKind.CALL);
    assert(this.childCount() >= 1);
    assert(isExpression(this.firstChild));
    return this.firstChild;
  }

  castValue(): Node {
    assert(this.kind == NodeKind.CAST);
    assert(this.childCount() == 2);
    assert(isExpression(this.firstChild));
    return this.firstChild;
  }

  castType(): Node {
    assert(this.kind == NodeKind.CAST);
    assert(this.childCount() == 2);
    assert(isExpression(this.lastChild));
    return this.lastChild;
  }

  alignOfType(): Node {
    assert(this.kind == NodeKind.ALIGN_OF);
    assert(this.childCount() == 1);
    assert(isExpression(this.firstChild));
    return this.firstChild;
  }

  sizeOfType(): Node {
    assert(this.kind == NodeKind.SIZE_OF);
    assert(this.childCount() == 1);
    assert(isExpression(this.firstChild));
    return this.firstChild;
  }

  dotTarget(): Node {
    assert(this.kind == NodeKind.DOT);
    assert(this.childCount() == 1);
    assert(isExpression(this.firstChild));
    return this.firstChild;
  }

  returnValue(): Node {
    assert(this.kind == NodeKind.RETURN);
    assert(this.childCount() <= 1);
    assert(this.firstChild == null || isExpression(this.firstChild));
    return this.firstChild;
  }

  variableType(): Node {
    assert(this.kind == NodeKind.VARIABLE);
    assert(this.childCount() <= 2);
    assert(isExpression(this.firstChild) || this.firstChild.kind == NodeKind.EMPTY);
    var type = this.firstChild;
    return type.kind != NodeKind.EMPTY ? type : null;
  }

  variableValue(): Node {
    assert(this.kind == NodeKind.VARIABLE);
    assert(this.childCount() <= 2);
    assert(this.firstChild.nextSibling == null || isExpression(this.firstChild.nextSibling));
    return this.firstChild.nextSibling;
  }

  expressionValue(): Node {
    assert(this.kind == NodeKind.EXPRESSION);
    assert(this.childCount() == 1);
    assert(isExpression(this.firstChild));
    return this.firstChild;
  }

  binaryLeft(): Node {
    assert(isBinary(this.kind));
    assert(this.childCount() == 2);
    assert(isExpression(this.firstChild));
    return this.firstChild;
  }

  binaryRight(): Node {
    assert(isBinary(this.kind));
    assert(this.childCount() == 2);
    assert(isExpression(this.lastChild));
    return this.lastChild;
  }

  unaryValue(): Node {
    assert(isUnary(this.kind));
    assert(this.childCount() == 1);
    assert(isExpression(this.firstChild));
    return this.firstChild;
  }

  whileValue(): Node {
    assert(this.kind == NodeKind.WHILE);
    assert(this.childCount() == 2);
    assert(isExpression(this.firstChild));
    return this.firstChild;
  }

  whileBody(): Node {
    assert(this.kind == NodeKind.WHILE);
    assert(this.childCount() == 2);
    assert(this.lastChild.kind == NodeKind.BLOCK);
    return this.lastChild;
  }

  hookValue(): Node {
    assert(this.kind == NodeKind.HOOK);
    assert(this.childCount() == 3);
    assert(isExpression(this.firstChild));
    return this.firstChild;
  }

  hookTrue(): Node {
    assert(this.kind == NodeKind.HOOK);
    assert(this.childCount() == 3);
    assert(isExpression(this.firstChild.nextSibling));
    return this.firstChild.nextSibling;
  }

  hookFalse(): Node {
    assert(this.kind == NodeKind.HOOK);
    assert(this.childCount() == 3);
    assert(isExpression(this.lastChild));
    return this.lastChild;
  }

  indexTarget(): Node {
    assert(this.kind == NodeKind.INDEX);
    assert(this.childCount() >= 1);
    assert(isExpression(this.firstChild));
    return this.firstChild;
  }

  ifValue(): Node {
    assert(this.kind == NodeKind.IF);
    assert(this.childCount() == 2 || this.childCount() == 3);
    assert(isExpression(this.firstChild));
    return this.firstChild;
  }

  ifTrue(): Node {
    assert(this.kind == NodeKind.IF);
    assert(this.childCount() == 2 || this.childCount() == 3);
    assert(this.firstChild.nextSibling.kind == NodeKind.BLOCK);
    return this.firstChild.nextSibling;
  }

  ifFalse(): Node {
    assert(this.kind == NodeKind.IF);
    assert(this.childCount() == 2 || this.childCount() == 3);
    assert(this.firstChild.nextSibling.nextSibling == null || this.firstChild.nextSibling.nextSibling.kind == NodeKind.BLOCK);
    return this.firstChild.nextSibling.nextSibling;
  }
}

function createNew(type: Node): Node {
  assert(isExpression(type));
  var node = new Node();
  node.kind = NodeKind.NEW;
  node.appendChild(type);
  return node;
}

function createHook(test: Node, primary: Node, secondary: Node): Node {
  assert(isExpression(test));
  assert(isExpression(primary));
  assert(isExpression(secondary));
  var node = new Node();
  node.kind = NodeKind.HOOK;
  node.appendChild(test);
  node.appendChild(primary);
  node.appendChild(secondary);
  return node;
}

function createIndex(target: Node): Node {
  assert(isExpression(target));
  var node = new Node();
  node.kind = NodeKind.INDEX;
  node.appendChild(target);
  return node;
}

function createNull(): Node {
  var node = new Node();
  node.kind = NodeKind.NULL;
  return node;
}

function createThis(): Node {
  var node = new Node();
  node.kind = NodeKind.THIS;
  return node;
}

function createAlignOf(type: Node): Node {
  assert(isExpression(type));
  var node = new Node();
  node.kind = NodeKind.ALIGN_OF;
  node.appendChild(type);
  return node;
}

function createSizeOf(type: Node): Node {
  assert(isExpression(type));
  var node = new Node();
  node.kind = NodeKind.SIZE_OF;
  node.appendChild(type);
  return node;
}

function createBool(value: bool): Node {
  var node = new Node();
  node.kind = NodeKind.BOOL;
  node.intValue = value ? 1 : 0;
  return node;
}

function createInt(value: int): Node {
  var node = new Node();
  node.kind = NodeKind.INT;
  node.intValue = value;
  return node;
}

function createString(value: String): Node {
  var node = new Node();
  node.kind = NodeKind.STRING;
  node.stringValue = value;
  return node;
}

function createName(value: String): Node {
  var node = new Node();
  node.kind = NodeKind.NAME;
  node.stringValue = value;
  return node;
}

function createType(type: Type): Node {
  assert(type != null);
  var node = new Node();
  node.kind = NodeKind.TYPE;
  node.resolvedType = type;
  return node;
}

function createEmpty(): Node {
  var node = new Node();
  node.kind = NodeKind.EMPTY;
  return node;
}

function createExpression(value: Node): Node {
  assert(isExpression(value));
  var node = new Node();
  node.kind = NodeKind.EXPRESSION;
  node.appendChild(value);
  return node;
}

function createBlock(): Node {
  var node = new Node();
  node.kind = NodeKind.BLOCK;
  return node;
}

function createClass(name: String): Node {
  var node = new Node();
  node.kind = NodeKind.CLASS;
  node.stringValue = name;
  return node;
}

function createEnum(name: String): Node {
  var node = new Node();
  node.kind = NodeKind.ENUM;
  node.stringValue = name;
  return node;
}

function createIf(value: Node, trueBranch: Node, falseBranch: Node): Node {
  assert(isExpression(value));
  assert(trueBranch.kind == NodeKind.BLOCK);
  assert(falseBranch == null || falseBranch.kind == NodeKind.BLOCK);
  var node = new Node();
  node.kind = NodeKind.IF;
  node.appendChild(value);
  node.appendChild(trueBranch);
  if (falseBranch != null) {
    node.appendChild(falseBranch);
  }
  return node;
}

function createWhile(value: Node, body: Node): Node {
  assert(isExpression(value));
  assert(body.kind == NodeKind.BLOCK);
  var node = new Node();
  node.kind = NodeKind.WHILE;
  node.appendChild(value);
  node.appendChild(body);
  return node;
}

function createReturn(value: Node): Node {
  assert(value == null || isExpression(value));
  var node = new Node();
  node.kind = NodeKind.RETURN;
  if (value != null) {
    node.appendChild(value);
  }
  return node;
}

function createVariables(): Node {
  var node = new Node();
  node.kind = NodeKind.VARIABLES;
  return node;
}

function createConstants(): Node {
  var node = new Node();
  node.kind = NodeKind.CONSTANTS;
  return node;
}

function createVariable(name: String, type: Node, value: Node): Node {
  assert(type == null || isExpression(type));
  assert(value == null || isExpression(value));

  var node = new Node();
  node.kind = NodeKind.VARIABLE;
  node.stringValue = name;

  node.appendChild(type != null ? type : createEmpty());
  if (value != null) {
    node.appendChild(value);
  }

  return node;
}

function createFunction(name: String): Node {
  var node = new Node();
  node.kind = NodeKind.FUNCTION;
  node.stringValue = name;
  return node;
}

function createUnary(kind: NodeKind, value: Node): Node {
  assert(isUnary(kind));
  assert(isExpression(value));
  var node = new Node();
  node.kind = kind;
  node.appendChild(value);
  return node;
}

function createBinary(kind: NodeKind, left: Node, right: Node): Node {
  assert(isBinary(kind));
  assert(isExpression(left));
  assert(isExpression(right));
  var node = new Node();
  node.kind = kind;
  node.appendChild(left);
  node.appendChild(right);
  return node;
}

function createCall(value: Node): Node {
  assert(isExpression(value));
  var node = new Node();
  node.kind = NodeKind.CALL;
  node.appendChild(value);
  return node;
}

function createCast(value: Node, type: Node): Node {
  assert(isExpression(value));
  assert(isExpression(type));
  var node = new Node();
  node.kind = NodeKind.CAST;
  node.appendChild(value);
  node.appendChild(type);
  return node;
}

function createDot(value: Node, name: String): Node {
  assert(isExpression(value));
  var node = new Node();
  node.kind = NodeKind.DOT;
  node.stringValue = name;
  node.appendChild(value);
  return node;
}

function createMemberReference(value: Node, symbol: Symbol): Node {
  assert(isExpression(value));
  var node = new Node();
  node.kind = NodeKind.DOT;
  node.stringValue = symbol.name;
  node.symbol = symbol;
  node.resolvedType = symbol.resolvedType;
  node.appendChild(value);
  return node;
}

function createParseError(): Node {
  var node = new Node();
  node.kind = NodeKind.PARSE_ERROR;
  return node;
}
enum Precedence {
  LOWEST,
  ASSIGN,
  LOGICAL_OR,
  LOGICAL_AND,
  BITWISE_OR,
  BITWISE_XOR,
  BITWISE_AND,
  EQUAL,
  COMPARE,
  SHIFT,
  ADD,
  MULTIPLY,
  UNARY_PREFIX,
  UNARY_POSTFIX,
  MEMBER,
}

enum ParseKind {
  EXPRESSION,
  TYPE,
}

enum StatementMode {
  NORMAL,
  GLOBAL,
}

class ParserContext {
  previous: Token;
  current: Token;
  log: Log;

  peek(kind: TokenKind): bool {
    return this.current.kind == kind;
  }

  eat(kind: TokenKind): bool {
    if (this.peek(kind)) {
      this.advance();
      return true;
    }

    return false;
  }

  advance(): void {
    if (!this.peek(TokenKind.END_OF_FILE)) {
      this.previous = this.current;
      this.current = this.current.next;
    }
  }

  unexpectedToken(): void {
    this.log.error(this.current.range, String_appendNew(
      String_new("Unexpected "),
      tokenToString(this.current.kind)));
  }

  expect(kind: TokenKind): bool {
    if (!this.peek(kind)) {
      var previousLine = this.previous.range.enclosingLine();
      var currentLine = this.current.range.enclosingLine();

      // Show missing token errors on the previous line for clarity
      if (kind != TokenKind.IDENTIFIER && !previousLine.equals(currentLine)) {
        this.log.error(createRange(previousLine.source, previousLine.end, previousLine.end), String_appendNew(
          String_new("Expected "),
          tokenToString(kind)));
      }

      else {
        this.log.error(this.current.range, String_appendNew(String_appendNew(String_appendNew(
          String_new("Expected "),
          tokenToString(kind)),
          " but found "),
          tokenToString(this.current.kind)));
      }

      return false;
    }

    this.advance();
    return true;
  }

  parseUnaryPrefix(kind: NodeKind): Node {
    assert(isUnary(kind));

    var token = this.current;
    this.advance();

    var value = this.parseExpression(Precedence.UNARY_PREFIX, ParseKind.EXPRESSION);
    if (value == null) {
      return null;
    }

    return createUnary(kind, value).withRange(spanRanges(token.range, value.range));
  }

  parseBinary(kind: NodeKind, left: Node, localPrecedence: Precedence, operatorPrecedence: Precedence): Node {
    if (localPrecedence >= operatorPrecedence) {
      return left;
    }

    this.advance();

    // Reduce the precedence since the assign operator is right-associative
    var precedence = operatorPrecedence == Precedence.ASSIGN ? Precedence.LOWEST : operatorPrecedence;
    var right = this.parseExpression(precedence, ParseKind.EXPRESSION);

    if (right == null) {
      return null;
    }

    return createBinary(kind, left, right).withRange(spanRanges(left.range, right.range));
  }

  parseUnaryPostfix(kind: NodeKind, value: Node, localPrecedence: Precedence): Node {
    if (localPrecedence >= Precedence.UNARY_POSTFIX) {
      return value;
    }

    var token = this.current;
    this.advance();
    return createUnary(kind, value).withRange(spanRanges(value.range, token.range));
  }

  parseQuotedString(range: Range): String {
    assert(range.end - range.start >= 2);
    var text = range.toString();
    var end = 1;
    var limit = String_length(text) - 1;
    var start = end;
    var result = String_new("");

    while (end < limit) {
      var c = String_get(text, end);

      if (c == '\\') {
        result = String_append(result, String_slice(text, start, end));
        end = end + 1;
        start = end + 1;
        c = String_get(text, end);

        if (c == '0') result = String_append(result, String_newLength("\0", 1));
        else if (c == 't') result = String_appendNew(result, "\t");
        else if (c == 'n') result = String_appendNew(result, "\n");
        else if (c == 'r') result = String_appendNew(result, "\r");
        else if (c == '"' || c == '\'' || c == '`' || c == '\n' || c == '\\') start = end;
        else {
          var escape = createRange(range.source, range.start + end - 1, range.start + end + 1);
          this.log.error(escape, String_append(String_append(
            String_new("Invalid escape code '"),
            escape.toString()),
            String_new("'")));
          return null;
        }
      }

      end = end + 1;
    }

    return String_append(result, String_slice(text, start, end));
  }

  parsePrefix(mode: ParseKind): Node {
    var token = this.current;

    if (this.peek(TokenKind.IDENTIFIER)) {
      var value = token.range.toString();
      this.advance();
      return createName(value).withRange(token.range);
    }

    if (mode == ParseKind.EXPRESSION) {
      if (this.eat(TokenKind.NULL)) {
        return createNull().withRange(token.range);
      }

      if (this.eat(TokenKind.THIS)) {
        return createThis().withRange(token.range);
      }

      if (this.peek(TokenKind.CHARACTER)) {
        var text = this.parseQuotedString(token.range);
        if (text == null) {
          return null;
        }
        this.advance();
        if (String_length(text) != 1) {
          this.log.error(token.range, String_new("Invalid character literal (strings use double quotes)"));
          return createParseError().withRange(token.range);
        }
        return createInt(String_get(text, 0)).withRange(token.range);
      }

      if (this.peek(TokenKind.STRING)) {
        var text = this.parseQuotedString(token.range);
        if (text == null) {
          return null;
        }
        this.advance();
        return createString(text).withRange(token.range);
      }

      if (this.peek(TokenKind.INT)) {
        var value = createInt(0);
        if (!this.parseInt(token.range, value)) {
          value = createParseError();
        }
        this.advance();
        return value.withRange(token.range);
      }

      if (this.eat(TokenKind.TRUE)) {
        return createBool(true).withRange(token.range);
      }

      if (this.eat(TokenKind.FALSE)) {
        return createBool(false).withRange(token.range);
      }

      if (this.eat(TokenKind.NEW)) {
        var type = this.parseType();
        if (type == null) {
          return null;
        }
        return this.parseArgumentList(token.range, createNew(type));
      }

      if (this.eat(TokenKind.ALIGNOF)) {
        if (!this.expect(TokenKind.LEFT_PARENTHESIS)) {
          return null;
        }
        var type = this.parseType();
        if (type == null) {
          return null;
        }
        var close = this.current;
        if (!this.expect(TokenKind.RIGHT_PARENTHESIS)) {
          return null;
        }
        return createAlignOf(type).withRange(spanRanges(token.range, close.range));
      }

      if (this.eat(TokenKind.SIZEOF)) {
        if (!this.expect(TokenKind.LEFT_PARENTHESIS)) {
          return null;
        }
        var type = this.parseType();
        if (type == null) {
          return null;
        }
        var close = this.current;
        if (!this.expect(TokenKind.RIGHT_PARENTHESIS)) {
          return null;
        }
        return createSizeOf(type).withRange(spanRanges(token.range, close.range));
      }

      if (this.eat(TokenKind.LEFT_PARENTHESIS)) {
        var value = this.parseExpression(Precedence.LOWEST, ParseKind.EXPRESSION);
        if (value == null || !this.expect(TokenKind.RIGHT_PARENTHESIS)) {
          return null;
        }
        return value;
      }

      // Unary prefix
      if (this.peek(TokenKind.NOT)) return this.parseUnaryPrefix(NodeKind.NOT);
      if (this.peek(TokenKind.MINUS)) return this.parseUnaryPrefix(NodeKind.NEGATIVE);
      if (this.peek(TokenKind.MINUS_MINUS)) return this.parseUnaryPrefix(NodeKind.PREFIX_DECREMENT);
      if (this.peek(TokenKind.PLUS)) return this.parseUnaryPrefix(NodeKind.POSITIVE);
      if (this.peek(TokenKind.PLUS_PLUS)) return this.parseUnaryPrefix(NodeKind.PREFIX_INCREMENT);
      if (this.peek(TokenKind.COMPLEMENT)) return this.parseUnaryPrefix(NodeKind.COMPLEMENT);
    }

    this.unexpectedToken();
    return null;
  }

  parseInfix(precedence: Precedence, node: Node, mode: ParseKind): Node {
    var token = this.current.range;

    // Dot
    if (this.peek(TokenKind.DOT) && precedence < Precedence.MEMBER) {
      this.advance();

      var name = this.current;
      var range = name.range;

      // Allow contextual keywords
      if (isKeyword(name.kind)) {
        this.advance();
      }

      // Recover from a missing identifier
      else if (!this.expect(TokenKind.IDENTIFIER)) {
        range = createRange(range.source, token.end, token.end);
      }

      return createDot(node, range.toString()).withRange(spanRanges(node.range, range)).withInternalRange(range);
    }

    if (mode == ParseKind.EXPRESSION) {
      // Binary
      if (this.peek(TokenKind.ASSIGN)) return this.parseBinary(NodeKind.ASSIGN, node, precedence, Precedence.ASSIGN);
      if (this.peek(TokenKind.BITWISE_AND)) return this.parseBinary(NodeKind.BITWISE_AND, node, precedence, Precedence.BITWISE_AND);
      if (this.peek(TokenKind.BITWISE_OR)) return this.parseBinary(NodeKind.BITWISE_OR, node, precedence, Precedence.BITWISE_OR);
      if (this.peek(TokenKind.BITWISE_XOR)) return this.parseBinary(NodeKind.BITWISE_XOR, node, precedence, Precedence.BITWISE_XOR);
      if (this.peek(TokenKind.DIVIDE)) return this.parseBinary(NodeKind.DIVIDE, node, precedence, Precedence.MULTIPLY);
      if (this.peek(TokenKind.EQUAL)) return this.parseBinary(NodeKind.EQUAL, node, precedence, Precedence.EQUAL);
      if (this.peek(TokenKind.GREATER_THAN)) return this.parseBinary(NodeKind.GREATER_THAN, node, precedence, Precedence.COMPARE);
      if (this.peek(TokenKind.GREATER_THAN_EQUAL)) return this.parseBinary(NodeKind.GREATER_THAN_EQUAL, node, precedence, Precedence.COMPARE);
      if (this.peek(TokenKind.LESS_THAN)) return this.parseBinary(NodeKind.LESS_THAN, node, precedence, Precedence.COMPARE);
      if (this.peek(TokenKind.LESS_THAN_EQUAL)) return this.parseBinary(NodeKind.LESS_THAN_EQUAL, node, precedence, Precedence.COMPARE);
      if (this.peek(TokenKind.LOGICAL_AND)) return this.parseBinary(NodeKind.LOGICAL_AND, node, precedence, Precedence.LOGICAL_AND);
      if (this.peek(TokenKind.LOGICAL_OR)) return this.parseBinary(NodeKind.LOGICAL_OR, node, precedence, Precedence.LOGICAL_OR);
      if (this.peek(TokenKind.MINUS)) return this.parseBinary(NodeKind.SUBTRACT, node, precedence, Precedence.ADD);
      if (this.peek(TokenKind.MULTIPLY)) return this.parseBinary(NodeKind.MULTIPLY, node, precedence, Precedence.MULTIPLY);
      if (this.peek(TokenKind.NOT_EQUAL)) return this.parseBinary(NodeKind.NOT_EQUAL, node, precedence, Precedence.EQUAL);
      if (this.peek(TokenKind.PLUS)) return this.parseBinary(NodeKind.ADD, node, precedence, Precedence.ADD);
      if (this.peek(TokenKind.REMAINDER)) return this.parseBinary(NodeKind.REMAINDER, node, precedence, Precedence.MULTIPLY);
      if (this.peek(TokenKind.SHIFT_LEFT)) return this.parseBinary(NodeKind.SHIFT_LEFT, node, precedence, Precedence.SHIFT);
      if (this.peek(TokenKind.SHIFT_RIGHT)) return this.parseBinary(NodeKind.SHIFT_RIGHT, node, precedence, Precedence.SHIFT);

      // Unary postfix
      if (this.peek(TokenKind.PLUS_PLUS)) return this.parseUnaryPostfix(NodeKind.POSTFIX_INCREMENT, node, precedence);
      if (this.peek(TokenKind.MINUS_MINUS)) return this.parseUnaryPostfix(NodeKind.POSTFIX_DECREMENT, node, precedence);

      // Cast
      if (this.peek(TokenKind.AS) && precedence < Precedence.UNARY_PREFIX) {
        this.advance();

        var type = this.parseType();
        if (type == null) {
          return null;
        }

        return createCast(node, type).withRange(spanRanges(node.range, type.range)).withInternalRange(token);
      }

      // Call or index
      var isIndex = this.peek(TokenKind.LEFT_BRACKET);
      if ((isIndex || this.peek(TokenKind.LEFT_PARENTHESIS)) && precedence < Precedence.UNARY_POSTFIX) {
        return this.parseArgumentList(node.range, isIndex ? createIndex(node) : createCall(node));
      }

      // Hook
      if (this.peek(TokenKind.QUESTION_MARK) && precedence < Precedence.ASSIGN) {
        this.advance();

        var middle = this.parseExpression(Precedence.LOWEST, ParseKind.EXPRESSION);
        if (middle == null || !this.expect(TokenKind.COLON)) {
          return null;
        }

        var right = this.parseExpression(Precedence.LOWEST, ParseKind.EXPRESSION);
        if (right == null) {
          return null;
        }

        return createHook(node, middle, right).withRange(spanRanges(node.range, right.range));
      }
    }

    return node;
  }

  parseArgumentList(start: Range, node: Node): Node {
    var open = this.current.range;
    var isIndex = node.kind == NodeKind.INDEX;
    var left = isIndex ? TokenKind.LEFT_BRACKET : TokenKind.LEFT_PARENTHESIS;
    var right = isIndex ? TokenKind.RIGHT_BRACKET : TokenKind.RIGHT_PARENTHESIS;

    if (!this.expect(left)) {
      return null;
    }

    if (!this.peek(right)) {
      while (true) {
        var value = this.parseExpression(Precedence.LOWEST, ParseKind.EXPRESSION);
        if (value == null) {
          return null;
        }
        node.appendChild(value);

        if (!this.eat(TokenKind.COMMA)) {
          break;
        }
      }
    }

    var close = this.current.range;
    if (!this.expect(right)) {
      return null;
    }

    return node.withRange(spanRanges(start, close)).withInternalRange(spanRanges(open, close));
  }

  parseExpression(precedence: Precedence, mode: ParseKind): Node {
    // Prefix
    var node = this.parsePrefix(mode);
    if (node == null) {
      return null;
    }
    assert(node.range != null);

    // Infix
    while (true) {
      var result = this.parseInfix(precedence, node, mode);
      if (result == null) {
        return null;
      }
      if (result == node) {
        break;
      }
      node = result;
      assert(node.range != null);
    }

    return node;
  }

  parseType(): Node {
    return this.parseExpression(Precedence.UNARY_POSTFIX, ParseKind.TYPE);
  }

  parseIf(): Node {
    var token = this.current;
    assert(token.kind == TokenKind.IF);
    this.advance();

    if (!this.expect(TokenKind.LEFT_PARENTHESIS)) {
      return null;
    }

    var value: Node;

    // Recover from a missing value
    if (this.peek(TokenKind.RIGHT_PARENTHESIS)) {
      this.unexpectedToken();
      this.advance();
      value = createParseError();
    }

    else {
      value = this.parseExpression(Precedence.LOWEST, ParseKind.EXPRESSION);
      if (value == null || !this.expect(TokenKind.RIGHT_PARENTHESIS)) {
        return null;
      }
    }

    var trueBranch = this.parseBody();
    if (trueBranch == null) {
      return null;
    }

    var falseBranch: Node = null;
    if (this.eat(TokenKind.ELSE)) {
      falseBranch = this.parseBody();
      if (falseBranch == null) {
        return null;
      }
    }

    return createIf(value, trueBranch, falseBranch).withRange(spanRanges(
      token.range, (falseBranch != null ? falseBranch : trueBranch).range));
  }

  parseWhile(): Node {
    var token = this.current;
    assert(token.kind == TokenKind.WHILE);
    this.advance();

    if (!this.expect(TokenKind.LEFT_PARENTHESIS)) {
      return null;
    }

    var value: Node;

    // Recover from a missing value
    if (this.peek(TokenKind.RIGHT_PARENTHESIS)) {
      this.unexpectedToken();
      this.advance();
      value = createParseError();
    }

    else {
      value = this.parseExpression(Precedence.LOWEST, ParseKind.EXPRESSION);
      if (value == null || !this.expect(TokenKind.RIGHT_PARENTHESIS)) {
        return null;
      }
    }

    var body = this.parseBody();
    if (body == null) {
      return null;
    }

    return createWhile(value, body).withRange(spanRanges(token.range, body.range));
  }

  parseBody(): Node {
    var node = this.parseStatement(StatementMode.NORMAL);
    if (node == null) {
      return null;
    }

    if (node.kind == NodeKind.BLOCK) {
      return node;
    }

    var block = createBlock();
    block.appendChild(node);
    return block.withRange(node.range);
  }

  parseBlock(): Node {
    var open = this.current;
    if (!this.expect(TokenKind.LEFT_BRACE)) {
      return null;
    }

    var block = createBlock();
    if (!this.parseStatements(block)) {
      return null;
    }

    var close = this.current;
    if (!this.expect(TokenKind.RIGHT_BRACE)) {
      return null;
    }

    return block.withRange(spanRanges(open.range, close.range));
  }

  parseReturn(): Node {
    var token = this.current;
    assert(token.kind == TokenKind.RETURN);
    this.advance();

    var value: Node = null;
    if (!this.peek(TokenKind.SEMICOLON)) {
      value = this.parseExpression(Precedence.LOWEST, ParseKind.EXPRESSION);
      if (value == null) {
        return null;
      }
    }

    var semicolon = this.current;
    this.expect(TokenKind.SEMICOLON);
    return createReturn(value).withRange(spanRanges(token.range, semicolon.range));
  }

  parseEmpty(): Node {
    var token = this.current;
    this.advance();
    return createEmpty().withRange(token.range);
  }

  parseEnum(firstFlag: NodeFlag): Node {
    var token = this.current;
    assert(token.kind == TokenKind.ENUM);
    this.advance();

    var name = this.current;
    if (!this.expect(TokenKind.IDENTIFIER) || !this.expect(TokenKind.LEFT_BRACE)) {
      return null;
    }

    var text = name.range.toString();
    var node = createEnum(text);
    node.firstFlag = firstFlag;
    node.flags = allFlags(firstFlag);

    while (!this.peek(TokenKind.END_OF_FILE) && !this.peek(TokenKind.RIGHT_BRACE)) {
      var member = this.current.range;
      var value: Node = null;

      if (!this.expect(TokenKind.IDENTIFIER)) {
        return null;
      }

      if (this.eat(TokenKind.ASSIGN)) {
        value = this.parseExpression(Precedence.LOWEST, ParseKind.EXPRESSION);
        if (value == null) {
          return null;
        }
      }

      var variable = createVariable(member.toString(), createName(text), value);
      node.appendChild(variable.withRange(value != null ? spanRanges(member, value.range) : member).withInternalRange(member));

      // Recover from a terminating semicolon
      if (this.peek(TokenKind.SEMICOLON)) {
        this.expect(TokenKind.COMMA);
        this.advance();
      }

      // Recover from a missing comma
      else if (this.peek(TokenKind.IDENTIFIER)) {
        this.expect(TokenKind.COMMA);
      }

      else if (!this.eat(TokenKind.COMMA)) {
        break;
      }
    }

    var close = this.current;
    if (!this.expect(TokenKind.RIGHT_BRACE)) {
      return null;
    }

    return node.withRange(spanRanges(token.range, close.range)).withInternalRange(name.range);
  }

  parseClass(firstFlag: NodeFlag): Node {
    var token = this.current;
    assert(token.kind == TokenKind.CLASS);
    this.advance();

    var name = this.current;
    if (!this.expect(TokenKind.IDENTIFIER) || !this.expect(TokenKind.LEFT_BRACE)) {
      return null;
    }

    var node = createClass(name.range.toString());
    node.firstFlag = firstFlag;
    node.flags = allFlags(firstFlag);

    while (!this.peek(TokenKind.END_OF_FILE) && !this.peek(TokenKind.RIGHT_BRACE)) {
      var childFlags = this.parseFlags();
      var childName = this.current;
      var oldKind = childName.kind;

      // Support contextual keywords
      if (isKeyword(childName.kind)) {
        childName.kind = TokenKind.IDENTIFIER;
        this.advance();
      }

      // The identifier must come first without any keyword
      if (!this.expect(TokenKind.IDENTIFIER)) {
        return null;
      }

      var text = childName.range.toString();

      // Support operator definitions
      if (String_equalNew(text, "operator") && this.peek(TokenKind.LEFT_BRACKET)) {
        childName.kind = TokenKind.OPERATOR;
        this.current = childName;
        if (this.parseFunction(childFlags, node) == null) {
          return null;
        }
        continue;
      }

      // Is there another identifier after the first one?
      else if (this.peek(TokenKind.IDENTIFIER)) {
        var isGet = String_equalNew(text, "get");
        var isSet = String_equalNew(text, "set");

        // The "get" and "set" flags are contextual
        if (isGet || isSet) {
          childFlags = appendFlag(childFlags, isGet ? NODE_FLAG_GET : NODE_FLAG_SET, childName.range);

          // Get the real identifier
          childName = this.current;
          this.advance();
        }

        // Recover from an extra "function" token
        else if (oldKind == TokenKind.FUNCTION) {
          this.log.error(childName.range, String_new("Instance functions don't need the 'function' keyword"));

          // Get the real identifier
          childName = this.current;
          this.advance();
        }

        // Recover from an extra variable tokens
        else if (oldKind == TokenKind.CONST || oldKind == TokenKind.LET || oldKind == TokenKind.VAR) {
          this.log.error(childName.range, String_appendNew(String_append(
            String_new("Instance variables don't need the '"),
            childName.range.toString()),
            "' keyword"));

          // Get the real identifier
          childName = this.current;
          this.advance();
        }
      }

      // Function
      if (this.peek(TokenKind.LEFT_PARENTHESIS)) {
        this.current = childName;
        if (this.parseFunction(childFlags, node) == null) {
          return null;
        }
      }

      // Variable
      else {
        this.current = childName;
        if (this.parseVariables(childFlags, node) == null) {
          return null;
        }
      }
    }

    var close = this.current;
    if (!this.expect(TokenKind.RIGHT_BRACE)) {
      return null;
    }

    return node.withRange(spanRanges(token.range, close.range)).withInternalRange(name.range);
  }

  parseFunction(firstFlag: NodeFlag, parent: Node): Node {
    var token = this.current;
    var nameRange: Range;
    var name: String;

    // Support index operators
    if (parent != null && this.eat(TokenKind.OPERATOR)) {
      var end = this.current;

      if (!this.expect(TokenKind.LEFT_BRACKET) || !this.expect(TokenKind.RIGHT_BRACKET)) {
        return null;
      }

      if (this.peek(TokenKind.ASSIGN)) {
        nameRange = spanRanges(token.range, this.current.range);
        name = String_new("[]=");
        this.advance();
      }

      else {
        nameRange = spanRanges(token.range, end.range);
        name = String_new("[]");
      }
    }

    else {
      // Functions inside class declarations don't use "function"
      if (parent == null) {
        assert(token.kind == TokenKind.FUNCTION);
        this.advance();
      }

      // Remember where the name is for the symbol later
      nameRange = this.current.range;
      if (!this.expect(TokenKind.IDENTIFIER)) {
        return null;
      }
      name = nameRange.toString();
    }

    if (!this.expect(TokenKind.LEFT_PARENTHESIS)) {
      return null;
    }

    var node = createFunction(name);
    node.firstFlag = firstFlag;
    node.flags = allFlags(firstFlag);

    if (!this.peek(TokenKind.RIGHT_PARENTHESIS)) {
      while (true) {
        var firstArgumentFlag = this.parseFlags();

        var argument = this.current;
        if (!this.expect(TokenKind.IDENTIFIER)) {
          return null;
        }

        var type: Node;
        var range = argument.range;

        if (this.expect(TokenKind.COLON)) {
          type = this.parseType();

          if (type != null) {
            range = spanRanges(range, type.range);
          }

          // Recover from a missing type
          else if (this.peek(TokenKind.COMMA) || this.peek(TokenKind.RIGHT_PARENTHESIS)) {
            type = createParseError();
          }

          else {
            return null;
          }
        }

        // Recover from a missing colon
        else if (this.peek(TokenKind.COMMA) || this.peek(TokenKind.RIGHT_PARENTHESIS)) {
          type = createParseError();
        }

        var variable = createVariable(argument.range.toString(), type, null);
        variable.firstFlag = firstArgumentFlag;
        variable.flags = allFlags(firstArgumentFlag);
        node.appendChild(variable.withRange(range).withInternalRange(argument.range));

        if (!this.eat(TokenKind.COMMA)) {
          break;
        }
      }
    }

    if (!this.expect(TokenKind.RIGHT_PARENTHESIS)) {
      return null;
    }

    var returnType: Node;

    if (this.expect(TokenKind.COLON)) {
      returnType = this.parseType();

      if (returnType == null) {
        // Recover from a missing return type
        if (this.peek(TokenKind.SEMICOLON) || this.peek(TokenKind.LEFT_BRACE)) {
          returnType = createParseError();
        }

        else {
          return null;
        }
      }
    }

    // Recover from a missing colon
    else if (this.peek(TokenKind.SEMICOLON) || this.peek(TokenKind.LEFT_BRACE)) {
      returnType = createParseError();
    }

    else {
      return null;
    }

    node.appendChild(returnType);
    var block: Node = null;

    // Is this an import?
    var semicolon = this.current;
    if (this.eat(TokenKind.SEMICOLON)) {
      block = createEmpty().withRange(semicolon.range);
    }

    // Normal functions
    else {
      block = this.parseBlock();
      if (block == null) {
        return null;
      }
    }

    // Add this to the enclosing class
    if (parent != null) {
      parent.appendChild(node);
    }

    node.appendChild(block);
    return node.withRange(spanRanges(token.range, block.range)).withInternalRange(nameRange);
  }

  parseVariables(firstFlag: NodeFlag, parent: Node): Node {
    var token = this.current;

    // Variables inside class declarations don't use "var"
    if (parent == null) {
      assert(token.kind == TokenKind.CONST || token.kind == TokenKind.LET || token.kind == TokenKind.VAR);
      this.advance();
    }

    var node = token.kind == TokenKind.CONST ? createConstants() : createVariables();

    while (true) {
      var name = this.current;
      if (!this.expect(TokenKind.IDENTIFIER)) {
        return null;
      }

      var type: Node = null;
      if (this.eat(TokenKind.COLON)) {
        type = this.parseType();
        if (type == null) {
          return null;
        }
      }

      var value: Node = null;
      if (this.eat(TokenKind.ASSIGN)) {
        value = this.parseExpression(Precedence.LOWEST, ParseKind.EXPRESSION);
        if (value == null) {
          return null;
        }

        // TODO: Implement constructors
        if (parent != null) {
          this.log.error(value.range, String_new("Inline initialization of instance variables is not supported yet"));
        }
      }

      var range =
        value != null ? spanRanges(name.range, value.range) :
        type != null ? spanRanges(name.range, type.range) :
        name.range;

      var variable = createVariable(name.range.toString(), type, value);
      variable.firstFlag = firstFlag;
      variable.flags = allFlags(firstFlag);
      (parent != null ? parent : node).appendChild(variable.withRange(range).withInternalRange(name.range));

      if (!this.eat(TokenKind.COMMA)) {
        break;
      }
    }

    var semicolon = this.current;
    this.expect(TokenKind.SEMICOLON);
    return node.withRange(spanRanges(token.range, semicolon.range));
  }

  parseLoopJump(kind: NodeKind): Node {
    var token = this.current;
    this.advance();
    this.expect(TokenKind.SEMICOLON);
    var node = new Node();
    node.kind = kind;
    return node.withRange(token.range);
  }

  parseFlags(): NodeFlag {
    var firstFlag: NodeFlag = null;
    var lastFlag: NodeFlag = null;

    while (true) {
      var token = this.current;
      var flag: int;

      if (this.eat(TokenKind.DECLARE)) flag = NODE_FLAG_DECLARE;
      else if (this.eat(TokenKind.EXPORT)) flag = NODE_FLAG_EXPORT;
      else if (this.eat(TokenKind.EXTERN)) flag = NODE_FLAG_EXTERN;
      else if (this.eat(TokenKind.PRIVATE)) flag = NODE_FLAG_PRIVATE;
      else if (this.eat(TokenKind.PROTECTED)) flag = NODE_FLAG_PROTECTED;
      else if (this.eat(TokenKind.PUBLIC)) flag = NODE_FLAG_PUBLIC;
      else if (this.eat(TokenKind.STATIC)) flag = NODE_FLAG_STATIC;
      else if (this.eat(TokenKind.UNSAFE)) flag = NODE_FLAG_UNSAFE;
      else return firstFlag;

      var link = new NodeFlag();
      link.flag = flag;
      link.range = token.range;

      if (firstFlag == null) firstFlag = link;
      else lastFlag.next = link;
      lastFlag = link;
    }
  }

  parseUnsafe(): Node {
    var token = this.current;
    this.advance();

    var node = this.parseBlock();
    if (node == null) {
      return null;
    }

    node.flags = node.flags | NODE_FLAG_UNSAFE;
    return node.withRange(spanRanges(token.range, node.range));
  }

  parseStatement(mode: StatementMode): Node {
    var firstFlag = mode == StatementMode.GLOBAL ? this.parseFlags() : null;

    if (this.peek(TokenKind.UNSAFE) && firstFlag == null) return this.parseUnsafe();
    if (this.peek(TokenKind.CONST) || this.peek(TokenKind.LET) || this.peek(TokenKind.VAR)) return this.parseVariables(firstFlag, null);
    if (this.peek(TokenKind.FUNCTION)) return this.parseFunction(firstFlag, null);
    if (this.peek(TokenKind.CLASS)) return this.parseClass(firstFlag);
    if (this.peek(TokenKind.ENUM)) return this.parseEnum(firstFlag);

    // Definition modifiers need to be attached to a definition
    if (firstFlag != null) {
      this.unexpectedToken();
      return null;
    }

    if (this.peek(TokenKind.LEFT_BRACE)) return this.parseBlock();
    if (this.peek(TokenKind.BREAK)) return this.parseLoopJump(NodeKind.BREAK);
    if (this.peek(TokenKind.CONTINUE)) return this.parseLoopJump(NodeKind.CONTINUE);
    if (this.peek(TokenKind.IF)) return this.parseIf();
    if (this.peek(TokenKind.WHILE)) return this.parseWhile();
    if (this.peek(TokenKind.RETURN)) return this.parseReturn();
    if (this.peek(TokenKind.SEMICOLON)) return this.parseEmpty();

    // Parse an expression statement
    var value = this.parseExpression(Precedence.LOWEST, ParseKind.EXPRESSION);

    if (value == null) {
      return null;
    }

    var semicolon = this.current;
    this.expect(TokenKind.SEMICOLON);
    return createExpression(value).withRange(spanRanges(value.range, semicolon.range));
  }

  parseStatements(parent: Node): bool {
    while (!this.peek(TokenKind.END_OF_FILE) && !this.peek(TokenKind.RIGHT_BRACE)) {
      var child = this.parseStatement(parent.kind == NodeKind.GLOBAL ? StatementMode.GLOBAL : StatementMode.NORMAL);
      if (child == null) {
        return false;
      }
      parent.appendChild(child);
    }
    return true;
  }

  parseInt(range: Range, node: Node): bool {
    var source = range.source;
    var i = range.start;
    var limit = range.end;
    var value: uint = 0;
    var base: uint = 10;

    // Handle binary, octal, and hexadecimal prefixes
    if (String_get(source.contents, i) == '0' && i + 1 < limit) {
      var c = String_get(source.contents, i + 1);
      if (c == 'b' || c == 'B') base = 2;
      else if (c == 'o' || c == 'O') base = 8;
      else if (c == 'x' || c == 'X') base = 16;
      else {
        this.log.error(range, String_new("Use the '0o' prefix for octal integers"));
        return false;
      }
      if (base != 10) i = i + 2;
    }

    while (i < limit) {
      var c = String_get(source.contents, i);
      var digit = (
        c >= 'A' && c <= 'F' ? c + (10 - 'A') :
        c >= 'a' && c <= 'f' ? c + (10 - 'a') :
        c - '0'
      ) as uint;
      var baseValue = value * base;

      // Check for overflow (unsigned integer overflow supposedly doesn't result in undefined behavior)
      if (baseValue / base != value || baseValue > ~0 as uint - digit) {
        this.log.error(range, String_new("Integer literal is too big to fit in 32 bits"));
        return false;
      }

      value = baseValue + digit;
      i = i + 1;
    }

    node.intValue = value as int;
    return true;
  }
}

function parse(firstToken: Token, log: Log): Node {
  var context = new ParserContext();
  context.current = firstToken;
  context.log = log;

  var global = new Node();
  global.kind = NodeKind.GLOBAL;
  if (!context.parseStatements(global)) {
    return null;
  }
  return global;
}
enum FindNested {
  NORMAL,
  ALLOW_INSTANCE_ERRORS,
}

class Scope {
  parent: Scope;
  symbol: Symbol;
  firstSymbol: Symbol;
  lastSymbol: Symbol;

  findLocal(name: String): Symbol {
    var symbol = this.firstSymbol;
    while (symbol != null) {
      if (String_equal(symbol.name, name)) {
        return symbol;
      }
      symbol = symbol.next;
    }
    return null;
  }

  findNested(name: String, mode: FindNested): Symbol {
    var scope = this;
    while (scope != null) {
      if (scope.symbol == null || scope.symbol.kind != SymbolKind.TYPE_CLASS || mode == FindNested.ALLOW_INSTANCE_ERRORS) {
        var local = scope.findLocal(name);
        if (local != null) {
          return local;
        }
      }
      scope = scope.parent;
    }
    return null;
  }

  define(log: Log, symbol: Symbol): bool {
    var existing = this.findLocal(symbol.name);
    if (existing != null) {
      log.error(symbol.range, String_appendNew(String_append(String_new("Duplicate symbol '"), symbol.name), "'"));
      return false;
    }

    if (this.firstSymbol == null) this.firstSymbol = symbol;
    else this.lastSymbol.next = symbol;
    this.lastSymbol = symbol;

    return true;
  }

  defineNativeType(log: Log, name: string, byteSizeAndMaxAlignment: int): Type {
    var symbol = new Symbol();
    symbol.kind = SymbolKind.TYPE_NATIVE;
    symbol.name = String_new(name);
    symbol.byteSize = byteSizeAndMaxAlignment;
    symbol.maxAlignment = byteSizeAndMaxAlignment;
    symbol.resolvedType = new Type();
    symbol.resolvedType.symbol = symbol;
    symbol.state = SymbolState.INITIALIZED;
    this.define(log, symbol);
    return symbol.resolvedType;
  }

  defineNativeIntegerType(log: Log, name: string, byteSizeAndMaxAlignment: int, isUnsigned: bool): Type {
    var type = this.defineNativeType(log, name, byteSizeAndMaxAlignment);
    type.symbol.flags = isUnsigned ? SYMBOL_FLAG_NATIVE_INTEGER | SYMBOL_FLAG_IS_UNSIGNED : SYMBOL_FLAG_NATIVE_INTEGER;
    return type;
  }
}
enum SymbolKind {
  TYPE_CLASS,
  TYPE_ENUM,
  TYPE_GLOBAL,
  TYPE_NATIVE,

  FUNCTION_INSTANCE,
  FUNCTION_GLOBAL,

  VARIABLE_ARGUMENT,
  VARIABLE_CONSTANT,
  VARIABLE_GLOBAL,
  VARIABLE_INSTANCE,
  VARIABLE_LOCAL,
}

function isType(kind: SymbolKind): bool {
  return kind >= SymbolKind.TYPE_CLASS && kind <= SymbolKind.TYPE_NATIVE;
}

function isFunction(kind: SymbolKind): bool {
  return kind >= SymbolKind.FUNCTION_INSTANCE && kind <= SymbolKind.FUNCTION_GLOBAL;
}

function isVariable(kind: SymbolKind): bool {
  return kind >= SymbolKind.VARIABLE_ARGUMENT && kind <= SymbolKind.VARIABLE_LOCAL;
}

enum SymbolState {
  UNINITIALIZED,
  INITIALIZING,
  INITIALIZED,
}

const SYMBOL_FLAG_NATIVE_INTEGER = 1;
const SYMBOL_FLAG_IS_UNSIGNED = 2;

class Symbol {
  kind: SymbolKind;
  name: String;
  node: Node;
  range: Range;
  scope: Scope;
  resolvedType: Type;
  next: Symbol;
  state: SymbolState;
  flags: int;
  byteSize: int;
  maxAlignment: int;

  // The "offset" variable is used to store kind-specific information
  //
  //   TYPE_CLASS: N/A
  //   TYPE_ENUM: N/A
  //   TYPE_GLOBAL: N/A
  //   TYPE_NATIVE: N/A
  //
  //   FUNCTION_INSTANCE: N/A
  //   FUNCTION_GLOBAL: N/A
  //
  //   VARIABLE_ARGUMENT: Argument index
  //   VARIABLE_CONSTANT: Integer constant value
  //   VARIABLE_GLOBAL: Memory address relative to start address
  //   VARIABLE_INSTANCE: Instance offset
  //   VARIABLE_LOCAL: N/A
  //
  offset: int;

  isEnumValue(): bool {
    return this.node.parent.kind == NodeKind.ENUM;
  }

  isUnsafe(): bool {
    return this.node != null && this.node.isUnsafe();
  }

  parent(): Symbol {
    var parent = this.node.parent;
    return parent.kind == NodeKind.CLASS ? parent.symbol : null;
  }

  resolvedTypeUnderlyingIfEnumValue(context: CheckContext): Type {
    return this.isEnumValue() ? this.resolvedType.underlyingType(context) : this.resolvedType;
  }

  determineClassLayout(context: CheckContext): void {
    assert(this.kind == SymbolKind.TYPE_CLASS);

    // Only determine class layout once
    if (this.byteSize != 0) {
      return;
    }

    var offset = 0;
    var child = this.node.firstChild;
    var maxAlignment = 1;

    while (child != null) {
      if (child.kind == NodeKind.VARIABLE) {
        var type = child.symbol.resolvedType;

        // Ignore invalid members
        if (type != context.errorType) {
          var alignmentOf = type.variableAlignmentOf();

          // Align the member to the next available slot
          offset = alignToNextMultipleOf(offset, alignmentOf);
          if (alignmentOf > maxAlignment) maxAlignment = alignmentOf;

          // Allocate the member by extending the object
          child.symbol.offset = offset;
          offset = offset + type.variableSizeOf();
        }
      }

      child = child.nextSibling;
    }

    // All objects must have a non-zero size
    if (offset == 0) {
      offset = 1;
    }

    // The object size must be a multiple of the maximum alignment for arrays to work correctly
    offset = alignToNextMultipleOf(offset, maxAlignment);

    this.byteSize = offset;
    this.maxAlignment = maxAlignment;
  }
}
const POINTER_SIZE = 4;

enum ConversionKind {
  IMPLICIT,
  EXPLICIT,
}

class Type {
  symbol: Symbol;

  isClass(): bool {
    return this.symbol.kind == SymbolKind.TYPE_CLASS;
  }

  isEnum(): bool {
    return this.symbol.kind == SymbolKind.TYPE_ENUM;
  }

  isInteger(): bool {
    return (this.symbol.flags & SYMBOL_FLAG_NATIVE_INTEGER) != 0 || this.isEnum();
  }

  isUnsigned(): bool {
    return (this.symbol.flags & SYMBOL_FLAG_IS_UNSIGNED) != 0;
  }

  underlyingType(context: CheckContext): Type {
    return this.isEnum() ? context.intType : this;
  }

  integerBitCount(): int {
    return this.symbol.byteSize * 8;
  }

  integerBitMask(): uint {
    return ~0 as uint >> (32 - this.integerBitCount()) as uint;
  }

  isReference(context: CheckContext): bool {
    return this == context.stringType || this.isClass();
  }

  allocationSizeOf(): int {
    return this.symbol.byteSize;
  }

  allocationAlignmentOf(): int {
    return this.allocationSizeOf(); // This is true right now
  }

  variableSizeOf(): int {
    return this.isClass() ? POINTER_SIZE : this.symbol.byteSize;
  }

  variableAlignmentOf(): int {
    return this.variableSizeOf(); // This is true right now
  }

  toString(): String {
    return this.symbol.name;
  }

  findMember(name: String): Symbol {
    var child = this.symbol.node.firstChild;

    while (child != null) {
      assert(child.kind == NodeKind.VARIABLE || child.kind == NodeKind.FUNCTION);

      if (String_equal(child.symbol.name, name)) {
        return child.symbol;
      }

      child = child.nextSibling;
    }

    return null;
  }
}
// Control flow operators
const WASM_OPCODE_NOP: byte = 0;
const WASM_OPCODE_BLOCK: byte = 1;
const WASM_OPCODE_LOOP: byte = 2;
const WASM_OPCODE_IF: byte = 3;
const WASM_OPCODE_IF_ELSE: byte = 4;
const WASM_OPCODE_SELECT: byte = 5;
const WASM_OPCODE_BR: byte = 6;
const WASM_OPCODE_BR_IF: byte = 7;
const WASM_OPCODE_BR_TABLE: byte = 8;
const WASM_OPCODE_RETURN: byte = 20;
const WASM_OPCODE_UNREACHABLE: byte = 21;

// Basic operators
const WASM_OPCODE_I32_CONST: byte = 10;
const WASM_OPCODE_I64_CONST: byte = 11;
const WASM_OPCODE_F64_CONST: byte = 12;
const WASM_OPCODE_F32_CONST: byte = 13;
const WASM_OPCODE_GET_LOCAL: byte = 14;
const WASM_OPCODE_SET_LOCAL: byte = 15;
const WASM_OPCODE_CALL: byte = 18;
const WASM_OPCODE_CALL_INDIRECT: byte = 19;
const WASM_OPCODE_CALL_IMPORT: byte = 31;

// Memory-related operators
const WASM_OPCODE_I32_LOAD8_S: byte = 32;
const WASM_OPCODE_I32_LOAD8_U: byte = 33;
const WASM_OPCODE_I32_LOAD16_S: byte = 34;
const WASM_OPCODE_I32_LOAD16_U: byte = 35;
const WASM_OPCODE_I64_LOAD8_S: byte = 36;
const WASM_OPCODE_I64_LOAD8_U: byte = 37;
const WASM_OPCODE_I64_LOAD16_S: byte = 38;
const WASM_OPCODE_I64_LOAD16_U: byte = 39;
const WASM_OPCODE_I64_LOAD32_S: byte = 40;
const WASM_OPCODE_I64_LOAD32_U: byte = 41;
const WASM_OPCODE_I32_LOAD: byte = 42;
const WASM_OPCODE_I64_LOAD: byte = 43;
const WASM_OPCODE_F32_LOAD: byte = 44;
const WASM_OPCODE_F64_LOAD: byte = 45;
const WASM_OPCODE_I32_STORE8: byte = 46;
const WASM_OPCODE_I32_STORE16: byte = 47;
const WASM_OPCODE_I64_STORE8: byte = 48;
const WASM_OPCODE_I64_STORE16: byte = 49;
const WASM_OPCODE_I64_STORE32: byte = 50;
const WASM_OPCODE_I32_STORE: byte = 51;
const WASM_OPCODE_I64_STORE: byte = 52;
const WASM_OPCODE_F32_STORE: byte = 53;
const WASM_OPCODE_F64_STORE: byte = 54;
const WASM_OPCODE_MEMORY_SIZE: byte = 59;
const WASM_OPCODE_GROW_MEMORY: byte = 57;

// Simple operators
const WASM_OPCODE_I32_ADD: byte = 64;
const WASM_OPCODE_I32_SUB: byte = 65;
const WASM_OPCODE_I32_MUL: byte = 66;
const WASM_OPCODE_I32_DIV_S: byte = 67;
const WASM_OPCODE_I32_DIV_U: byte = 68;
const WASM_OPCODE_I32_REM_S: byte = 69;
const WASM_OPCODE_I32_REM_U: byte = 70;
const WASM_OPCODE_I32_AND: byte = 71;
const WASM_OPCODE_I32_OR: byte = 72;
const WASM_OPCODE_I32_XOR: byte = 73;
const WASM_OPCODE_I32_SHL: byte = 74;
const WASM_OPCODE_I32_SHR_U: byte = 75;
const WASM_OPCODE_I32_SHR_S: byte = 76;
const WASM_OPCODE_I32_ROTR: byte = 182;
const WASM_OPCODE_I32_ROTL: byte = 183;
const WASM_OPCODE_I32_EQ: byte = 77;
const WASM_OPCODE_I32_NE: byte = 78;
const WASM_OPCODE_I32_LT_S: byte = 79;
const WASM_OPCODE_I32_LE_S: byte = 80;
const WASM_OPCODE_I32_LT_U: byte = 81;
const WASM_OPCODE_I32_LE_U: byte = 82;
const WASM_OPCODE_I32_GT_S: byte = 83;
const WASM_OPCODE_I32_GE_S: byte = 84;
const WASM_OPCODE_I32_GT_U: byte = 85;
const WASM_OPCODE_I32_GE_U: byte = 86;
const WASM_OPCODE_I32_CLZ: byte = 87;
const WASM_OPCODE_I32_CTZ: byte = 88;
const WASM_OPCODE_I32_POPCNT: byte = 89;
const WASM_OPCODE_I32_EQZ: byte = 90;
const WASM_OPCODE_I64_ADD: byte = 91;
const WASM_OPCODE_I64_SUB: byte = 92;
const WASM_OPCODE_I64_MUL: byte = 93;
const WASM_OPCODE_I64_DIV_S: byte = 94;
const WASM_OPCODE_I64_DIV_U: byte = 95;
const WASM_OPCODE_I64_REM_S: byte = 96;
const WASM_OPCODE_I64_REM_U: byte = 97;
const WASM_OPCODE_I64_AND: byte = 98;
const WASM_OPCODE_I64_OR: byte = 99;
const WASM_OPCODE_I64_XOR: byte = 100;
const WASM_OPCODE_I64_SHL: byte = 101;
const WASM_OPCODE_I64_SHR_U: byte = 102;
const WASM_OPCODE_I64_SHR_S: byte = 103;
const WASM_OPCODE_I64_ROTR: byte = 184;
const WASM_OPCODE_I64_ROTL: byte = 185;
const WASM_OPCODE_I64_EQ: byte = 104;
const WASM_OPCODE_I64_NE: byte = 105;
const WASM_OPCODE_I64_LT_S: byte = 106;
const WASM_OPCODE_I64_LE_S: byte = 107;
const WASM_OPCODE_I64_LT_U: byte = 108;
const WASM_OPCODE_I64_LE_U: byte = 109;
const WASM_OPCODE_I64_GT_S: byte = 110;
const WASM_OPCODE_I64_GE_S: byte = 111;
const WASM_OPCODE_I64_GT_U: byte = 112;
const WASM_OPCODE_I64_GE_U: byte = 113;
const WASM_OPCODE_I64_CLZ: byte = 114;
const WASM_OPCODE_I64_CTZ: byte = 115;
const WASM_OPCODE_I64_POPCNT: byte = 116;
const WASM_OPCODE_I64_EQZ: byte = 186;
const WASM_OPCODE_F32_ADD: byte = 117;
const WASM_OPCODE_F32_SUB: byte = 118;
const WASM_OPCODE_F32_MUL: byte = 119;
const WASM_OPCODE_F32_DIV: byte = 120;
const WASM_OPCODE_F32_MIN: byte = 121;
const WASM_OPCODE_F32_MAX: byte = 122;
const WASM_OPCODE_F32_ABS: byte = 123;
const WASM_OPCODE_F32_NEG: byte = 124;
const WASM_OPCODE_F32_COPYSIGN: byte = 125;
const WASM_OPCODE_F32_CEIL: byte = 126;
const WASM_OPCODE_F32_FLOOR: byte = 127;
const WASM_OPCODE_F32_TRUNC: byte = 128;
const WASM_OPCODE_F32_NEAREST: byte = 129;
const WASM_OPCODE_F32_SQRT: byte = 130;
const WASM_OPCODE_F32_EQ: byte = 131;
const WASM_OPCODE_F32_NE: byte = 132;
const WASM_OPCODE_F32_LT: byte = 133;
const WASM_OPCODE_F32_LE: byte = 134;
const WASM_OPCODE_F32_GT: byte = 135;
const WASM_OPCODE_F32_GE: byte = 136;
const WASM_OPCODE_F64_ADD: byte = 137;
const WASM_OPCODE_F64_SUB: byte = 138;
const WASM_OPCODE_F64_MUL: byte = 139;
const WASM_OPCODE_F64_DIV: byte = 140;
const WASM_OPCODE_F64_MIN: byte = 141;
const WASM_OPCODE_F64_MAX: byte = 142;
const WASM_OPCODE_F64_ABS: byte = 143;
const WASM_OPCODE_F64_NEG: byte = 144;
const WASM_OPCODE_F64_COPYSIGN: byte = 145;
const WASM_OPCODE_F64_CEIL: byte = 146;
const WASM_OPCODE_F64_FLOOR: byte = 147;
const WASM_OPCODE_F64_TRUNC: byte = 148;
const WASM_OPCODE_F64_NEAREST: byte = 149;
const WASM_OPCODE_F64_SQRT: byte = 150;
const WASM_OPCODE_F64_EQ: byte = 151;
const WASM_OPCODE_F64_NE: byte = 152;
const WASM_OPCODE_F64_LT: byte = 153;
const WASM_OPCODE_F64_LE: byte = 154;
const WASM_OPCODE_F64_GT: byte = 155;
const WASM_OPCODE_F64_GE: byte = 156;
const WASM_OPCODE_I32_TRUNC_S_F32: byte = 157;
const WASM_OPCODE_I32_TRUNC_S_F64: byte = 158;
const WASM_OPCODE_I32_TRUNC_U_F32: byte = 159;
const WASM_OPCODE_I32_TRUNC_U_F64: byte = 160;
const WASM_OPCODE_I32_WRAP_I64: byte = 161;
const WASM_OPCODE_I64_TRUNC_S_F32: byte = 162;
const WASM_OPCODE_I64_TRUNC_S_F64: byte = 163;
const WASM_OPCODE_I64_TRUNC_U_F32: byte = 164;
const WASM_OPCODE_I64_TRUNC_U_F64: byte = 165;
const WASM_OPCODE_I64_EXTEND_S_I32: byte = 166;
const WASM_OPCODE_I64_EXTEND_U_I32: byte = 167;
const WASM_OPCODE_F32_CONVERT_S_I32: byte = 168;
const WASM_OPCODE_F32_CONVERT_U_I32: byte = 169;
const WASM_OPCODE_F32_CONVERT_S_I64: byte = 170;
const WASM_OPCODE_F32_CONVERT_U_I64: byte = 171;
const WASM_OPCODE_F32_DEMOTE_F64: byte = 172;
const WASM_OPCODE_F32_REINTERPRET_I32: byte = 173;
const WASM_OPCODE_F64_CONVERT_S_I32: byte = 174;
const WASM_OPCODE_F64_CONVERT_U_I32: byte = 175;
const WASM_OPCODE_F64_CONVERT_S_I64: byte = 176;
const WASM_OPCODE_F64_CONVERT_U_I64: byte = 177;
const WASM_OPCODE_F64_PROMOTE_F32: byte = 178;
const WASM_OPCODE_F64_REINTERPRET_I64: byte = 179;
const WASM_OPCODE_I32_REINTERPRET_F32: byte = 180;
const WASM_OPCODE_I64_REINTERPRET_F64: byte = 181;

const WASM_MAGIC = '\0' | 'a' << 8 | 's' << 16 | 'm' << 24;
const WASM_VERSION = 10;
const WASM_SIZE_IN_PAGES = 64;
const WASM_MEMORY_INITIALIZER_BASE = 8; // Leave space for "null"

enum WasmType {
  VOID = 0,
  I32 = 1,
  I64 = 2,
  F32 = 3,
  F64 = 4,
}

class WasmWrappedType {
  id: WasmType;
  next: WasmWrappedType;
}

class WasmSignature {
  argumentTypes: WasmWrappedType;
  returnType: WasmWrappedType;
  next: WasmSignature;
}

function wasmAreSignaturesEqual(a: WasmSignature, b: WasmSignature): bool {
  assert(a.returnType != null);
  assert(b.returnType != null);
  assert(a.returnType.next == null);
  assert(b.returnType.next == null);

  var x = a.argumentTypes;
  var y = b.argumentTypes;

  while (x != null && y != null) {
    if (x.id != y.id) {
      return false;
    }

    x = x.next;
    y = y.next;
  }

  if (x != null || y != null) {
    return false;
  }

  if (a.returnType.id != b.returnType.id) {
    return false;
  }

  return true;
}

class WasmFunction {
  name: String;
  signatureIndex: int;
  body: Node;
  isExported: bool;
  intLocalCount: int;
  next: WasmFunction;
}

class WasmImport {
  signatureIndex: int;
  module: String;
  name: String;
  next: WasmImport;
}

class WasmModule {
  firstImport: WasmImport;
  lastImport: WasmImport;
  importCount: int;

  firstFunction: WasmFunction;
  lastFunction: WasmFunction;
  functionCount: int;

  firstSignature: WasmSignature;
  lastSignature: WasmSignature;
  signatureCount: int;

  memoryInitializer: ByteArray;
  currentHeapPointer: int;
  originalHeapPointer: int;
  mallocFunctionIndex: int;
  context: CheckContext;

  growMemoryInitializer(): void {
    var array = this.memoryInitializer;
    var current = array.length();
    var length = this.context.nextGlobalVariableOffset;

    while (current < length) {
      array.append(0);
      current = current + 1;
    }
  }

  allocateImport(signatureIndex: int, mod: String, name: String): WasmImport {
    var result = new WasmImport();
    result.signatureIndex = signatureIndex;
    result.module = mod;
    result.name = name;

    if (this.firstImport == null) this.firstImport = result;
    else this.lastImport.next = result;
    this.lastImport = result;

    this.importCount = this.importCount + 1;
    return result;
  }

  allocateFunction(name: String, signatureIndex: int, body: Node): WasmFunction {
    var fn = new WasmFunction();
    fn.name = name;
    fn.signatureIndex = signatureIndex;
    fn.body = body;

    if (this.firstFunction == null) this.firstFunction = fn;
    else this.lastFunction.next = fn;
    this.lastFunction = fn;

    this.functionCount = this.functionCount + 1;
    return fn;
  }

  allocateSignature(argumentTypes: WasmWrappedType, returnType: WasmWrappedType): int {
    assert(returnType != null);
    assert(returnType.next == null);

    var signature = new WasmSignature();
    signature.argumentTypes = argumentTypes;
    signature.returnType = returnType;

    var check = this.firstSignature;
    var i = 0;

    while (check != null) {
      if (wasmAreSignaturesEqual(signature, check)) {
        return i;
      }

      check = check.next;
      i = i + 1;
    }

    if (this.firstSignature == null) this.firstSignature = signature;
    else this.lastSignature.next = signature;
    this.lastSignature = signature;

    this.signatureCount = this.signatureCount + 1;
    return i;
  }

  emitModule(array: ByteArray): void {
    ByteArray_append32(array, WASM_MAGIC);
    ByteArray_append32(array, WASM_VERSION);

    this.emitSignatures(array);
    this.emitImportTable(array);
    this.emitFunctionSignatures(array);
    this.emitMemory(array);
    this.emitExportTable(array);
    this.emitFunctionBodies(array);
    this.emitDataSegments(array);
  }

  emitSignatures(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("signatures"));
    wasmWriteVarUnsigned(array, this.signatureCount);

    var signature = this.firstSignature;
    while (signature != null) {
      var count = 0;
      var type = signature.argumentTypes;

      while (type != null) {
        count = count + 1;
        type = type.next;
      }

      wasmWriteVarUnsigned(array, count);
      wasmWriteVarUnsigned(array, signature.returnType.id as int);

      type = signature.argumentTypes;
      while (type != null) {
        wasmWriteVarUnsigned(array, type.id as int);
        type = type.next;
      }

      signature = signature.next;
    }

    wasmFinishSection(array, section);
  }

  emitImportTable(array: ByteArray): void {
    if (this.firstImport == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("import_table"));
    wasmWriteVarUnsigned(array, this.importCount);

    var current = this.firstImport;
    while (current != null) {
      wasmWriteVarUnsigned(array, current.signatureIndex);
      wasmWriteLengthPrefixedString(array, current.module);
      wasmWriteLengthPrefixedString(array, current.name);
      current = current.next;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionSignatures(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_signatures"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      wasmWriteVarUnsigned(array, fn.signatureIndex);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitMemory(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("memory"));
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, 1); // The memory array is exported
    wasmFinishSection(array, section);
  }

  emitExportTable(array: ByteArray): void {
    var exportedCount = 0;
    var fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        exportedCount = exportedCount + 1;
      }
      fn = fn.next;
    }
    if (exportedCount == 0) {
      return;
    }

    var section = wasmStartSection(array, String_new("export_table"));
    wasmWriteVarUnsigned(array, exportedCount);

    var i = 0;
    fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        wasmWriteVarUnsigned(array, i);
        wasmWriteLengthPrefixedString(array, fn.name);
      }
      fn = fn.next;
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionBodies(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_bodies"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      var bodyLength = array.length();
      wasmWriteVarUnsigned(array, ~0); // This will be patched later

      if (fn.intLocalCount > 0) {
        wasmWriteVarUnsigned(array, 1);
        wasmWriteVarUnsigned(array, fn.intLocalCount);
        array.append(WasmType.I32);
      } else {
        wasmWriteVarUnsigned(array, 0);
      }

      var child = fn.body.firstChild;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }

      wasmPatchVarUnsigned(array, bodyLength, array.length() - bodyLength - 5, ~0);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitDataSegments(array: ByteArray): void {
    this.growMemoryInitializer();
    var memoryInitializer = this.memoryInitializer;
    var initializerLength = memoryInitializer.length();
    var initialHeapPointer = alignToNextMultipleOf(WASM_MEMORY_INITIALIZER_BASE + initializerLength, 8);

    // Pass the initial heap pointer to the "malloc" function
    ByteArray_set32(memoryInitializer, this.currentHeapPointer, initialHeapPointer);
    ByteArray_set32(memoryInitializer, this.originalHeapPointer, initialHeapPointer);

    var section = wasmStartSection(array, String_new("data_segments"));

    // This only writes one single section containing everything
    wasmWriteVarUnsigned(array, 1);

    // Emit the range of the memory initializer
    wasmWriteVarUnsigned(array, WASM_MEMORY_INITIALIZER_BASE);
    wasmWriteVarUnsigned(array, initializerLength);

    // Copy the entire memory initializer (also includes zero-initialized data for now)
    var i = 0;
    while (i < initializerLength) {
      array.append(memoryInitializer.get(i));
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  prepareToEmit(node: Node): void {
    if (node.kind == NodeKind.STRING) {
      var text = node.stringValue;
      var length = String_length(text);
      var offset = this.context.allocateGlobalVariableOffset(length + 1, 1);;
      this.growMemoryInitializer();
      var memoryInitializer = this.memoryInitializer;
      var i = 0;
      while (i < length) {
        memoryInitializer.set(offset + i, String_get(text, i) as byte);
        i = i + 1;
      }
      memoryInitializer.set(offset + length, 0);
      node.intValue = offset;
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        var sizeOf = symbol.resolvedType.variableSizeOf();
        var value = symbol.node.variableValue().intValue;
        var memoryInitializer = this.memoryInitializer;

        // Copy the inital value into the memory initializer
        this.growMemoryInitializer();
        if (sizeOf == 1) memoryInitializer.set(symbol.offset, value as byte);
        else if (sizeOf == 2) ByteArray_set16(memoryInitializer, symbol.offset, value);
        else if (sizeOf == 4) ByteArray_set32(memoryInitializer, symbol.offset, value);
        else assert(false);

        // Make sure the heap offset is tracked
        if (String_equalNew(symbol.name, "currentHeapPointer")) {
          assert(this.currentHeapPointer == -1);
          this.currentHeapPointer = symbol.offset;
        }

        // Make sure the heap offset is tracked
        else if (String_equalNew(symbol.name, "originalHeapPointer")) {
          assert(this.originalHeapPointer == -1);
          this.originalHeapPointer = symbol.offset;
        }
      }
    }

    else if (node.kind == NodeKind.FUNCTION) {
      var returnType = node.functionReturnType();
      var shared = new WasmSharedOffset();
      var argumentTypesFirst: WasmWrappedType = null;
      var argumentTypesLast: WasmWrappedType = null;

      // Make sure to include the implicit "this" variable as a normal argument
      var argument = node.firstChild;
      while (argument != returnType) {
        var type = wasmWrapType(this.getWasmType(argument.variableType().resolvedType));

        if (argumentTypesFirst == null) argumentTypesFirst = type;
        else argumentTypesLast.next = type;
        argumentTypesLast = type;

        shared.nextLocalOffset = shared.nextLocalOffset + 1;
        argument = argument.nextSibling;
      }
      var signatureIndex = this.allocateSignature(argumentTypesFirst, wasmWrapType(this.getWasmType(returnType.resolvedType)));
      var body = node.functionBody();
      var symbol = node.symbol;

      // Functions without bodies are imports
      if (body == null) {
        var moduleName = symbol.kind == SymbolKind.FUNCTION_INSTANCE ? symbol.parent().name : String_new("globals");
        symbol.offset = this.importCount;
        this.allocateImport(signatureIndex, moduleName, symbol.name);
        node = node.nextSibling;
        return;
      }

      symbol.offset = this.functionCount;
      var fn = this.allocateFunction(symbol.name, signatureIndex, body);

      // Make sure "malloc" is tracked
      if (symbol.kind == SymbolKind.FUNCTION_GLOBAL && String_equalNew(symbol.name, "malloc")) {
        assert(this.mallocFunctionIndex == -1);
        this.mallocFunctionIndex = symbol.offset;
      }

      // Only export "extern" functions
      if (node.isExtern()) {
        fn.isExported = true;
      }

      // Assign local variable offsets
      wasmAssignLocalVariableOffsets(body, shared);
      fn.intLocalCount = shared.intLocalCount;
    }

    var child = node.firstChild;
    while (child != null) {
      this.prepareToEmit(child);
      child = child.nextSibling;
    }
  }

  emitBinaryExpression(array: ByteArray, node: Node, opcode: byte): void {
    array.append(opcode);
    this.emitNode(array, node.binaryLeft());
    this.emitNode(array, node.binaryRight());
  }

  emitLoadFromMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD8_U : WASM_OPCODE_I32_LOAD8_S);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD16_U : WASM_OPCODE_I32_LOAD16_S);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_LOAD);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }
  }

  emitStoreToMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int, value: Node): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(WASM_OPCODE_I32_STORE8);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(WASM_OPCODE_I32_STORE16);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_STORE);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }

    this.emitNode(array, value);
  }

  emitNode(array: ByteArray, node: Node): int {
    assert(!isExpression(node) || node.resolvedType != null);

    if (node.kind == NodeKind.BLOCK) {
      array.append(WASM_OPCODE_BLOCK);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.WHILE) {
      var value = node.whileValue();
      var body = node.whileBody();

      // Ignore "while (false) { ... }"
      if (value.kind == NodeKind.BOOL && value.intValue == 0) {
        return 0;
      }

      array.append(WASM_OPCODE_LOOP);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;

      // Emit the condition as "loop { if (!condition) break; }" as long as it's not a "while (true)" loop
      if (value.kind != NodeKind.BOOL) {
        array.append(WASM_OPCODE_BR_IF);
        wasmWriteVarUnsigned(array, 1); // Break out of the immediately enclosing loop
        array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
        array.append(WASM_OPCODE_I32_EQZ); // The conditional is flipped
        this.emitNode(array, value);
        count = count + 1;
      }

      var child = body.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }

      // Jump back to the top (this doesn't happen automatically)
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, 0); // Continue back to the immediately enclosing loop
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
      count = count + 1;

      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.BREAK || node.kind == NodeKind.CONTINUE) {
      var label = 0;
      var parent = node.parent;

      while (parent != null && parent.kind != NodeKind.WHILE) {
        if (parent.kind == NodeKind.BLOCK) {
          label = label + 1;
        }
        parent = parent.parent;
      }

      assert(label > 0);
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, label - (node.kind == NodeKind.BREAK ? 0 : 1));
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
    }

    else if (node.kind == NodeKind.EMPTY) {
      return 0;
    }

    else if (node.kind == NodeKind.EXPRESSION) {
      this.emitNode(array, node.expressionValue());
    }

    else if (node.kind == NodeKind.RETURN) {
      var value = node.returnValue();
      array.append(WASM_OPCODE_RETURN);
      if (value != null) {
        this.emitNode(array, value);
      }
    }

    else if (node.kind == NodeKind.VARIABLES) {
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        assert(child.kind == NodeKind.VARIABLE);
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      return count;
    }

    else if (node.kind == NodeKind.IF) {
      var branch = node.ifFalse();
      array.append(branch == null ? WASM_OPCODE_IF : WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.ifValue());
      this.emitNode(array, node.ifTrue());
      if (branch != null) {
        this.emitNode(array, branch);
      }
    }

    else if (node.kind == NodeKind.HOOK) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.hookValue());
      this.emitNode(array, node.hookTrue());
      this.emitNode(array, node.hookFalse());
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var value = node.variableValue();

      if (node.symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, node.symbol.offset);

        if (value != null) {
          this.emitNode(array, value);
        }

        // Default initialization
        else {
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, 0);
        }
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NAME) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_GET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitLoadFromMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NULL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.INT || node.kind == NodeKind.BOOL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, node.intValue);
    }

    else if (node.kind == NodeKind.STRING) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, WASM_MEMORY_INITIALIZER_BASE + node.intValue);
    }

    else if (node.kind == NodeKind.CALL) {
      var value = node.callValue();
      var symbol = value.symbol;
      assert(isFunction(symbol.kind));

      array.append(symbol.node.functionBody() == null ? WASM_OPCODE_CALL_IMPORT : WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, symbol.offset);

      // Write out the implicit "this" argument
      if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
        this.emitNode(array, value.dotTarget());
      }

      var child = value.nextSibling;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }
    }

    else if (node.kind == NodeKind.NEW) {
      var type = node.newType();
      assert(type.symbol.kind == SymbolKind.TYPE_CLASS);

      array.append(WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, this.mallocFunctionIndex);

      // Pass the object size as the first argument
      assert(type.symbol.byteSize > 0);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, type.symbol.byteSize);
    }

    else if (node.kind == NodeKind.POSITIVE) {
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NEGATIVE) {
      array.append(WASM_OPCODE_I32_SUB);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.COMPLEMENT) {
      array.append(WASM_OPCODE_I32_XOR);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, ~0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NOT) {
      array.append(WASM_OPCODE_I32_EQZ);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.CAST) {
      var value = node.castValue();
      var context = this.context;
      var from = value.resolvedType.underlyingType(context);
      var type = node.resolvedType.underlyingType(context);

      // The cast isn't needed if it's to a wider integer type
      if (from == type || from.symbol.byteSize < type.symbol.byteSize) {
        this.emitNode(array, value);
      }

      else {
        // Sign-extend
        if (type == context.byteType || type == context.shortType) {
          var shift = 32 - type.symbol.byteSize * 8;
          array.append(WASM_OPCODE_I32_SHR_S);
          array.append(WASM_OPCODE_I32_SHL);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
        }

        // Mask
        else if (type == context.ubyteType || type == context.ushortType) {
          array.append(WASM_OPCODE_I32_AND);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, type.integerBitMask() as int);
        }

        // No cast needed
        else {
          this.emitNode(array, value);
        }
      }
    }

    else if (node.kind == NodeKind.DOT) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitLoadFromMemory(array, symbol.resolvedType, node.dotTarget(), symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.ASSIGN) {
      var left = node.binaryLeft();
      var symbol = left.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitStoreToMemory(array, symbol.resolvedType, left.dotTarget(), symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitStoreToMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
        this.emitNode(array, node.binaryRight());
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.LOGICAL_AND) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      this.emitNode(array, node.binaryRight());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.LOGICAL_OR) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 1);
      this.emitNode(array, node.binaryRight());
    }

    else {
      var isUnsigned = node.isUnsignedOperator();

      if (node.kind == NodeKind.ADD) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_ADD);
      else if (node.kind == NodeKind.BITWISE_AND) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_AND);
      else if (node.kind == NodeKind.BITWISE_OR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_OR);
      else if (node.kind == NodeKind.BITWISE_XOR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_XOR);
      else if (node.kind == NodeKind.EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_EQ);
      else if (node.kind == NodeKind.MULTIPLY) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_MUL);
      else if (node.kind == NodeKind.NOT_EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_NE);
      else if (node.kind == NodeKind.SHIFT_LEFT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SHL);
      else if (node.kind == NodeKind.SUBTRACT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SUB);

      else if (node.kind == NodeKind.DIVIDE) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_DIV_U : WASM_OPCODE_I32_DIV_S);
      else if (node.kind == NodeKind.GREATER_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GT_U : WASM_OPCODE_I32_GT_S);
      else if (node.kind == NodeKind.GREATER_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GE_U : WASM_OPCODE_I32_GE_S);
      else if (node.kind == NodeKind.LESS_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LT_U : WASM_OPCODE_I32_LT_S);
      else if (node.kind == NodeKind.LESS_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LE_U : WASM_OPCODE_I32_LE_S);
      else if (node.kind == NodeKind.REMAINDER) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_REM_U : WASM_OPCODE_I32_REM_S);
      else if (node.kind == NodeKind.SHIFT_RIGHT) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_SHR_U : WASM_OPCODE_I32_SHR_S);

      else {
        assert(false);
      }
    }

    return 1;
  }

  getWasmType(type: Type): WasmType {
    var context = this.context;

    if (type == context.boolType || type.isInteger() || type.isReference(context)) {
      return WasmType.I32;
    }

    if (type == context.voidType) {
      return WasmType.VOID;
    }

    assert(false);
    return WasmType.VOID;
  }
}

function wasmPatchVarUnsigned(array: ByteArray, offset: int, value: int, maxValue: int): void {
  var current = value as uint;
  var max = maxValue as uint;
  while (true) {
    var element = current & 127;
    current = current >> 7;
    max = max >> 7;
    if (max != 0) {
      element = element | 128;
    }
    array.set(offset, element as byte);
    offset = offset + 1;
    if (max == 0) {
      break;
    }
  }
}

function wasmWriteVarUnsigned(array: ByteArray, value: int): void {
  var current = value as uint;
  while (true) {
    var element = current & 127;
    current = current >> 7;
    if (current != 0) {
      element = element | 128;
    }
    array.append(element as byte);
    if (current == 0) {
      break;
    }
  }
}

function wasmWriteVarSigned(array: ByteArray, value: int): void {
  while (true) {
    var element = value & 127;
    value = value >> 7;
    var done =
      value == 0 && (element & 64) == 0 ||
      value == -1 && (element & 64) != 0;
    if (!done) {
      element = element | 128;
    }
    array.append(element as byte);
    if (done) {
      break;
    }
  }
}

function wasmWriteLengthPrefixedString(array: ByteArray, value: String): void {
  var length = String_length(value);
  wasmWriteVarUnsigned(array, length);
  var i = 0;
  while (i < length) {
    array.append(String_get(value, i) as byte);
    i = i + 1;
  }
}

function wasmStartSection(array: ByteArray, name: String): int {
  var offset = array.length();
  wasmWriteVarUnsigned(array, ~0); // Section length, will be filled in later
  wasmWriteLengthPrefixedString(array, name);
  return offset;
}

function wasmFinishSection(array: ByteArray, offset: int): void {
  wasmPatchVarUnsigned(array, offset, array.length() - offset - 5, ~0);
}

function wasmWrapType(id: WasmType): WasmWrappedType {
  assert(id == WasmType.VOID || id == WasmType.I32);
  var type = new WasmWrappedType();
  type.id = id;
  return type;
}

class WasmSharedOffset {
  nextLocalOffset: int;
  intLocalCount: int;
}

function wasmAssignLocalVariableOffsets(node: Node, shared: WasmSharedOffset): void {
  if (node.kind == NodeKind.VARIABLE) {
    assert(node.symbol.kind == SymbolKind.VARIABLE_LOCAL);
    node.symbol.offset = shared.nextLocalOffset;
    shared.nextLocalOffset = shared.nextLocalOffset + 1;
    shared.intLocalCount = shared.intLocalCount + 1;
  }

  var child = node.firstChild;
  while (child != null) {
    wasmAssignLocalVariableOffsets(child, shared);
    child = child.nextSibling;
  }
}

function wasmEmit(global: Node, context: CheckContext, array: ByteArray): void {
  var module = new WasmModule();
  module.context = context;
  module.memoryInitializer = new ByteArray();

  // Set these to invalid values since "0" is valid
  module.mallocFunctionIndex = -1;
  module.currentHeapPointer = -1;
  module.originalHeapPointer = -1;

  // Emission requires two passes
  module.prepareToEmit(global);

  // The standard library must be included
  assert(module.mallocFunctionIndex != -1);
  assert(module.currentHeapPointer != -1);
  assert(module.originalHeapPointer != -1);

  module.emitModule(array);
}

function tokenize2(source: Source, log: Log): Token {
  var first: Token = null;
  var last: Token = null;
  var contents = source.contents;
  var limit = String_length(contents);
  var i = 0;

  while (i < limit) {
    var start = i;
    var c = String_get(contents, i);
    i = i + 1;

    if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
      continue;
    }

    var kind = TokenKind.END_OF_FILE;

    // Identifier
    if (isAlpha(c)) {
      kind = TokenKind.IDENTIFIER;

      while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
        i = i + 1;
      }

      // Keywords
      var text = String_slice(contents, start, i);
      if (String_equalNew(text, "alignof")) kind = TokenKind.ALIGNOF;
      else if (String_equalNew(text, "as")) kind = TokenKind.AS;
      else if (String_equalNew(text, "break")) kind = TokenKind.BREAK;
      else if (String_equalNew(text, "class")) kind = TokenKind.CLASS;
      else if (String_equalNew(text, "const")) kind = TokenKind.CONST;
      else if (String_equalNew(text, "continue")) kind = TokenKind.CONTINUE;
      else if (String_equalNew(text, "declare")) kind = TokenKind.DECLARE;
      else if (String_equalNew(text, "else")) kind = TokenKind.ELSE;
      else if (String_equalNew(text, "enum")) kind = TokenKind.ENUM;
      else if (String_equalNew(text, "export")) kind = TokenKind.EXPORT;
      else if (String_equalNew(text, "extends")) kind = TokenKind.EXTENDS;
      else if (String_equalNew(text, "extern")) kind = TokenKind.EXTERN;
      else if (String_equalNew(text, "false")) kind = TokenKind.FALSE;
      else if (String_equalNew(text, "function")) kind = TokenKind.FUNCTION;
      else if (String_equalNew(text, "if")) kind = TokenKind.IF;
      else if (String_equalNew(text, "implements")) kind = TokenKind.IMPLEMENTS;
      else if (String_equalNew(text, "import")) kind = TokenKind.IMPORT;
      else if (String_equalNew(text, "interface")) kind = TokenKind.INTERFACE;
      else if (String_equalNew(text, "let")) kind = TokenKind.LET;
      else if (String_equalNew(text, "new")) kind = TokenKind.NEW;
      else if (String_equalNew(text, "null")) kind = TokenKind.NULL;
      else if (String_equalNew(text, "private")) kind = TokenKind.PRIVATE;
      else if (String_equalNew(text, "protected")) kind = TokenKind.PROTECTED;
      else if (String_equalNew(text, "public")) kind = TokenKind.PUBLIC;
      else if (String_equalNew(text, "return")) kind = TokenKind.RETURN;
      else if (String_equalNew(text, "sizeof")) kind = TokenKind.SIZEOF;
      else if (String_equalNew(text, "static")) kind = TokenKind.STATIC;
      else if (String_equalNew(text, "this")) kind = TokenKind.THIS;
      else if (String_equalNew(text, "true")) kind = TokenKind.TRUE;
      else if (String_equalNew(text, "unsafe")) kind = TokenKind.UNSAFE;
      else if (String_equalNew(text, "var")) kind = TokenKind.VAR;
      else if (String_equalNew(text, "while")) kind = TokenKind.WHILE;
    }

    // Integer
    else if (isNumber(c)) {
      kind = TokenKind.INT;

      if (i < limit) {
        var next = String_get(contents, i);
        var base = 10;

        // Handle binary, octal, and hexadecimal prefixes
        if (c == '0' && i + 1 < limit) {
          if (next == 'b' || next == 'B') base = 2;
          else if (next == 'o' || next == 'O') base = 8;
          else if (next == 'x' || next == 'X') base = 16;
          if (base != 10) {
            if (isDigit(String_get(contents, i + 1), base)) i = i + 2;
            else base = 10;
          }
        }

        // Scan the payload
        while (i < limit && isDigit(String_get(contents, i), base)) {
          i = i + 1;
        }

        // Extra letters after the end is an error
        if (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
          i = i + 1;

          while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
            i = i + 1;
          }

          log.error(createRange(source, start, i), String_appendNew(String_append(
            String_new("Invalid integer literal: '"),
            String_slice(contents, start, i)),
            "'"));
          return null;
        }
      }
    }

    // Character or string
    else if (c == '"' || c == '\'' || c == '`') {
      while (i < limit) {
        var next = String_get(contents, i);

        // Escape any character including newlines
        if (i + 1 < limit && next == '\\') {
          i = i + 2;
        }

        // Only allow newlines in template literals
        else if (next == '\n' && c != '`') {
          break;
        }

        // Handle a normal character
        else {
          i = i + 1;

          // End the string with a matching quote character
          if (next == c) {
            kind = c == '\'' ? TokenKind.CHARACTER : TokenKind.STRING;
            break;
          }
        }
      }

      // It's an error if we didn't find a matching quote character
      if (kind == TokenKind.END_OF_FILE) {
        log.error(createRange(source, start, i), String_new(
          c == '\'' ? "Unterminated character literal" :
          c == '`' ? "Unterminated template literal" :
          "Unterminated string literal"));
        return null;
      }
    }

    // Operators
    else if (c == '%') kind = TokenKind.REMAINDER;
    else if (c == '(') kind = TokenKind.LEFT_PARENTHESIS;
    else if (c == ')') kind = TokenKind.RIGHT_PARENTHESIS;
    else if (c == '*') kind = TokenKind.MULTIPLY;
    else if (c == ',') kind = TokenKind.COMMA;
    else if (c == '.') kind = TokenKind.DOT;
    else if (c == ':') kind = TokenKind.COLON;
    else if (c == ';') kind = TokenKind.SEMICOLON;
    else if (c == '?') kind = TokenKind.QUESTION_MARK;
    else if (c == '[') kind = TokenKind.LEFT_BRACKET;
    else if (c == ']') kind = TokenKind.RIGHT_BRACKET;
    else if (c == '^') kind = TokenKind.BITWISE_XOR;
    else if (c == '{') kind = TokenKind.LEFT_BRACE;
    else if (c == '}') kind = TokenKind.RIGHT_BRACE;
    else if (c == '~') kind = TokenKind.COMPLEMENT;

    // / or // or /*
    else if (c == '/') {
      kind = TokenKind.DIVIDE;

      // Single-line comments
      if (i < limit && String_get(contents, i) == '/') {
        i = i + 1;

        while (i < limit && String_get(contents, i) != '\n') {
          i = i + 1;
        }

        continue;
      }

      // Multi-line comments
      if (i < limit && String_get(contents, i) == '*') {
        i = i + 1;
        var foundEnd = false;

        while (i < limit) {
          var next = String_get(contents, i);

          if (next == '*' && i + 1 < limit && String_get(contents, i + 1) == '/') {
            foundEnd = true;
            i = i + 2;
            break;
          }

          i = i + 1;
        }

        if (!foundEnd) {
          log.error(createRange(source, start, start + 2), String_new("Unterminated multi-line comment"));
          return null;
        }

        continue;
      }
    }

    // ! or !=
    else if (c == '!') {
      kind = TokenKind.NOT;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.NOT_EQUAL;
        i = i + 1;

        // Recover from !==
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '!=' instead of '!=='"));
        }
      }
    }

    // = or ==
    else if (c == '=') {
      kind = TokenKind.ASSIGN;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.EQUAL;
        i = i + 1;

        // Recover from ===
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '==' instead of '==='"));
        }
      }
    }

    // + or ++
    else if (c == '+') {
      kind = TokenKind.PLUS;

      if (i < limit && String_get(contents, i) == '+') {
        kind = TokenKind.PLUS_PLUS;
        i = i + 1;
      }
    }

    // - or --
    else if (c == '-') {
      kind = TokenKind.MINUS;

      if (i < limit && String_get(contents, i) == '-') {
        kind = TokenKind.MINUS_MINUS;
        i = i + 1;
      }
    }

    // & or &&
    else if (c == '&') {
      kind = TokenKind.BITWISE_AND;

      if (i < limit && String_get(contents, i) == '&') {
        kind = TokenKind.LOGICAL_AND;
        i = i + 1;
      }
    }

    // | or ||
    else if (c == '|') {
      kind = TokenKind.BITWISE_OR;

      if (i < limit && String_get(contents, i) == '|') {
        kind = TokenKind.LOGICAL_OR;
        i = i + 1;
      }
    }

    // < or << or <=
    else if (c == '<') {
      kind = TokenKind.LESS_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '<') {
          kind = TokenKind.SHIFT_LEFT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.LESS_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    // > or >> or >=
    else if (c == '>') {
      kind = TokenKind.GREATER_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '>') {
          kind = TokenKind.SHIFT_RIGHT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.GREATER_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    var range = createRange(source, start, i);

    if (kind == TokenKind.END_OF_FILE) {
      log.error(range,
        String_appendNew(
          String_append(
            String_new("Syntax error: '"),
            String_slice(contents, start, start + 1)),
          "'"));
      return null;
    }

    var token = new Token();
    token.kind = kind;
    token.range = range;

    if (first == null) first = token;
    else last.next = token;
    last = token;
  }

  var eof = new Token();
  eof.kind = TokenKind.END_OF_FILE;
  eof.range = createRange(source, limit, limit);

  if (first == null) first = eof;
  else last.next = eof;
  last = eof;

  return first;
}

function tokenize3(source: Source, log: Log): Token {
  var first: Token = null;
  var last: Token = null;
  var contents = source.contents;
  var limit = String_length(contents);
  var i = 0;

  while (i < limit) {
    var start = i;
    var c = String_get(contents, i);
    i = i + 1;

    if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
      continue;
    }

    var kind = TokenKind.END_OF_FILE;

    // Identifier
    if (isAlpha(c)) {
      kind = TokenKind.IDENTIFIER;

      while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
        i = i + 1;
      }

      // Keywords
      var text = String_slice(contents, start, i);
      if (String_equalNew(text, "alignof")) kind = TokenKind.ALIGNOF;
      else if (String_equalNew(text, "as")) kind = TokenKind.AS;
      else if (String_equalNew(text, "break")) kind = TokenKind.BREAK;
      else if (String_equalNew(text, "class")) kind = TokenKind.CLASS;
      else if (String_equalNew(text, "const")) kind = TokenKind.CONST;
      else if (String_equalNew(text, "continue")) kind = TokenKind.CONTINUE;
      else if (String_equalNew(text, "declare")) kind = TokenKind.DECLARE;
      else if (String_equalNew(text, "else")) kind = TokenKind.ELSE;
      else if (String_equalNew(text, "enum")) kind = TokenKind.ENUM;
      else if (String_equalNew(text, "export")) kind = TokenKind.EXPORT;
      else if (String_equalNew(text, "extends")) kind = TokenKind.EXTENDS;
      else if (String_equalNew(text, "extern")) kind = TokenKind.EXTERN;
      else if (String_equalNew(text, "false")) kind = TokenKind.FALSE;
      else if (String_equalNew(text, "function")) kind = TokenKind.FUNCTION;
      else if (String_equalNew(text, "if")) kind = TokenKind.IF;
      else if (String_equalNew(text, "implements")) kind = TokenKind.IMPLEMENTS;
      else if (String_equalNew(text, "import")) kind = TokenKind.IMPORT;
      else if (String_equalNew(text, "interface")) kind = TokenKind.INTERFACE;
      else if (String_equalNew(text, "let")) kind = TokenKind.LET;
      else if (String_equalNew(text, "new")) kind = TokenKind.NEW;
      else if (String_equalNew(text, "null")) kind = TokenKind.NULL;
      else if (String_equalNew(text, "private")) kind = TokenKind.PRIVATE;
      else if (String_equalNew(text, "protected")) kind = TokenKind.PROTECTED;
      else if (String_equalNew(text, "public")) kind = TokenKind.PUBLIC;
      else if (String_equalNew(text, "return")) kind = TokenKind.RETURN;
      else if (String_equalNew(text, "sizeof")) kind = TokenKind.SIZEOF;
      else if (String_equalNew(text, "static")) kind = TokenKind.STATIC;
      else if (String_equalNew(text, "this")) kind = TokenKind.THIS;
      else if (String_equalNew(text, "true")) kind = TokenKind.TRUE;
      else if (String_equalNew(text, "unsafe")) kind = TokenKind.UNSAFE;
      else if (String_equalNew(text, "var")) kind = TokenKind.VAR;
      else if (String_equalNew(text, "while")) kind = TokenKind.WHILE;
    }

    // Integer
    else if (isNumber(c)) {
      kind = TokenKind.INT;

      if (i < limit) {
        var next = String_get(contents, i);
        var base = 10;

        // Handle binary, octal, and hexadecimal prefixes
        if (c == '0' && i + 1 < limit) {
          if (next == 'b' || next == 'B') base = 2;
          else if (next == 'o' || next == 'O') base = 8;
          else if (next == 'x' || next == 'X') base = 16;
          if (base != 10) {
            if (isDigit(String_get(contents, i + 1), base)) i = i + 2;
            else base = 10;
          }
        }

        // Scan the payload
        while (i < limit && isDigit(String_get(contents, i), base)) {
          i = i + 1;
        }

        // Extra letters after the end is an error
        if (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
          i = i + 1;

          while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
            i = i + 1;
          }

          log.error(createRange(source, start, i), String_appendNew(String_append(
            String_new("Invalid integer literal: '"),
            String_slice(contents, start, i)),
            "'"));
          return null;
        }
      }
    }

    // Character or string
    else if (c == '"' || c == '\'' || c == '`') {
      while (i < limit) {
        var next = String_get(contents, i);

        // Escape any character including newlines
        if (i + 1 < limit && next == '\\') {
          i = i + 2;
        }

        // Only allow newlines in template literals
        else if (next == '\n' && c != '`') {
          break;
        }

        // Handle a normal character
        else {
          i = i + 1;

          // End the string with a matching quote character
          if (next == c) {
            kind = c == '\'' ? TokenKind.CHARACTER : TokenKind.STRING;
            break;
          }
        }
      }

      // It's an error if we didn't find a matching quote character
      if (kind == TokenKind.END_OF_FILE) {
        log.error(createRange(source, start, i), String_new(
          c == '\'' ? "Unterminated character literal" :
          c == '`' ? "Unterminated template literal" :
          "Unterminated string literal"));
        return null;
      }
    }

    // Operators
    else if (c == '%') kind = TokenKind.REMAINDER;
    else if (c == '(') kind = TokenKind.LEFT_PARENTHESIS;
    else if (c == ')') kind = TokenKind.RIGHT_PARENTHESIS;
    else if (c == '*') kind = TokenKind.MULTIPLY;
    else if (c == ',') kind = TokenKind.COMMA;
    else if (c == '.') kind = TokenKind.DOT;
    else if (c == ':') kind = TokenKind.COLON;
    else if (c == ';') kind = TokenKind.SEMICOLON;
    else if (c == '?') kind = TokenKind.QUESTION_MARK;
    else if (c == '[') kind = TokenKind.LEFT_BRACKET;
    else if (c == ']') kind = TokenKind.RIGHT_BRACKET;
    else if (c == '^') kind = TokenKind.BITWISE_XOR;
    else if (c == '{') kind = TokenKind.LEFT_BRACE;
    else if (c == '}') kind = TokenKind.RIGHT_BRACE;
    else if (c == '~') kind = TokenKind.COMPLEMENT;

    // / or // or /*
    else if (c == '/') {
      kind = TokenKind.DIVIDE;

      // Single-line comments
      if (i < limit && String_get(contents, i) == '/') {
        i = i + 1;

        while (i < limit && String_get(contents, i) != '\n') {
          i = i + 1;
        }

        continue;
      }

      // Multi-line comments
      if (i < limit && String_get(contents, i) == '*') {
        i = i + 1;
        var foundEnd = false;

        while (i < limit) {
          var next = String_get(contents, i);

          if (next == '*' && i + 1 < limit && String_get(contents, i + 1) == '/') {
            foundEnd = true;
            i = i + 2;
            break;
          }

          i = i + 1;
        }

        if (!foundEnd) {
          log.error(createRange(source, start, start + 2), String_new("Unterminated multi-line comment"));
          return null;
        }

        continue;
      }
    }

    // ! or !=
    else if (c == '!') {
      kind = TokenKind.NOT;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.NOT_EQUAL;
        i = i + 1;

        // Recover from !==
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '!=' instead of '!=='"));
        }
      }
    }

    // = or ==
    else if (c == '=') {
      kind = TokenKind.ASSIGN;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.EQUAL;
        i = i + 1;

        // Recover from ===
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '==' instead of '==='"));
        }
      }
    }

    // + or ++
    else if (c == '+') {
      kind = TokenKind.PLUS;

      if (i < limit && String_get(contents, i) == '+') {
        kind = TokenKind.PLUS_PLUS;
        i = i + 1;
      }
    }

    // - or --
    else if (c == '-') {
      kind = TokenKind.MINUS;

      if (i < limit && String_get(contents, i) == '-') {
        kind = TokenKind.MINUS_MINUS;
        i = i + 1;
      }
    }

    // & or &&
    else if (c == '&') {
      kind = TokenKind.BITWISE_AND;

      if (i < limit && String_get(contents, i) == '&') {
        kind = TokenKind.LOGICAL_AND;
        i = i + 1;
      }
    }

    // | or ||
    else if (c == '|') {
      kind = TokenKind.BITWISE_OR;

      if (i < limit && String_get(contents, i) == '|') {
        kind = TokenKind.LOGICAL_OR;
        i = i + 1;
      }
    }

    // < or << or <=
    else if (c == '<') {
      kind = TokenKind.LESS_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '<') {
          kind = TokenKind.SHIFT_LEFT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.LESS_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    // > or >> or >=
    else if (c == '>') {
      kind = TokenKind.GREATER_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '>') {
          kind = TokenKind.SHIFT_RIGHT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.GREATER_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    var range = createRange(source, start, i);

    if (kind == TokenKind.END_OF_FILE) {
      log.error(range,
        String_appendNew(
          String_append(
            String_new("Syntax error: '"),
            String_slice(contents, start, start + 1)),
          "'"));
      return null;
    }

    var token = new Token();
    token.kind = kind;
    token.range = range;

    if (first == null) first = token;
    else last.next = token;
    last = token;
  }

  var eof = new Token();
  eof.kind = TokenKind.END_OF_FILE;
  eof.range = createRange(source, limit, limit);

  if (first == null) first = eof;
  else last.next = eof;
  last = eof;

  return first;
}

function tokenize4(source: Source, log: Log): Token {
  var first: Token = null;
  var last: Token = null;
  var contents = source.contents;
  var limit = String_length(contents);
  var i = 0;

  while (i < limit) {
    var start = i;
    var c = String_get(contents, i);
    i = i + 1;

    if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
      continue;
    }

    var kind = TokenKind.END_OF_FILE;

    // Identifier
    if (isAlpha(c)) {
      kind = TokenKind.IDENTIFIER;

      while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
        i = i + 1;
      }

      // Keywords
      var text = String_slice(contents, start, i);
      if (String_equalNew(text, "alignof")) kind = TokenKind.ALIGNOF;
      else if (String_equalNew(text, "as")) kind = TokenKind.AS;
      else if (String_equalNew(text, "break")) kind = TokenKind.BREAK;
      else if (String_equalNew(text, "class")) kind = TokenKind.CLASS;
      else if (String_equalNew(text, "const")) kind = TokenKind.CONST;
      else if (String_equalNew(text, "continue")) kind = TokenKind.CONTINUE;
      else if (String_equalNew(text, "declare")) kind = TokenKind.DECLARE;
      else if (String_equalNew(text, "else")) kind = TokenKind.ELSE;
      else if (String_equalNew(text, "enum")) kind = TokenKind.ENUM;
      else if (String_equalNew(text, "export")) kind = TokenKind.EXPORT;
      else if (String_equalNew(text, "extends")) kind = TokenKind.EXTENDS;
      else if (String_equalNew(text, "extern")) kind = TokenKind.EXTERN;
      else if (String_equalNew(text, "false")) kind = TokenKind.FALSE;
      else if (String_equalNew(text, "function")) kind = TokenKind.FUNCTION;
      else if (String_equalNew(text, "if")) kind = TokenKind.IF;
      else if (String_equalNew(text, "implements")) kind = TokenKind.IMPLEMENTS;
      else if (String_equalNew(text, "import")) kind = TokenKind.IMPORT;
      else if (String_equalNew(text, "interface")) kind = TokenKind.INTERFACE;
      else if (String_equalNew(text, "let")) kind = TokenKind.LET;
      else if (String_equalNew(text, "new")) kind = TokenKind.NEW;
      else if (String_equalNew(text, "null")) kind = TokenKind.NULL;
      else if (String_equalNew(text, "private")) kind = TokenKind.PRIVATE;
      else if (String_equalNew(text, "protected")) kind = TokenKind.PROTECTED;
      else if (String_equalNew(text, "public")) kind = TokenKind.PUBLIC;
      else if (String_equalNew(text, "return")) kind = TokenKind.RETURN;
      else if (String_equalNew(text, "sizeof")) kind = TokenKind.SIZEOF;
      else if (String_equalNew(text, "static")) kind = TokenKind.STATIC;
      else if (String_equalNew(text, "this")) kind = TokenKind.THIS;
      else if (String_equalNew(text, "true")) kind = TokenKind.TRUE;
      else if (String_equalNew(text, "unsafe")) kind = TokenKind.UNSAFE;
      else if (String_equalNew(text, "var")) kind = TokenKind.VAR;
      else if (String_equalNew(text, "while")) kind = TokenKind.WHILE;
    }

    // Integer
    else if (isNumber(c)) {
      kind = TokenKind.INT;

      if (i < limit) {
        var next = String_get(contents, i);
        var base = 10;

        // Handle binary, octal, and hexadecimal prefixes
        if (c == '0' && i + 1 < limit) {
          if (next == 'b' || next == 'B') base = 2;
          else if (next == 'o' || next == 'O') base = 8;
          else if (next == 'x' || next == 'X') base = 16;
          if (base != 10) {
            if (isDigit(String_get(contents, i + 1), base)) i = i + 2;
            else base = 10;
          }
        }

        // Scan the payload
        while (i < limit && isDigit(String_get(contents, i), base)) {
          i = i + 1;
        }

        // Extra letters after the end is an error
        if (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
          i = i + 1;

          while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
            i = i + 1;
          }

          log.error(createRange(source, start, i), String_appendNew(String_append(
            String_new("Invalid integer literal: '"),
            String_slice(contents, start, i)),
            "'"));
          return null;
        }
      }
    }

    // Character or string
    else if (c == '"' || c == '\'' || c == '`') {
      while (i < limit) {
        var next = String_get(contents, i);

        // Escape any character including newlines
        if (i + 1 < limit && next == '\\') {
          i = i + 2;
        }

        // Only allow newlines in template literals
        else if (next == '\n' && c != '`') {
          break;
        }

        // Handle a normal character
        else {
          i = i + 1;

          // End the string with a matching quote character
          if (next == c) {
            kind = c == '\'' ? TokenKind.CHARACTER : TokenKind.STRING;
            break;
          }
        }
      }

      // It's an error if we didn't find a matching quote character
      if (kind == TokenKind.END_OF_FILE) {
        log.error(createRange(source, start, i), String_new(
          c == '\'' ? "Unterminated character literal" :
          c == '`' ? "Unterminated template literal" :
          "Unterminated string literal"));
        return null;
      }
    }

    // Operators
    else if (c == '%') kind = TokenKind.REMAINDER;
    else if (c == '(') kind = TokenKind.LEFT_PARENTHESIS;
    else if (c == ')') kind = TokenKind.RIGHT_PARENTHESIS;
    else if (c == '*') kind = TokenKind.MULTIPLY;
    else if (c == ',') kind = TokenKind.COMMA;
    else if (c == '.') kind = TokenKind.DOT;
    else if (c == ':') kind = TokenKind.COLON;
    else if (c == ';') kind = TokenKind.SEMICOLON;
    else if (c == '?') kind = TokenKind.QUESTION_MARK;
    else if (c == '[') kind = TokenKind.LEFT_BRACKET;
    else if (c == ']') kind = TokenKind.RIGHT_BRACKET;
    else if (c == '^') kind = TokenKind.BITWISE_XOR;
    else if (c == '{') kind = TokenKind.LEFT_BRACE;
    else if (c == '}') kind = TokenKind.RIGHT_BRACE;
    else if (c == '~') kind = TokenKind.COMPLEMENT;

    // / or // or /*
    else if (c == '/') {
      kind = TokenKind.DIVIDE;

      // Single-line comments
      if (i < limit && String_get(contents, i) == '/') {
        i = i + 1;

        while (i < limit && String_get(contents, i) != '\n') {
          i = i + 1;
        }

        continue;
      }

      // Multi-line comments
      if (i < limit && String_get(contents, i) == '*') {
        i = i + 1;
        var foundEnd = false;

        while (i < limit) {
          var next = String_get(contents, i);

          if (next == '*' && i + 1 < limit && String_get(contents, i + 1) == '/') {
            foundEnd = true;
            i = i + 2;
            break;
          }

          i = i + 1;
        }

        if (!foundEnd) {
          log.error(createRange(source, start, start + 2), String_new("Unterminated multi-line comment"));
          return null;
        }

        continue;
      }
    }

    // ! or !=
    else if (c == '!') {
      kind = TokenKind.NOT;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.NOT_EQUAL;
        i = i + 1;

        // Recover from !==
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '!=' instead of '!=='"));
        }
      }
    }

    // = or ==
    else if (c == '=') {
      kind = TokenKind.ASSIGN;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.EQUAL;
        i = i + 1;

        // Recover from ===
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '==' instead of '==='"));
        }
      }
    }

    // + or ++
    else if (c == '+') {
      kind = TokenKind.PLUS;

      if (i < limit && String_get(contents, i) == '+') {
        kind = TokenKind.PLUS_PLUS;
        i = i + 1;
      }
    }

    // - or --
    else if (c == '-') {
      kind = TokenKind.MINUS;

      if (i < limit && String_get(contents, i) == '-') {
        kind = TokenKind.MINUS_MINUS;
        i = i + 1;
      }
    }

    // & or &&
    else if (c == '&') {
      kind = TokenKind.BITWISE_AND;

      if (i < limit && String_get(contents, i) == '&') {
        kind = TokenKind.LOGICAL_AND;
        i = i + 1;
      }
    }

    // | or ||
    else if (c == '|') {
      kind = TokenKind.BITWISE_OR;

      if (i < limit && String_get(contents, i) == '|') {
        kind = TokenKind.LOGICAL_OR;
        i = i + 1;
      }
    }

    // < or << or <=
    else if (c == '<') {
      kind = TokenKind.LESS_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '<') {
          kind = TokenKind.SHIFT_LEFT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.LESS_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    // > or >> or >=
    else if (c == '>') {
      kind = TokenKind.GREATER_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '>') {
          kind = TokenKind.SHIFT_RIGHT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.GREATER_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    var range = createRange(source, start, i);

    if (kind == TokenKind.END_OF_FILE) {
      log.error(range,
        String_appendNew(
          String_append(
            String_new("Syntax error: '"),
            String_slice(contents, start, start + 1)),
          "'"));
      return null;
    }

    var token = new Token();
    token.kind = kind;
    token.range = range;

    if (first == null) first = token;
    else last.next = token;
    last = token;
  }

  var eof = new Token();
  eof.kind = TokenKind.END_OF_FILE;
  eof.range = createRange(source, limit, limit);

  if (first == null) first = eof;
  else last.next = eof;
  last = eof;

  return first;
}
function tokenize22(source: Source, log: Log): Token {
  var first: Token = null;
  var last: Token = null;
  var contents = source.contents;
  var limit = String_length(contents);
  var i = 0;

  while (i < limit) {
    var start = i;
    var c = String_get(contents, i);
    i = i + 1;

    if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
      continue;
    }

    var kind = TokenKind.END_OF_FILE;

    // Identifier
    if (isAlpha(c)) {
      kind = TokenKind.IDENTIFIER;

      while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
        i = i + 1;
      }

      // Keywords
      var text = String_slice(contents, start, i);
      if (String_equalNew(text, "alignof")) kind = TokenKind.ALIGNOF;
      else if (String_equalNew(text, "as")) kind = TokenKind.AS;
      else if (String_equalNew(text, "break")) kind = TokenKind.BREAK;
      else if (String_equalNew(text, "class")) kind = TokenKind.CLASS;
      else if (String_equalNew(text, "const")) kind = TokenKind.CONST;
      else if (String_equalNew(text, "continue")) kind = TokenKind.CONTINUE;
      else if (String_equalNew(text, "declare")) kind = TokenKind.DECLARE;
      else if (String_equalNew(text, "else")) kind = TokenKind.ELSE;
      else if (String_equalNew(text, "enum")) kind = TokenKind.ENUM;
      else if (String_equalNew(text, "export")) kind = TokenKind.EXPORT;
      else if (String_equalNew(text, "extends")) kind = TokenKind.EXTENDS;
      else if (String_equalNew(text, "extern")) kind = TokenKind.EXTERN;
      else if (String_equalNew(text, "false")) kind = TokenKind.FALSE;
      else if (String_equalNew(text, "function")) kind = TokenKind.FUNCTION;
      else if (String_equalNew(text, "if")) kind = TokenKind.IF;
      else if (String_equalNew(text, "implements")) kind = TokenKind.IMPLEMENTS;
      else if (String_equalNew(text, "import")) kind = TokenKind.IMPORT;
      else if (String_equalNew(text, "interface")) kind = TokenKind.INTERFACE;
      else if (String_equalNew(text, "let")) kind = TokenKind.LET;
      else if (String_equalNew(text, "new")) kind = TokenKind.NEW;
      else if (String_equalNew(text, "null")) kind = TokenKind.NULL;
      else if (String_equalNew(text, "private")) kind = TokenKind.PRIVATE;
      else if (String_equalNew(text, "protected")) kind = TokenKind.PROTECTED;
      else if (String_equalNew(text, "public")) kind = TokenKind.PUBLIC;
      else if (String_equalNew(text, "return")) kind = TokenKind.RETURN;
      else if (String_equalNew(text, "sizeof")) kind = TokenKind.SIZEOF;
      else if (String_equalNew(text, "static")) kind = TokenKind.STATIC;
      else if (String_equalNew(text, "this")) kind = TokenKind.THIS;
      else if (String_equalNew(text, "true")) kind = TokenKind.TRUE;
      else if (String_equalNew(text, "unsafe")) kind = TokenKind.UNSAFE;
      else if (String_equalNew(text, "var")) kind = TokenKind.VAR;
      else if (String_equalNew(text, "while")) kind = TokenKind.WHILE;
    }

    // Integer
    else if (isNumber(c)) {
      kind = TokenKind.INT;

      if (i < limit) {
        var next = String_get(contents, i);
        var base = 10;

        // Handle binary, octal, and hexadecimal prefixes
        if (c == '0' && i + 1 < limit) {
          if (next == 'b' || next == 'B') base = 2;
          else if (next == 'o' || next == 'O') base = 8;
          else if (next == 'x' || next == 'X') base = 16;
          if (base != 10) {
            if (isDigit(String_get(contents, i + 1), base)) i = i + 2;
            else base = 10;
          }
        }

        // Scan the payload
        while (i < limit && isDigit(String_get(contents, i), base)) {
          i = i + 1;
        }

        // Extra letters after the end is an error
        if (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
          i = i + 1;

          while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
            i = i + 1;
          }

          log.error(createRange(source, start, i), String_appendNew(String_append(
            String_new("Invalid integer literal: '"),
            String_slice(contents, start, i)),
            "'"));
          return null;
        }
      }
    }

    // Character or string
    else if (c == '"' || c == '\'' || c == '`') {
      while (i < limit) {
        var next = String_get(contents, i);

        // Escape any character including newlines
        if (i + 1 < limit && next == '\\') {
          i = i + 2;
        }

        // Only allow newlines in template literals
        else if (next == '\n' && c != '`') {
          break;
        }

        // Handle a normal character
        else {
          i = i + 1;

          // End the string with a matching quote character
          if (next == c) {
            kind = c == '\'' ? TokenKind.CHARACTER : TokenKind.STRING;
            break;
          }
        }
      }

      // It's an error if we didn't find a matching quote character
      if (kind == TokenKind.END_OF_FILE) {
        log.error(createRange(source, start, i), String_new(
          c == '\'' ? "Unterminated character literal" :
          c == '`' ? "Unterminated template literal" :
          "Unterminated string literal"));
        return null;
      }
    }

    // Operators
    else if (c == '%') kind = TokenKind.REMAINDER;
    else if (c == '(') kind = TokenKind.LEFT_PARENTHESIS;
    else if (c == ')') kind = TokenKind.RIGHT_PARENTHESIS;
    else if (c == '*') kind = TokenKind.MULTIPLY;
    else if (c == ',') kind = TokenKind.COMMA;
    else if (c == '.') kind = TokenKind.DOT;
    else if (c == ':') kind = TokenKind.COLON;
    else if (c == ';') kind = TokenKind.SEMICOLON;
    else if (c == '?') kind = TokenKind.QUESTION_MARK;
    else if (c == '[') kind = TokenKind.LEFT_BRACKET;
    else if (c == ']') kind = TokenKind.RIGHT_BRACKET;
    else if (c == '^') kind = TokenKind.BITWISE_XOR;
    else if (c == '{') kind = TokenKind.LEFT_BRACE;
    else if (c == '}') kind = TokenKind.RIGHT_BRACE;
    else if (c == '~') kind = TokenKind.COMPLEMENT;

    // / or // or /*
    else if (c == '/') {
      kind = TokenKind.DIVIDE;

      // Single-line comments
      if (i < limit && String_get(contents, i) == '/') {
        i = i + 1;

        while (i < limit && String_get(contents, i) != '\n') {
          i = i + 1;
        }

        continue;
      }

      // Multi-line comments
      if (i < limit && String_get(contents, i) == '*') {
        i = i + 1;
        var foundEnd = false;

        while (i < limit) {
          var next = String_get(contents, i);

          if (next == '*' && i + 1 < limit && String_get(contents, i + 1) == '/') {
            foundEnd = true;
            i = i + 2;
            break;
          }

          i = i + 1;
        }

        if (!foundEnd) {
          log.error(createRange(source, start, start + 2), String_new("Unterminated multi-line comment"));
          return null;
        }

        continue;
      }
    }

    // ! or !=
    else if (c == '!') {
      kind = TokenKind.NOT;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.NOT_EQUAL;
        i = i + 1;

        // Recover from !==
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '!=' instead of '!=='"));
        }
      }
    }

    // = or ==
    else if (c == '=') {
      kind = TokenKind.ASSIGN;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.EQUAL;
        i = i + 1;

        // Recover from ===
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '==' instead of '==='"));
        }
      }
    }

    // + or ++
    else if (c == '+') {
      kind = TokenKind.PLUS;

      if (i < limit && String_get(contents, i) == '+') {
        kind = TokenKind.PLUS_PLUS;
        i = i + 1;
      }
    }

    // - or --
    else if (c == '-') {
      kind = TokenKind.MINUS;

      if (i < limit && String_get(contents, i) == '-') {
        kind = TokenKind.MINUS_MINUS;
        i = i + 1;
      }
    }

    // & or &&
    else if (c == '&') {
      kind = TokenKind.BITWISE_AND;

      if (i < limit && String_get(contents, i) == '&') {
        kind = TokenKind.LOGICAL_AND;
        i = i + 1;
      }
    }

    // | or ||
    else if (c == '|') {
      kind = TokenKind.BITWISE_OR;

      if (i < limit && String_get(contents, i) == '|') {
        kind = TokenKind.LOGICAL_OR;
        i = i + 1;
      }
    }

    // < or << or <=
    else if (c == '<') {
      kind = TokenKind.LESS_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '<') {
          kind = TokenKind.SHIFT_LEFT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.LESS_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    // > or >> or >=
    else if (c == '>') {
      kind = TokenKind.GREATER_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '>') {
          kind = TokenKind.SHIFT_RIGHT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.GREATER_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    var range = createRange(source, start, i);

    if (kind == TokenKind.END_OF_FILE) {
      log.error(range,
        String_appendNew(
          String_append(
            String_new("Syntax error: '"),
            String_slice(contents, start, start + 1)),
          "'"));
      return null;
    }

    var token = new Token();
    token.kind = kind;
    token.range = range;

    if (first == null) first = token;
    else last.next = token;
    last = token;
  }

  var eof = new Token();
  eof.kind = TokenKind.END_OF_FILE;
  eof.range = createRange(source, limit, limit);

  if (first == null) first = eof;
  else last.next = eof;
  last = eof;

  return first;
}

function tokenize32(source: Source, log: Log): Token {
  var first: Token = null;
  var last: Token = null;
  var contents = source.contents;
  var limit = String_length(contents);
  var i = 0;

  while (i < limit) {
    var start = i;
    var c = String_get(contents, i);
    i = i + 1;

    if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
      continue;
    }

    var kind = TokenKind.END_OF_FILE;

    // Identifier
    if (isAlpha(c)) {
      kind = TokenKind.IDENTIFIER;

      while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
        i = i + 1;
      }

      // Keywords
      var text = String_slice(contents, start, i);
      if (String_equalNew(text, "alignof")) kind = TokenKind.ALIGNOF;
      else if (String_equalNew(text, "as")) kind = TokenKind.AS;
      else if (String_equalNew(text, "break")) kind = TokenKind.BREAK;
      else if (String_equalNew(text, "class")) kind = TokenKind.CLASS;
      else if (String_equalNew(text, "const")) kind = TokenKind.CONST;
      else if (String_equalNew(text, "continue")) kind = TokenKind.CONTINUE;
      else if (String_equalNew(text, "declare")) kind = TokenKind.DECLARE;
      else if (String_equalNew(text, "else")) kind = TokenKind.ELSE;
      else if (String_equalNew(text, "enum")) kind = TokenKind.ENUM;
      else if (String_equalNew(text, "export")) kind = TokenKind.EXPORT;
      else if (String_equalNew(text, "extends")) kind = TokenKind.EXTENDS;
      else if (String_equalNew(text, "extern")) kind = TokenKind.EXTERN;
      else if (String_equalNew(text, "false")) kind = TokenKind.FALSE;
      else if (String_equalNew(text, "function")) kind = TokenKind.FUNCTION;
      else if (String_equalNew(text, "if")) kind = TokenKind.IF;
      else if (String_equalNew(text, "implements")) kind = TokenKind.IMPLEMENTS;
      else if (String_equalNew(text, "import")) kind = TokenKind.IMPORT;
      else if (String_equalNew(text, "interface")) kind = TokenKind.INTERFACE;
      else if (String_equalNew(text, "let")) kind = TokenKind.LET;
      else if (String_equalNew(text, "new")) kind = TokenKind.NEW;
      else if (String_equalNew(text, "null")) kind = TokenKind.NULL;
      else if (String_equalNew(text, "private")) kind = TokenKind.PRIVATE;
      else if (String_equalNew(text, "protected")) kind = TokenKind.PROTECTED;
      else if (String_equalNew(text, "public")) kind = TokenKind.PUBLIC;
      else if (String_equalNew(text, "return")) kind = TokenKind.RETURN;
      else if (String_equalNew(text, "sizeof")) kind = TokenKind.SIZEOF;
      else if (String_equalNew(text, "static")) kind = TokenKind.STATIC;
      else if (String_equalNew(text, "this")) kind = TokenKind.THIS;
      else if (String_equalNew(text, "true")) kind = TokenKind.TRUE;
      else if (String_equalNew(text, "unsafe")) kind = TokenKind.UNSAFE;
      else if (String_equalNew(text, "var")) kind = TokenKind.VAR;
      else if (String_equalNew(text, "while")) kind = TokenKind.WHILE;
    }

    // Integer
    else if (isNumber(c)) {
      kind = TokenKind.INT;

      if (i < limit) {
        var next = String_get(contents, i);
        var base = 10;

        // Handle binary, octal, and hexadecimal prefixes
        if (c == '0' && i + 1 < limit) {
          if (next == 'b' || next == 'B') base = 2;
          else if (next == 'o' || next == 'O') base = 8;
          else if (next == 'x' || next == 'X') base = 16;
          if (base != 10) {
            if (isDigit(String_get(contents, i + 1), base)) i = i + 2;
            else base = 10;
          }
        }

        // Scan the payload
        while (i < limit && isDigit(String_get(contents, i), base)) {
          i = i + 1;
        }

        // Extra letters after the end is an error
        if (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
          i = i + 1;

          while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
            i = i + 1;
          }

          log.error(createRange(source, start, i), String_appendNew(String_append(
            String_new("Invalid integer literal: '"),
            String_slice(contents, start, i)),
            "'"));
          return null;
        }
      }
    }

    // Character or string
    else if (c == '"' || c == '\'' || c == '`') {
      while (i < limit) {
        var next = String_get(contents, i);

        // Escape any character including newlines
        if (i + 1 < limit && next == '\\') {
          i = i + 2;
        }

        // Only allow newlines in template literals
        else if (next == '\n' && c != '`') {
          break;
        }

        // Handle a normal character
        else {
          i = i + 1;

          // End the string with a matching quote character
          if (next == c) {
            kind = c == '\'' ? TokenKind.CHARACTER : TokenKind.STRING;
            break;
          }
        }
      }

      // It's an error if we didn't find a matching quote character
      if (kind == TokenKind.END_OF_FILE) {
        log.error(createRange(source, start, i), String_new(
          c == '\'' ? "Unterminated character literal" :
          c == '`' ? "Unterminated template literal" :
          "Unterminated string literal"));
        return null;
      }
    }

    // Operators
    else if (c == '%') kind = TokenKind.REMAINDER;
    else if (c == '(') kind = TokenKind.LEFT_PARENTHESIS;
    else if (c == ')') kind = TokenKind.RIGHT_PARENTHESIS;
    else if (c == '*') kind = TokenKind.MULTIPLY;
    else if (c == ',') kind = TokenKind.COMMA;
    else if (c == '.') kind = TokenKind.DOT;
    else if (c == ':') kind = TokenKind.COLON;
    else if (c == ';') kind = TokenKind.SEMICOLON;
    else if (c == '?') kind = TokenKind.QUESTION_MARK;
    else if (c == '[') kind = TokenKind.LEFT_BRACKET;
    else if (c == ']') kind = TokenKind.RIGHT_BRACKET;
    else if (c == '^') kind = TokenKind.BITWISE_XOR;
    else if (c == '{') kind = TokenKind.LEFT_BRACE;
    else if (c == '}') kind = TokenKind.RIGHT_BRACE;
    else if (c == '~') kind = TokenKind.COMPLEMENT;

    // / or // or /*
    else if (c == '/') {
      kind = TokenKind.DIVIDE;

      // Single-line comments
      if (i < limit && String_get(contents, i) == '/') {
        i = i + 1;

        while (i < limit && String_get(contents, i) != '\n') {
          i = i + 1;
        }

        continue;
      }

      // Multi-line comments
      if (i < limit && String_get(contents, i) == '*') {
        i = i + 1;
        var foundEnd = false;

        while (i < limit) {
          var next = String_get(contents, i);

          if (next == '*' && i + 1 < limit && String_get(contents, i + 1) == '/') {
            foundEnd = true;
            i = i + 2;
            break;
          }

          i = i + 1;
        }

        if (!foundEnd) {
          log.error(createRange(source, start, start + 2), String_new("Unterminated multi-line comment"));
          return null;
        }

        continue;
      }
    }

    // ! or !=
    else if (c == '!') {
      kind = TokenKind.NOT;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.NOT_EQUAL;
        i = i + 1;

        // Recover from !==
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '!=' instead of '!=='"));
        }
      }
    }

    // = or ==
    else if (c == '=') {
      kind = TokenKind.ASSIGN;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.EQUAL;
        i = i + 1;

        // Recover from ===
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '==' instead of '==='"));
        }
      }
    }

    // + or ++
    else if (c == '+') {
      kind = TokenKind.PLUS;

      if (i < limit && String_get(contents, i) == '+') {
        kind = TokenKind.PLUS_PLUS;
        i = i + 1;
      }
    }

    // - or --
    else if (c == '-') {
      kind = TokenKind.MINUS;

      if (i < limit && String_get(contents, i) == '-') {
        kind = TokenKind.MINUS_MINUS;
        i = i + 1;
      }
    }

    // & or &&
    else if (c == '&') {
      kind = TokenKind.BITWISE_AND;

      if (i < limit && String_get(contents, i) == '&') {
        kind = TokenKind.LOGICAL_AND;
        i = i + 1;
      }
    }

    // | or ||
    else if (c == '|') {
      kind = TokenKind.BITWISE_OR;

      if (i < limit && String_get(contents, i) == '|') {
        kind = TokenKind.LOGICAL_OR;
        i = i + 1;
      }
    }

    // < or << or <=
    else if (c == '<') {
      kind = TokenKind.LESS_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '<') {
          kind = TokenKind.SHIFT_LEFT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.LESS_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    // > or >> or >=
    else if (c == '>') {
      kind = TokenKind.GREATER_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '>') {
          kind = TokenKind.SHIFT_RIGHT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.GREATER_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    var range = createRange(source, start, i);

    if (kind == TokenKind.END_OF_FILE) {
      log.error(range,
        String_appendNew(
          String_append(
            String_new("Syntax error: '"),
            String_slice(contents, start, start + 1)),
          "'"));
      return null;
    }

    var token = new Token();
    token.kind = kind;
    token.range = range;

    if (first == null) first = token;
    else last.next = token;
    last = token;
  }

  var eof = new Token();
  eof.kind = TokenKind.END_OF_FILE;
  eof.range = createRange(source, limit, limit);

  if (first == null) first = eof;
  else last.next = eof;
  last = eof;

  return first;
}

function tokenize42(source: Source, log: Log): Token {
  var first: Token = null;
  var last: Token = null;
  var contents = source.contents;
  var limit = String_length(contents);
  var i = 0;

  while (i < limit) {
    var start = i;
    var c = String_get(contents, i);
    i = i + 1;

    if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
      continue;
    }

    var kind = TokenKind.END_OF_FILE;

    // Identifier
    if (isAlpha(c)) {
      kind = TokenKind.IDENTIFIER;

      while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
        i = i + 1;
      }

      // Keywords
      var text = String_slice(contents, start, i);
      if (String_equalNew(text, "alignof")) kind = TokenKind.ALIGNOF;
      else if (String_equalNew(text, "as")) kind = TokenKind.AS;
      else if (String_equalNew(text, "break")) kind = TokenKind.BREAK;
      else if (String_equalNew(text, "class")) kind = TokenKind.CLASS;
      else if (String_equalNew(text, "const")) kind = TokenKind.CONST;
      else if (String_equalNew(text, "continue")) kind = TokenKind.CONTINUE;
      else if (String_equalNew(text, "declare")) kind = TokenKind.DECLARE;
      else if (String_equalNew(text, "else")) kind = TokenKind.ELSE;
      else if (String_equalNew(text, "enum")) kind = TokenKind.ENUM;
      else if (String_equalNew(text, "export")) kind = TokenKind.EXPORT;
      else if (String_equalNew(text, "extends")) kind = TokenKind.EXTENDS;
      else if (String_equalNew(text, "extern")) kind = TokenKind.EXTERN;
      else if (String_equalNew(text, "false")) kind = TokenKind.FALSE;
      else if (String_equalNew(text, "function")) kind = TokenKind.FUNCTION;
      else if (String_equalNew(text, "if")) kind = TokenKind.IF;
      else if (String_equalNew(text, "implements")) kind = TokenKind.IMPLEMENTS;
      else if (String_equalNew(text, "import")) kind = TokenKind.IMPORT;
      else if (String_equalNew(text, "interface")) kind = TokenKind.INTERFACE;
      else if (String_equalNew(text, "let")) kind = TokenKind.LET;
      else if (String_equalNew(text, "new")) kind = TokenKind.NEW;
      else if (String_equalNew(text, "null")) kind = TokenKind.NULL;
      else if (String_equalNew(text, "private")) kind = TokenKind.PRIVATE;
      else if (String_equalNew(text, "protected")) kind = TokenKind.PROTECTED;
      else if (String_equalNew(text, "public")) kind = TokenKind.PUBLIC;
      else if (String_equalNew(text, "return")) kind = TokenKind.RETURN;
      else if (String_equalNew(text, "sizeof")) kind = TokenKind.SIZEOF;
      else if (String_equalNew(text, "static")) kind = TokenKind.STATIC;
      else if (String_equalNew(text, "this")) kind = TokenKind.THIS;
      else if (String_equalNew(text, "true")) kind = TokenKind.TRUE;
      else if (String_equalNew(text, "unsafe")) kind = TokenKind.UNSAFE;
      else if (String_equalNew(text, "var")) kind = TokenKind.VAR;
      else if (String_equalNew(text, "while")) kind = TokenKind.WHILE;
    }

    // Integer
    else if (isNumber(c)) {
      kind = TokenKind.INT;

      if (i < limit) {
        var next = String_get(contents, i);
        var base = 10;

        // Handle binary, octal, and hexadecimal prefixes
        if (c == '0' && i + 1 < limit) {
          if (next == 'b' || next == 'B') base = 2;
          else if (next == 'o' || next == 'O') base = 8;
          else if (next == 'x' || next == 'X') base = 16;
          if (base != 10) {
            if (isDigit(String_get(contents, i + 1), base)) i = i + 2;
            else base = 10;
          }
        }

        // Scan the payload
        while (i < limit && isDigit(String_get(contents, i), base)) {
          i = i + 1;
        }

        // Extra letters after the end is an error
        if (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
          i = i + 1;

          while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
            i = i + 1;
          }

          log.error(createRange(source, start, i), String_appendNew(String_append(
            String_new("Invalid integer literal: '"),
            String_slice(contents, start, i)),
            "'"));
          return null;
        }
      }
    }

    // Character or string
    else if (c == '"' || c == '\'' || c == '`') {
      while (i < limit) {
        var next = String_get(contents, i);

        // Escape any character including newlines
        if (i + 1 < limit && next == '\\') {
          i = i + 2;
        }

        // Only allow newlines in template literals
        else if (next == '\n' && c != '`') {
          break;
        }

        // Handle a normal character
        else {
          i = i + 1;

          // End the string with a matching quote character
          if (next == c) {
            kind = c == '\'' ? TokenKind.CHARACTER : TokenKind.STRING;
            break;
          }
        }
      }

      // It's an error if we didn't find a matching quote character
      if (kind == TokenKind.END_OF_FILE) {
        log.error(createRange(source, start, i), String_new(
          c == '\'' ? "Unterminated character literal" :
          c == '`' ? "Unterminated template literal" :
          "Unterminated string literal"));
        return null;
      }
    }

    // Operators
    else if (c == '%') kind = TokenKind.REMAINDER;
    else if (c == '(') kind = TokenKind.LEFT_PARENTHESIS;
    else if (c == ')') kind = TokenKind.RIGHT_PARENTHESIS;
    else if (c == '*') kind = TokenKind.MULTIPLY;
    else if (c == ',') kind = TokenKind.COMMA;
    else if (c == '.') kind = TokenKind.DOT;
    else if (c == ':') kind = TokenKind.COLON;
    else if (c == ';') kind = TokenKind.SEMICOLON;
    else if (c == '?') kind = TokenKind.QUESTION_MARK;
    else if (c == '[') kind = TokenKind.LEFT_BRACKET;
    else if (c == ']') kind = TokenKind.RIGHT_BRACKET;
    else if (c == '^') kind = TokenKind.BITWISE_XOR;
    else if (c == '{') kind = TokenKind.LEFT_BRACE;
    else if (c == '}') kind = TokenKind.RIGHT_BRACE;
    else if (c == '~') kind = TokenKind.COMPLEMENT;

    // / or // or /*
    else if (c == '/') {
      kind = TokenKind.DIVIDE;

      // Single-line comments
      if (i < limit && String_get(contents, i) == '/') {
        i = i + 1;

        while (i < limit && String_get(contents, i) != '\n') {
          i = i + 1;
        }

        continue;
      }

      // Multi-line comments
      if (i < limit && String_get(contents, i) == '*') {
        i = i + 1;
        var foundEnd = false;

        while (i < limit) {
          var next = String_get(contents, i);

          if (next == '*' && i + 1 < limit && String_get(contents, i + 1) == '/') {
            foundEnd = true;
            i = i + 2;
            break;
          }

          i = i + 1;
        }

        if (!foundEnd) {
          log.error(createRange(source, start, start + 2), String_new("Unterminated multi-line comment"));
          return null;
        }

        continue;
      }
    }

    // ! or !=
    else if (c == '!') {
      kind = TokenKind.NOT;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.NOT_EQUAL;
        i = i + 1;

        // Recover from !==
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '!=' instead of '!=='"));
        }
      }
    }

    // = or ==
    else if (c == '=') {
      kind = TokenKind.ASSIGN;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.EQUAL;
        i = i + 1;

        // Recover from ===
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '==' instead of '==='"));
        }
      }
    }

    // + or ++
    else if (c == '+') {
      kind = TokenKind.PLUS;

      if (i < limit && String_get(contents, i) == '+') {
        kind = TokenKind.PLUS_PLUS;
        i = i + 1;
      }
    }

    // - or --
    else if (c == '-') {
      kind = TokenKind.MINUS;

      if (i < limit && String_get(contents, i) == '-') {
        kind = TokenKind.MINUS_MINUS;
        i = i + 1;
      }
    }

    // & or &&
    else if (c == '&') {
      kind = TokenKind.BITWISE_AND;

      if (i < limit && String_get(contents, i) == '&') {
        kind = TokenKind.LOGICAL_AND;
        i = i + 1;
      }
    }

    // | or ||
    else if (c == '|') {
      kind = TokenKind.BITWISE_OR;

      if (i < limit && String_get(contents, i) == '|') {
        kind = TokenKind.LOGICAL_OR;
        i = i + 1;
      }
    }

    // < or << or <=
    else if (c == '<') {
      kind = TokenKind.LESS_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '<') {
          kind = TokenKind.SHIFT_LEFT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.LESS_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    // > or >> or >=
    else if (c == '>') {
      kind = TokenKind.GREATER_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '>') {
          kind = TokenKind.SHIFT_RIGHT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.GREATER_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    var range = createRange(source, start, i);

    if (kind == TokenKind.END_OF_FILE) {
      log.error(range,
        String_appendNew(
          String_append(
            String_new("Syntax error: '"),
            String_slice(contents, start, start + 1)),
          "'"));
      return null;
    }

    var token = new Token();
    token.kind = kind;
    token.range = range;

    if (first == null) first = token;
    else last.next = token;
    last = token;
  }

  var eof = new Token();
  eof.kind = TokenKind.END_OF_FILE;
  eof.range = createRange(source, limit, limit);

  if (first == null) first = eof;
  else last.next = eof;
  last = eof;

  return first;
}

function tokenize23(source: Source, log: Log): Token {
  var first: Token = null;
  var last: Token = null;
  var contents = source.contents;
  var limit = String_length(contents);
  var i = 0;

  while (i < limit) {
    var start = i;
    var c = String_get(contents, i);
    i = i + 1;

    if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
      continue;
    }

    var kind = TokenKind.END_OF_FILE;

    // Identifier
    if (isAlpha(c)) {
      kind = TokenKind.IDENTIFIER;

      while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
        i = i + 1;
      }

      // Keywords
      var text = String_slice(contents, start, i);
      if (String_equalNew(text, "alignof")) kind = TokenKind.ALIGNOF;
      else if (String_equalNew(text, "as")) kind = TokenKind.AS;
      else if (String_equalNew(text, "break")) kind = TokenKind.BREAK;
      else if (String_equalNew(text, "class")) kind = TokenKind.CLASS;
      else if (String_equalNew(text, "const")) kind = TokenKind.CONST;
      else if (String_equalNew(text, "continue")) kind = TokenKind.CONTINUE;
      else if (String_equalNew(text, "declare")) kind = TokenKind.DECLARE;
      else if (String_equalNew(text, "else")) kind = TokenKind.ELSE;
      else if (String_equalNew(text, "enum")) kind = TokenKind.ENUM;
      else if (String_equalNew(text, "export")) kind = TokenKind.EXPORT;
      else if (String_equalNew(text, "extends")) kind = TokenKind.EXTENDS;
      else if (String_equalNew(text, "extern")) kind = TokenKind.EXTERN;
      else if (String_equalNew(text, "false")) kind = TokenKind.FALSE;
      else if (String_equalNew(text, "function")) kind = TokenKind.FUNCTION;
      else if (String_equalNew(text, "if")) kind = TokenKind.IF;
      else if (String_equalNew(text, "implements")) kind = TokenKind.IMPLEMENTS;
      else if (String_equalNew(text, "import")) kind = TokenKind.IMPORT;
      else if (String_equalNew(text, "interface")) kind = TokenKind.INTERFACE;
      else if (String_equalNew(text, "let")) kind = TokenKind.LET;
      else if (String_equalNew(text, "new")) kind = TokenKind.NEW;
      else if (String_equalNew(text, "null")) kind = TokenKind.NULL;
      else if (String_equalNew(text, "private")) kind = TokenKind.PRIVATE;
      else if (String_equalNew(text, "protected")) kind = TokenKind.PROTECTED;
      else if (String_equalNew(text, "public")) kind = TokenKind.PUBLIC;
      else if (String_equalNew(text, "return")) kind = TokenKind.RETURN;
      else if (String_equalNew(text, "sizeof")) kind = TokenKind.SIZEOF;
      else if (String_equalNew(text, "static")) kind = TokenKind.STATIC;
      else if (String_equalNew(text, "this")) kind = TokenKind.THIS;
      else if (String_equalNew(text, "true")) kind = TokenKind.TRUE;
      else if (String_equalNew(text, "unsafe")) kind = TokenKind.UNSAFE;
      else if (String_equalNew(text, "var")) kind = TokenKind.VAR;
      else if (String_equalNew(text, "while")) kind = TokenKind.WHILE;
    }

    // Integer
    else if (isNumber(c)) {
      kind = TokenKind.INT;

      if (i < limit) {
        var next = String_get(contents, i);
        var base = 10;

        // Handle binary, octal, and hexadecimal prefixes
        if (c == '0' && i + 1 < limit) {
          if (next == 'b' || next == 'B') base = 2;
          else if (next == 'o' || next == 'O') base = 8;
          else if (next == 'x' || next == 'X') base = 16;
          if (base != 10) {
            if (isDigit(String_get(contents, i + 1), base)) i = i + 2;
            else base = 10;
          }
        }

        // Scan the payload
        while (i < limit && isDigit(String_get(contents, i), base)) {
          i = i + 1;
        }

        // Extra letters after the end is an error
        if (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
          i = i + 1;

          while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
            i = i + 1;
          }

          log.error(createRange(source, start, i), String_appendNew(String_append(
            String_new("Invalid integer literal: '"),
            String_slice(contents, start, i)),
            "'"));
          return null;
        }
      }
    }

    // Character or string
    else if (c == '"' || c == '\'' || c == '`') {
      while (i < limit) {
        var next = String_get(contents, i);

        // Escape any character including newlines
        if (i + 1 < limit && next == '\\') {
          i = i + 2;
        }

        // Only allow newlines in template literals
        else if (next == '\n' && c != '`') {
          break;
        }

        // Handle a normal character
        else {
          i = i + 1;

          // End the string with a matching quote character
          if (next == c) {
            kind = c == '\'' ? TokenKind.CHARACTER : TokenKind.STRING;
            break;
          }
        }
      }

      // It's an error if we didn't find a matching quote character
      if (kind == TokenKind.END_OF_FILE) {
        log.error(createRange(source, start, i), String_new(
          c == '\'' ? "Unterminated character literal" :
          c == '`' ? "Unterminated template literal" :
          "Unterminated string literal"));
        return null;
      }
    }

    // Operators
    else if (c == '%') kind = TokenKind.REMAINDER;
    else if (c == '(') kind = TokenKind.LEFT_PARENTHESIS;
    else if (c == ')') kind = TokenKind.RIGHT_PARENTHESIS;
    else if (c == '*') kind = TokenKind.MULTIPLY;
    else if (c == ',') kind = TokenKind.COMMA;
    else if (c == '.') kind = TokenKind.DOT;
    else if (c == ':') kind = TokenKind.COLON;
    else if (c == ';') kind = TokenKind.SEMICOLON;
    else if (c == '?') kind = TokenKind.QUESTION_MARK;
    else if (c == '[') kind = TokenKind.LEFT_BRACKET;
    else if (c == ']') kind = TokenKind.RIGHT_BRACKET;
    else if (c == '^') kind = TokenKind.BITWISE_XOR;
    else if (c == '{') kind = TokenKind.LEFT_BRACE;
    else if (c == '}') kind = TokenKind.RIGHT_BRACE;
    else if (c == '~') kind = TokenKind.COMPLEMENT;

    // / or // or /*
    else if (c == '/') {
      kind = TokenKind.DIVIDE;

      // Single-line comments
      if (i < limit && String_get(contents, i) == '/') {
        i = i + 1;

        while (i < limit && String_get(contents, i) != '\n') {
          i = i + 1;
        }

        continue;
      }

      // Multi-line comments
      if (i < limit && String_get(contents, i) == '*') {
        i = i + 1;
        var foundEnd = false;

        while (i < limit) {
          var next = String_get(contents, i);

          if (next == '*' && i + 1 < limit && String_get(contents, i + 1) == '/') {
            foundEnd = true;
            i = i + 2;
            break;
          }

          i = i + 1;
        }

        if (!foundEnd) {
          log.error(createRange(source, start, start + 2), String_new("Unterminated multi-line comment"));
          return null;
        }

        continue;
      }
    }

    // ! or !=
    else if (c == '!') {
      kind = TokenKind.NOT;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.NOT_EQUAL;
        i = i + 1;

        // Recover from !==
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '!=' instead of '!=='"));
        }
      }
    }

    // = or ==
    else if (c == '=') {
      kind = TokenKind.ASSIGN;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.EQUAL;
        i = i + 1;

        // Recover from ===
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '==' instead of '==='"));
        }
      }
    }

    // + or ++
    else if (c == '+') {
      kind = TokenKind.PLUS;

      if (i < limit && String_get(contents, i) == '+') {
        kind = TokenKind.PLUS_PLUS;
        i = i + 1;
      }
    }

    // - or --
    else if (c == '-') {
      kind = TokenKind.MINUS;

      if (i < limit && String_get(contents, i) == '-') {
        kind = TokenKind.MINUS_MINUS;
        i = i + 1;
      }
    }

    // & or &&
    else if (c == '&') {
      kind = TokenKind.BITWISE_AND;

      if (i < limit && String_get(contents, i) == '&') {
        kind = TokenKind.LOGICAL_AND;
        i = i + 1;
      }
    }

    // | or ||
    else if (c == '|') {
      kind = TokenKind.BITWISE_OR;

      if (i < limit && String_get(contents, i) == '|') {
        kind = TokenKind.LOGICAL_OR;
        i = i + 1;
      }
    }

    // < or << or <=
    else if (c == '<') {
      kind = TokenKind.LESS_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '<') {
          kind = TokenKind.SHIFT_LEFT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.LESS_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    // > or >> or >=
    else if (c == '>') {
      kind = TokenKind.GREATER_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '>') {
          kind = TokenKind.SHIFT_RIGHT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.GREATER_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    var range = createRange(source, start, i);

    if (kind == TokenKind.END_OF_FILE) {
      log.error(range,
        String_appendNew(
          String_append(
            String_new("Syntax error: '"),
            String_slice(contents, start, start + 1)),
          "'"));
      return null;
    }

    var token = new Token();
    token.kind = kind;
    token.range = range;

    if (first == null) first = token;
    else last.next = token;
    last = token;
  }

  var eof = new Token();
  eof.kind = TokenKind.END_OF_FILE;
  eof.range = createRange(source, limit, limit);

  if (first == null) first = eof;
  else last.next = eof;
  last = eof;

  return first;
}

function tokenize33(source: Source, log: Log): Token {
  var first: Token = null;
  var last: Token = null;
  var contents = source.contents;
  var limit = String_length(contents);
  var i = 0;

  while (i < limit) {
    var start = i;
    var c = String_get(contents, i);
    i = i + 1;

    if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
      continue;
    }

    var kind = TokenKind.END_OF_FILE;

    // Identifier
    if (isAlpha(c)) {
      kind = TokenKind.IDENTIFIER;

      while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
        i = i + 1;
      }

      // Keywords
      var text = String_slice(contents, start, i);
      if (String_equalNew(text, "alignof")) kind = TokenKind.ALIGNOF;
      else if (String_equalNew(text, "as")) kind = TokenKind.AS;
      else if (String_equalNew(text, "break")) kind = TokenKind.BREAK;
      else if (String_equalNew(text, "class")) kind = TokenKind.CLASS;
      else if (String_equalNew(text, "const")) kind = TokenKind.CONST;
      else if (String_equalNew(text, "continue")) kind = TokenKind.CONTINUE;
      else if (String_equalNew(text, "declare")) kind = TokenKind.DECLARE;
      else if (String_equalNew(text, "else")) kind = TokenKind.ELSE;
      else if (String_equalNew(text, "enum")) kind = TokenKind.ENUM;
      else if (String_equalNew(text, "export")) kind = TokenKind.EXPORT;
      else if (String_equalNew(text, "extends")) kind = TokenKind.EXTENDS;
      else if (String_equalNew(text, "extern")) kind = TokenKind.EXTERN;
      else if (String_equalNew(text, "false")) kind = TokenKind.FALSE;
      else if (String_equalNew(text, "function")) kind = TokenKind.FUNCTION;
      else if (String_equalNew(text, "if")) kind = TokenKind.IF;
      else if (String_equalNew(text, "implements")) kind = TokenKind.IMPLEMENTS;
      else if (String_equalNew(text, "import")) kind = TokenKind.IMPORT;
      else if (String_equalNew(text, "interface")) kind = TokenKind.INTERFACE;
      else if (String_equalNew(text, "let")) kind = TokenKind.LET;
      else if (String_equalNew(text, "new")) kind = TokenKind.NEW;
      else if (String_equalNew(text, "null")) kind = TokenKind.NULL;
      else if (String_equalNew(text, "private")) kind = TokenKind.PRIVATE;
      else if (String_equalNew(text, "protected")) kind = TokenKind.PROTECTED;
      else if (String_equalNew(text, "public")) kind = TokenKind.PUBLIC;
      else if (String_equalNew(text, "return")) kind = TokenKind.RETURN;
      else if (String_equalNew(text, "sizeof")) kind = TokenKind.SIZEOF;
      else if (String_equalNew(text, "static")) kind = TokenKind.STATIC;
      else if (String_equalNew(text, "this")) kind = TokenKind.THIS;
      else if (String_equalNew(text, "true")) kind = TokenKind.TRUE;
      else if (String_equalNew(text, "unsafe")) kind = TokenKind.UNSAFE;
      else if (String_equalNew(text, "var")) kind = TokenKind.VAR;
      else if (String_equalNew(text, "while")) kind = TokenKind.WHILE;
    }

    // Integer
    else if (isNumber(c)) {
      kind = TokenKind.INT;

      if (i < limit) {
        var next = String_get(contents, i);
        var base = 10;

        // Handle binary, octal, and hexadecimal prefixes
        if (c == '0' && i + 1 < limit) {
          if (next == 'b' || next == 'B') base = 2;
          else if (next == 'o' || next == 'O') base = 8;
          else if (next == 'x' || next == 'X') base = 16;
          if (base != 10) {
            if (isDigit(String_get(contents, i + 1), base)) i = i + 2;
            else base = 10;
          }
        }

        // Scan the payload
        while (i < limit && isDigit(String_get(contents, i), base)) {
          i = i + 1;
        }

        // Extra letters after the end is an error
        if (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
          i = i + 1;

          while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
            i = i + 1;
          }

          log.error(createRange(source, start, i), String_appendNew(String_append(
            String_new("Invalid integer literal: '"),
            String_slice(contents, start, i)),
            "'"));
          return null;
        }
      }
    }

    // Character or string
    else if (c == '"' || c == '\'' || c == '`') {
      while (i < limit) {
        var next = String_get(contents, i);

        // Escape any character including newlines
        if (i + 1 < limit && next == '\\') {
          i = i + 2;
        }

        // Only allow newlines in template literals
        else if (next == '\n' && c != '`') {
          break;
        }

        // Handle a normal character
        else {
          i = i + 1;

          // End the string with a matching quote character
          if (next == c) {
            kind = c == '\'' ? TokenKind.CHARACTER : TokenKind.STRING;
            break;
          }
        }
      }

      // It's an error if we didn't find a matching quote character
      if (kind == TokenKind.END_OF_FILE) {
        log.error(createRange(source, start, i), String_new(
          c == '\'' ? "Unterminated character literal" :
          c == '`' ? "Unterminated template literal" :
          "Unterminated string literal"));
        return null;
      }
    }

    // Operators
    else if (c == '%') kind = TokenKind.REMAINDER;
    else if (c == '(') kind = TokenKind.LEFT_PARENTHESIS;
    else if (c == ')') kind = TokenKind.RIGHT_PARENTHESIS;
    else if (c == '*') kind = TokenKind.MULTIPLY;
    else if (c == ',') kind = TokenKind.COMMA;
    else if (c == '.') kind = TokenKind.DOT;
    else if (c == ':') kind = TokenKind.COLON;
    else if (c == ';') kind = TokenKind.SEMICOLON;
    else if (c == '?') kind = TokenKind.QUESTION_MARK;
    else if (c == '[') kind = TokenKind.LEFT_BRACKET;
    else if (c == ']') kind = TokenKind.RIGHT_BRACKET;
    else if (c == '^') kind = TokenKind.BITWISE_XOR;
    else if (c == '{') kind = TokenKind.LEFT_BRACE;
    else if (c == '}') kind = TokenKind.RIGHT_BRACE;
    else if (c == '~') kind = TokenKind.COMPLEMENT;

    // / or // or /*
    else if (c == '/') {
      kind = TokenKind.DIVIDE;

      // Single-line comments
      if (i < limit && String_get(contents, i) == '/') {
        i = i + 1;

        while (i < limit && String_get(contents, i) != '\n') {
          i = i + 1;
        }

        continue;
      }

      // Multi-line comments
      if (i < limit && String_get(contents, i) == '*') {
        i = i + 1;
        var foundEnd = false;

        while (i < limit) {
          var next = String_get(contents, i);

          if (next == '*' && i + 1 < limit && String_get(contents, i + 1) == '/') {
            foundEnd = true;
            i = i + 2;
            break;
          }

          i = i + 1;
        }

        if (!foundEnd) {
          log.error(createRange(source, start, start + 2), String_new("Unterminated multi-line comment"));
          return null;
        }

        continue;
      }
    }

    // ! or !=
    else if (c == '!') {
      kind = TokenKind.NOT;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.NOT_EQUAL;
        i = i + 1;

        // Recover from !==
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '!=' instead of '!=='"));
        }
      }
    }

    // = or ==
    else if (c == '=') {
      kind = TokenKind.ASSIGN;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.EQUAL;
        i = i + 1;

        // Recover from ===
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '==' instead of '==='"));
        }
      }
    }

    // + or ++
    else if (c == '+') {
      kind = TokenKind.PLUS;

      if (i < limit && String_get(contents, i) == '+') {
        kind = TokenKind.PLUS_PLUS;
        i = i + 1;
      }
    }

    // - or --
    else if (c == '-') {
      kind = TokenKind.MINUS;

      if (i < limit && String_get(contents, i) == '-') {
        kind = TokenKind.MINUS_MINUS;
        i = i + 1;
      }
    }

    // & or &&
    else if (c == '&') {
      kind = TokenKind.BITWISE_AND;

      if (i < limit && String_get(contents, i) == '&') {
        kind = TokenKind.LOGICAL_AND;
        i = i + 1;
      }
    }

    // | or ||
    else if (c == '|') {
      kind = TokenKind.BITWISE_OR;

      if (i < limit && String_get(contents, i) == '|') {
        kind = TokenKind.LOGICAL_OR;
        i = i + 1;
      }
    }

    // < or << or <=
    else if (c == '<') {
      kind = TokenKind.LESS_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '<') {
          kind = TokenKind.SHIFT_LEFT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.LESS_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    // > or >> or >=
    else if (c == '>') {
      kind = TokenKind.GREATER_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '>') {
          kind = TokenKind.SHIFT_RIGHT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.GREATER_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    var range = createRange(source, start, i);

    if (kind == TokenKind.END_OF_FILE) {
      log.error(range,
        String_appendNew(
          String_append(
            String_new("Syntax error: '"),
            String_slice(contents, start, start + 1)),
          "'"));
      return null;
    }

    var token = new Token();
    token.kind = kind;
    token.range = range;

    if (first == null) first = token;
    else last.next = token;
    last = token;
  }

  var eof = new Token();
  eof.kind = TokenKind.END_OF_FILE;
  eof.range = createRange(source, limit, limit);

  if (first == null) first = eof;
  else last.next = eof;
  last = eof;

  return first;
}

function tokenize43(source: Source, log: Log): Token {
  var first: Token = null;
  var last: Token = null;
  var contents = source.contents;
  var limit = String_length(contents);
  var i = 0;

  while (i < limit) {
    var start = i;
    var c = String_get(contents, i);
    i = i + 1;

    if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
      continue;
    }

    var kind = TokenKind.END_OF_FILE;

    // Identifier
    if (isAlpha(c)) {
      kind = TokenKind.IDENTIFIER;

      while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
        i = i + 1;
      }

      // Keywords
      var text = String_slice(contents, start, i);
      if (String_equalNew(text, "alignof")) kind = TokenKind.ALIGNOF;
      else if (String_equalNew(text, "as")) kind = TokenKind.AS;
      else if (String_equalNew(text, "break")) kind = TokenKind.BREAK;
      else if (String_equalNew(text, "class")) kind = TokenKind.CLASS;
      else if (String_equalNew(text, "const")) kind = TokenKind.CONST;
      else if (String_equalNew(text, "continue")) kind = TokenKind.CONTINUE;
      else if (String_equalNew(text, "declare")) kind = TokenKind.DECLARE;
      else if (String_equalNew(text, "else")) kind = TokenKind.ELSE;
      else if (String_equalNew(text, "enum")) kind = TokenKind.ENUM;
      else if (String_equalNew(text, "export")) kind = TokenKind.EXPORT;
      else if (String_equalNew(text, "extends")) kind = TokenKind.EXTENDS;
      else if (String_equalNew(text, "extern")) kind = TokenKind.EXTERN;
      else if (String_equalNew(text, "false")) kind = TokenKind.FALSE;
      else if (String_equalNew(text, "function")) kind = TokenKind.FUNCTION;
      else if (String_equalNew(text, "if")) kind = TokenKind.IF;
      else if (String_equalNew(text, "implements")) kind = TokenKind.IMPLEMENTS;
      else if (String_equalNew(text, "import")) kind = TokenKind.IMPORT;
      else if (String_equalNew(text, "interface")) kind = TokenKind.INTERFACE;
      else if (String_equalNew(text, "let")) kind = TokenKind.LET;
      else if (String_equalNew(text, "new")) kind = TokenKind.NEW;
      else if (String_equalNew(text, "null")) kind = TokenKind.NULL;
      else if (String_equalNew(text, "private")) kind = TokenKind.PRIVATE;
      else if (String_equalNew(text, "protected")) kind = TokenKind.PROTECTED;
      else if (String_equalNew(text, "public")) kind = TokenKind.PUBLIC;
      else if (String_equalNew(text, "return")) kind = TokenKind.RETURN;
      else if (String_equalNew(text, "sizeof")) kind = TokenKind.SIZEOF;
      else if (String_equalNew(text, "static")) kind = TokenKind.STATIC;
      else if (String_equalNew(text, "this")) kind = TokenKind.THIS;
      else if (String_equalNew(text, "true")) kind = TokenKind.TRUE;
      else if (String_equalNew(text, "unsafe")) kind = TokenKind.UNSAFE;
      else if (String_equalNew(text, "var")) kind = TokenKind.VAR;
      else if (String_equalNew(text, "while")) kind = TokenKind.WHILE;
    }

    // Integer
    else if (isNumber(c)) {
      kind = TokenKind.INT;

      if (i < limit) {
        var next = String_get(contents, i);
        var base = 10;

        // Handle binary, octal, and hexadecimal prefixes
        if (c == '0' && i + 1 < limit) {
          if (next == 'b' || next == 'B') base = 2;
          else if (next == 'o' || next == 'O') base = 8;
          else if (next == 'x' || next == 'X') base = 16;
          if (base != 10) {
            if (isDigit(String_get(contents, i + 1), base)) i = i + 2;
            else base = 10;
          }
        }

        // Scan the payload
        while (i < limit && isDigit(String_get(contents, i), base)) {
          i = i + 1;
        }

        // Extra letters after the end is an error
        if (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
          i = i + 1;

          while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
            i = i + 1;
          }

          log.error(createRange(source, start, i), String_appendNew(String_append(
            String_new("Invalid integer literal: '"),
            String_slice(contents, start, i)),
            "'"));
          return null;
        }
      }
    }

    // Character or string
    else if (c == '"' || c == '\'' || c == '`') {
      while (i < limit) {
        var next = String_get(contents, i);

        // Escape any character including newlines
        if (i + 1 < limit && next == '\\') {
          i = i + 2;
        }

        // Only allow newlines in template literals
        else if (next == '\n' && c != '`') {
          break;
        }

        // Handle a normal character
        else {
          i = i + 1;

          // End the string with a matching quote character
          if (next == c) {
            kind = c == '\'' ? TokenKind.CHARACTER : TokenKind.STRING;
            break;
          }
        }
      }

      // It's an error if we didn't find a matching quote character
      if (kind == TokenKind.END_OF_FILE) {
        log.error(createRange(source, start, i), String_new(
          c == '\'' ? "Unterminated character literal" :
          c == '`' ? "Unterminated template literal" :
          "Unterminated string literal"));
        return null;
      }
    }

    // Operators
    else if (c == '%') kind = TokenKind.REMAINDER;
    else if (c == '(') kind = TokenKind.LEFT_PARENTHESIS;
    else if (c == ')') kind = TokenKind.RIGHT_PARENTHESIS;
    else if (c == '*') kind = TokenKind.MULTIPLY;
    else if (c == ',') kind = TokenKind.COMMA;
    else if (c == '.') kind = TokenKind.DOT;
    else if (c == ':') kind = TokenKind.COLON;
    else if (c == ';') kind = TokenKind.SEMICOLON;
    else if (c == '?') kind = TokenKind.QUESTION_MARK;
    else if (c == '[') kind = TokenKind.LEFT_BRACKET;
    else if (c == ']') kind = TokenKind.RIGHT_BRACKET;
    else if (c == '^') kind = TokenKind.BITWISE_XOR;
    else if (c == '{') kind = TokenKind.LEFT_BRACE;
    else if (c == '}') kind = TokenKind.RIGHT_BRACE;
    else if (c == '~') kind = TokenKind.COMPLEMENT;

    // / or // or /*
    else if (c == '/') {
      kind = TokenKind.DIVIDE;

      // Single-line comments
      if (i < limit && String_get(contents, i) == '/') {
        i = i + 1;

        while (i < limit && String_get(contents, i) != '\n') {
          i = i + 1;
        }

        continue;
      }

      // Multi-line comments
      if (i < limit && String_get(contents, i) == '*') {
        i = i + 1;
        var foundEnd = false;

        while (i < limit) {
          var next = String_get(contents, i);

          if (next == '*' && i + 1 < limit && String_get(contents, i + 1) == '/') {
            foundEnd = true;
            i = i + 2;
            break;
          }

          i = i + 1;
        }

        if (!foundEnd) {
          log.error(createRange(source, start, start + 2), String_new("Unterminated multi-line comment"));
          return null;
        }

        continue;
      }
    }

    // ! or !=
    else if (c == '!') {
      kind = TokenKind.NOT;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.NOT_EQUAL;
        i = i + 1;

        // Recover from !==
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '!=' instead of '!=='"));
        }
      }
    }

    // = or ==
    else if (c == '=') {
      kind = TokenKind.ASSIGN;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.EQUAL;
        i = i + 1;

        // Recover from ===
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '==' instead of '==='"));
        }
      }
    }

    // + or ++
    else if (c == '+') {
      kind = TokenKind.PLUS;

      if (i < limit && String_get(contents, i) == '+') {
        kind = TokenKind.PLUS_PLUS;
        i = i + 1;
      }
    }

    // - or --
    else if (c == '-') {
      kind = TokenKind.MINUS;

      if (i < limit && String_get(contents, i) == '-') {
        kind = TokenKind.MINUS_MINUS;
        i = i + 1;
      }
    }

    // & or &&
    else if (c == '&') {
      kind = TokenKind.BITWISE_AND;

      if (i < limit && String_get(contents, i) == '&') {
        kind = TokenKind.LOGICAL_AND;
        i = i + 1;
      }
    }

    // | or ||
    else if (c == '|') {
      kind = TokenKind.BITWISE_OR;

      if (i < limit && String_get(contents, i) == '|') {
        kind = TokenKind.LOGICAL_OR;
        i = i + 1;
      }
    }

    // < or << or <=
    else if (c == '<') {
      kind = TokenKind.LESS_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '<') {
          kind = TokenKind.SHIFT_LEFT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.LESS_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    // > or >> or >=
    else if (c == '>') {
      kind = TokenKind.GREATER_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '>') {
          kind = TokenKind.SHIFT_RIGHT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.GREATER_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    var range = createRange(source, start, i);

    if (kind == TokenKind.END_OF_FILE) {
      log.error(range,
        String_appendNew(
          String_append(
            String_new("Syntax error: '"),
            String_slice(contents, start, start + 1)),
          "'"));
      return null;
    }

    var token = new Token();
    token.kind = kind;
    token.range = range;

    if (first == null) first = token;
    else last.next = token;
    last = token;
  }

  var eof = new Token();
  eof.kind = TokenKind.END_OF_FILE;
  eof.range = createRange(source, limit, limit);

  if (first == null) first = eof;
  else last.next = eof;
  last = eof;

  return first;
}
function tokenize223(source: Source, log: Log): Token {
  var first: Token = null;
  var last: Token = null;
  var contents = source.contents;
  var limit = String_length(contents);
  var i = 0;

  while (i < limit) {
    var start = i;
    var c = String_get(contents, i);
    i = i + 1;

    if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
      continue;
    }

    var kind = TokenKind.END_OF_FILE;

    // Identifier
    if (isAlpha(c)) {
      kind = TokenKind.IDENTIFIER;

      while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
        i = i + 1;
      }

      // Keywords
      var text = String_slice(contents, start, i);
      if (String_equalNew(text, "alignof")) kind = TokenKind.ALIGNOF;
      else if (String_equalNew(text, "as")) kind = TokenKind.AS;
      else if (String_equalNew(text, "break")) kind = TokenKind.BREAK;
      else if (String_equalNew(text, "class")) kind = TokenKind.CLASS;
      else if (String_equalNew(text, "const")) kind = TokenKind.CONST;
      else if (String_equalNew(text, "continue")) kind = TokenKind.CONTINUE;
      else if (String_equalNew(text, "declare")) kind = TokenKind.DECLARE;
      else if (String_equalNew(text, "else")) kind = TokenKind.ELSE;
      else if (String_equalNew(text, "enum")) kind = TokenKind.ENUM;
      else if (String_equalNew(text, "export")) kind = TokenKind.EXPORT;
      else if (String_equalNew(text, "extends")) kind = TokenKind.EXTENDS;
      else if (String_equalNew(text, "extern")) kind = TokenKind.EXTERN;
      else if (String_equalNew(text, "false")) kind = TokenKind.FALSE;
      else if (String_equalNew(text, "function")) kind = TokenKind.FUNCTION;
      else if (String_equalNew(text, "if")) kind = TokenKind.IF;
      else if (String_equalNew(text, "implements")) kind = TokenKind.IMPLEMENTS;
      else if (String_equalNew(text, "import")) kind = TokenKind.IMPORT;
      else if (String_equalNew(text, "interface")) kind = TokenKind.INTERFACE;
      else if (String_equalNew(text, "let")) kind = TokenKind.LET;
      else if (String_equalNew(text, "new")) kind = TokenKind.NEW;
      else if (String_equalNew(text, "null")) kind = TokenKind.NULL;
      else if (String_equalNew(text, "private")) kind = TokenKind.PRIVATE;
      else if (String_equalNew(text, "protected")) kind = TokenKind.PROTECTED;
      else if (String_equalNew(text, "public")) kind = TokenKind.PUBLIC;
      else if (String_equalNew(text, "return")) kind = TokenKind.RETURN;
      else if (String_equalNew(text, "sizeof")) kind = TokenKind.SIZEOF;
      else if (String_equalNew(text, "static")) kind = TokenKind.STATIC;
      else if (String_equalNew(text, "this")) kind = TokenKind.THIS;
      else if (String_equalNew(text, "true")) kind = TokenKind.TRUE;
      else if (String_equalNew(text, "unsafe")) kind = TokenKind.UNSAFE;
      else if (String_equalNew(text, "var")) kind = TokenKind.VAR;
      else if (String_equalNew(text, "while")) kind = TokenKind.WHILE;
    }

    // Integer
    else if (isNumber(c)) {
      kind = TokenKind.INT;

      if (i < limit) {
        var next = String_get(contents, i);
        var base = 10;

        // Handle binary, octal, and hexadecimal prefixes
        if (c == '0' && i + 1 < limit) {
          if (next == 'b' || next == 'B') base = 2;
          else if (next == 'o' || next == 'O') base = 8;
          else if (next == 'x' || next == 'X') base = 16;
          if (base != 10) {
            if (isDigit(String_get(contents, i + 1), base)) i = i + 2;
            else base = 10;
          }
        }

        // Scan the payload
        while (i < limit && isDigit(String_get(contents, i), base)) {
          i = i + 1;
        }

        // Extra letters after the end is an error
        if (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
          i = i + 1;

          while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
            i = i + 1;
          }

          log.error(createRange(source, start, i), String_appendNew(String_append(
            String_new("Invalid integer literal: '"),
            String_slice(contents, start, i)),
            "'"));
          return null;
        }
      }
    }

    // Character or string
    else if (c == '"' || c == '\'' || c == '`') {
      while (i < limit) {
        var next = String_get(contents, i);

        // Escape any character including newlines
        if (i + 1 < limit && next == '\\') {
          i = i + 2;
        }

        // Only allow newlines in template literals
        else if (next == '\n' && c != '`') {
          break;
        }

        // Handle a normal character
        else {
          i = i + 1;

          // End the string with a matching quote character
          if (next == c) {
            kind = c == '\'' ? TokenKind.CHARACTER : TokenKind.STRING;
            break;
          }
        }
      }

      // It's an error if we didn't find a matching quote character
      if (kind == TokenKind.END_OF_FILE) {
        log.error(createRange(source, start, i), String_new(
          c == '\'' ? "Unterminated character literal" :
          c == '`' ? "Unterminated template literal" :
          "Unterminated string literal"));
        return null;
      }
    }

    // Operators
    else if (c == '%') kind = TokenKind.REMAINDER;
    else if (c == '(') kind = TokenKind.LEFT_PARENTHESIS;
    else if (c == ')') kind = TokenKind.RIGHT_PARENTHESIS;
    else if (c == '*') kind = TokenKind.MULTIPLY;
    else if (c == ',') kind = TokenKind.COMMA;
    else if (c == '.') kind = TokenKind.DOT;
    else if (c == ':') kind = TokenKind.COLON;
    else if (c == ';') kind = TokenKind.SEMICOLON;
    else if (c == '?') kind = TokenKind.QUESTION_MARK;
    else if (c == '[') kind = TokenKind.LEFT_BRACKET;
    else if (c == ']') kind = TokenKind.RIGHT_BRACKET;
    else if (c == '^') kind = TokenKind.BITWISE_XOR;
    else if (c == '{') kind = TokenKind.LEFT_BRACE;
    else if (c == '}') kind = TokenKind.RIGHT_BRACE;
    else if (c == '~') kind = TokenKind.COMPLEMENT;

    // / or // or /*
    else if (c == '/') {
      kind = TokenKind.DIVIDE;

      // Single-line comments
      if (i < limit && String_get(contents, i) == '/') {
        i = i + 1;

        while (i < limit && String_get(contents, i) != '\n') {
          i = i + 1;
        }

        continue;
      }

      // Multi-line comments
      if (i < limit && String_get(contents, i) == '*') {
        i = i + 1;
        var foundEnd = false;

        while (i < limit) {
          var next = String_get(contents, i);

          if (next == '*' && i + 1 < limit && String_get(contents, i + 1) == '/') {
            foundEnd = true;
            i = i + 2;
            break;
          }

          i = i + 1;
        }

        if (!foundEnd) {
          log.error(createRange(source, start, start + 2), String_new("Unterminated multi-line comment"));
          return null;
        }

        continue;
      }
    }

    // ! or !=
    else if (c == '!') {
      kind = TokenKind.NOT;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.NOT_EQUAL;
        i = i + 1;

        // Recover from !==
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '!=' instead of '!=='"));
        }
      }
    }

    // = or ==
    else if (c == '=') {
      kind = TokenKind.ASSIGN;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.EQUAL;
        i = i + 1;

        // Recover from ===
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '==' instead of '==='"));
        }
      }
    }

    // + or ++
    else if (c == '+') {
      kind = TokenKind.PLUS;

      if (i < limit && String_get(contents, i) == '+') {
        kind = TokenKind.PLUS_PLUS;
        i = i + 1;
      }
    }

    // - or --
    else if (c == '-') {
      kind = TokenKind.MINUS;

      if (i < limit && String_get(contents, i) == '-') {
        kind = TokenKind.MINUS_MINUS;
        i = i + 1;
      }
    }

    // & or &&
    else if (c == '&') {
      kind = TokenKind.BITWISE_AND;

      if (i < limit && String_get(contents, i) == '&') {
        kind = TokenKind.LOGICAL_AND;
        i = i + 1;
      }
    }

    // | or ||
    else if (c == '|') {
      kind = TokenKind.BITWISE_OR;

      if (i < limit && String_get(contents, i) == '|') {
        kind = TokenKind.LOGICAL_OR;
        i = i + 1;
      }
    }

    // < or << or <=
    else if (c == '<') {
      kind = TokenKind.LESS_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '<') {
          kind = TokenKind.SHIFT_LEFT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.LESS_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    // > or >> or >=
    else if (c == '>') {
      kind = TokenKind.GREATER_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '>') {
          kind = TokenKind.SHIFT_RIGHT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.GREATER_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    var range = createRange(source, start, i);

    if (kind == TokenKind.END_OF_FILE) {
      log.error(range,
        String_appendNew(
          String_append(
            String_new("Syntax error: '"),
            String_slice(contents, start, start + 1)),
          "'"));
      return null;
    }

    var token = new Token();
    token.kind = kind;
    token.range = range;

    if (first == null) first = token;
    else last.next = token;
    last = token;
  }

  var eof = new Token();
  eof.kind = TokenKind.END_OF_FILE;
  eof.range = createRange(source, limit, limit);

  if (first == null) first = eof;
  else last.next = eof;
  last = eof;

  return first;
}

function tokenize323(source: Source, log: Log): Token {
  var first: Token = null;
  var last: Token = null;
  var contents = source.contents;
  var limit = String_length(contents);
  var i = 0;

  while (i < limit) {
    var start = i;
    var c = String_get(contents, i);
    i = i + 1;

    if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
      continue;
    }

    var kind = TokenKind.END_OF_FILE;

    // Identifier
    if (isAlpha(c)) {
      kind = TokenKind.IDENTIFIER;

      while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
        i = i + 1;
      }

      // Keywords
      var text = String_slice(contents, start, i);
      if (String_equalNew(text, "alignof")) kind = TokenKind.ALIGNOF;
      else if (String_equalNew(text, "as")) kind = TokenKind.AS;
      else if (String_equalNew(text, "break")) kind = TokenKind.BREAK;
      else if (String_equalNew(text, "class")) kind = TokenKind.CLASS;
      else if (String_equalNew(text, "const")) kind = TokenKind.CONST;
      else if (String_equalNew(text, "continue")) kind = TokenKind.CONTINUE;
      else if (String_equalNew(text, "declare")) kind = TokenKind.DECLARE;
      else if (String_equalNew(text, "else")) kind = TokenKind.ELSE;
      else if (String_equalNew(text, "enum")) kind = TokenKind.ENUM;
      else if (String_equalNew(text, "export")) kind = TokenKind.EXPORT;
      else if (String_equalNew(text, "extends")) kind = TokenKind.EXTENDS;
      else if (String_equalNew(text, "extern")) kind = TokenKind.EXTERN;
      else if (String_equalNew(text, "false")) kind = TokenKind.FALSE;
      else if (String_equalNew(text, "function")) kind = TokenKind.FUNCTION;
      else if (String_equalNew(text, "if")) kind = TokenKind.IF;
      else if (String_equalNew(text, "implements")) kind = TokenKind.IMPLEMENTS;
      else if (String_equalNew(text, "import")) kind = TokenKind.IMPORT;
      else if (String_equalNew(text, "interface")) kind = TokenKind.INTERFACE;
      else if (String_equalNew(text, "let")) kind = TokenKind.LET;
      else if (String_equalNew(text, "new")) kind = TokenKind.NEW;
      else if (String_equalNew(text, "null")) kind = TokenKind.NULL;
      else if (String_equalNew(text, "private")) kind = TokenKind.PRIVATE;
      else if (String_equalNew(text, "protected")) kind = TokenKind.PROTECTED;
      else if (String_equalNew(text, "public")) kind = TokenKind.PUBLIC;
      else if (String_equalNew(text, "return")) kind = TokenKind.RETURN;
      else if (String_equalNew(text, "sizeof")) kind = TokenKind.SIZEOF;
      else if (String_equalNew(text, "static")) kind = TokenKind.STATIC;
      else if (String_equalNew(text, "this")) kind = TokenKind.THIS;
      else if (String_equalNew(text, "true")) kind = TokenKind.TRUE;
      else if (String_equalNew(text, "unsafe")) kind = TokenKind.UNSAFE;
      else if (String_equalNew(text, "var")) kind = TokenKind.VAR;
      else if (String_equalNew(text, "while")) kind = TokenKind.WHILE;
    }

    // Integer
    else if (isNumber(c)) {
      kind = TokenKind.INT;

      if (i < limit) {
        var next = String_get(contents, i);
        var base = 10;

        // Handle binary, octal, and hexadecimal prefixes
        if (c == '0' && i + 1 < limit) {
          if (next == 'b' || next == 'B') base = 2;
          else if (next == 'o' || next == 'O') base = 8;
          else if (next == 'x' || next == 'X') base = 16;
          if (base != 10) {
            if (isDigit(String_get(contents, i + 1), base)) i = i + 2;
            else base = 10;
          }
        }

        // Scan the payload
        while (i < limit && isDigit(String_get(contents, i), base)) {
          i = i + 1;
        }

        // Extra letters after the end is an error
        if (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
          i = i + 1;

          while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
            i = i + 1;
          }

          log.error(createRange(source, start, i), String_appendNew(String_append(
            String_new("Invalid integer literal: '"),
            String_slice(contents, start, i)),
            "'"));
          return null;
        }
      }
    }

    // Character or string
    else if (c == '"' || c == '\'' || c == '`') {
      while (i < limit) {
        var next = String_get(contents, i);

        // Escape any character including newlines
        if (i + 1 < limit && next == '\\') {
          i = i + 2;
        }

        // Only allow newlines in template literals
        else if (next == '\n' && c != '`') {
          break;
        }

        // Handle a normal character
        else {
          i = i + 1;

          // End the string with a matching quote character
          if (next == c) {
            kind = c == '\'' ? TokenKind.CHARACTER : TokenKind.STRING;
            break;
          }
        }
      }

      // It's an error if we didn't find a matching quote character
      if (kind == TokenKind.END_OF_FILE) {
        log.error(createRange(source, start, i), String_new(
          c == '\'' ? "Unterminated character literal" :
          c == '`' ? "Unterminated template literal" :
          "Unterminated string literal"));
        return null;
      }
    }

    // Operators
    else if (c == '%') kind = TokenKind.REMAINDER;
    else if (c == '(') kind = TokenKind.LEFT_PARENTHESIS;
    else if (c == ')') kind = TokenKind.RIGHT_PARENTHESIS;
    else if (c == '*') kind = TokenKind.MULTIPLY;
    else if (c == ',') kind = TokenKind.COMMA;
    else if (c == '.') kind = TokenKind.DOT;
    else if (c == ':') kind = TokenKind.COLON;
    else if (c == ';') kind = TokenKind.SEMICOLON;
    else if (c == '?') kind = TokenKind.QUESTION_MARK;
    else if (c == '[') kind = TokenKind.LEFT_BRACKET;
    else if (c == ']') kind = TokenKind.RIGHT_BRACKET;
    else if (c == '^') kind = TokenKind.BITWISE_XOR;
    else if (c == '{') kind = TokenKind.LEFT_BRACE;
    else if (c == '}') kind = TokenKind.RIGHT_BRACE;
    else if (c == '~') kind = TokenKind.COMPLEMENT;

    // / or // or /*
    else if (c == '/') {
      kind = TokenKind.DIVIDE;

      // Single-line comments
      if (i < limit && String_get(contents, i) == '/') {
        i = i + 1;

        while (i < limit && String_get(contents, i) != '\n') {
          i = i + 1;
        }

        continue;
      }

      // Multi-line comments
      if (i < limit && String_get(contents, i) == '*') {
        i = i + 1;
        var foundEnd = false;

        while (i < limit) {
          var next = String_get(contents, i);

          if (next == '*' && i + 1 < limit && String_get(contents, i + 1) == '/') {
            foundEnd = true;
            i = i + 2;
            break;
          }

          i = i + 1;
        }

        if (!foundEnd) {
          log.error(createRange(source, start, start + 2), String_new("Unterminated multi-line comment"));
          return null;
        }

        continue;
      }
    }

    // ! or !=
    else if (c == '!') {
      kind = TokenKind.NOT;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.NOT_EQUAL;
        i = i + 1;

        // Recover from !==
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '!=' instead of '!=='"));
        }
      }
    }

    // = or ==
    else if (c == '=') {
      kind = TokenKind.ASSIGN;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.EQUAL;
        i = i + 1;

        // Recover from ===
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '==' instead of '==='"));
        }
      }
    }

    // + or ++
    else if (c == '+') {
      kind = TokenKind.PLUS;

      if (i < limit && String_get(contents, i) == '+') {
        kind = TokenKind.PLUS_PLUS;
        i = i + 1;
      }
    }

    // - or --
    else if (c == '-') {
      kind = TokenKind.MINUS;

      if (i < limit && String_get(contents, i) == '-') {
        kind = TokenKind.MINUS_MINUS;
        i = i + 1;
      }
    }

    // & or &&
    else if (c == '&') {
      kind = TokenKind.BITWISE_AND;

      if (i < limit && String_get(contents, i) == '&') {
        kind = TokenKind.LOGICAL_AND;
        i = i + 1;
      }
    }

    // | or ||
    else if (c == '|') {
      kind = TokenKind.BITWISE_OR;

      if (i < limit && String_get(contents, i) == '|') {
        kind = TokenKind.LOGICAL_OR;
        i = i + 1;
      }
    }

    // < or << or <=
    else if (c == '<') {
      kind = TokenKind.LESS_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '<') {
          kind = TokenKind.SHIFT_LEFT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.LESS_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    // > or >> or >=
    else if (c == '>') {
      kind = TokenKind.GREATER_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '>') {
          kind = TokenKind.SHIFT_RIGHT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.GREATER_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    var range = createRange(source, start, i);

    if (kind == TokenKind.END_OF_FILE) {
      log.error(range,
        String_appendNew(
          String_append(
            String_new("Syntax error: '"),
            String_slice(contents, start, start + 1)),
          "'"));
      return null;
    }

    var token = new Token();
    token.kind = kind;
    token.range = range;

    if (first == null) first = token;
    else last.next = token;
    last = token;
  }

  var eof = new Token();
  eof.kind = TokenKind.END_OF_FILE;
  eof.range = createRange(source, limit, limit);

  if (first == null) first = eof;
  else last.next = eof;
  last = eof;

  return first;
}

function tokenize423(source: Source, log: Log): Token {
  var first: Token = null;
  var last: Token = null;
  var contents = source.contents;
  var limit = String_length(contents);
  var i = 0;

  while (i < limit) {
    var start = i;
    var c = String_get(contents, i);
    i = i + 1;

    if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
      continue;
    }

    var kind = TokenKind.END_OF_FILE;

    // Identifier
    if (isAlpha(c)) {
      kind = TokenKind.IDENTIFIER;

      while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
        i = i + 1;
      }

      // Keywords
      var text = String_slice(contents, start, i);
      if (String_equalNew(text, "alignof")) kind = TokenKind.ALIGNOF;
      else if (String_equalNew(text, "as")) kind = TokenKind.AS;
      else if (String_equalNew(text, "break")) kind = TokenKind.BREAK;
      else if (String_equalNew(text, "class")) kind = TokenKind.CLASS;
      else if (String_equalNew(text, "const")) kind = TokenKind.CONST;
      else if (String_equalNew(text, "continue")) kind = TokenKind.CONTINUE;
      else if (String_equalNew(text, "declare")) kind = TokenKind.DECLARE;
      else if (String_equalNew(text, "else")) kind = TokenKind.ELSE;
      else if (String_equalNew(text, "enum")) kind = TokenKind.ENUM;
      else if (String_equalNew(text, "export")) kind = TokenKind.EXPORT;
      else if (String_equalNew(text, "extends")) kind = TokenKind.EXTENDS;
      else if (String_equalNew(text, "extern")) kind = TokenKind.EXTERN;
      else if (String_equalNew(text, "false")) kind = TokenKind.FALSE;
      else if (String_equalNew(text, "function")) kind = TokenKind.FUNCTION;
      else if (String_equalNew(text, "if")) kind = TokenKind.IF;
      else if (String_equalNew(text, "implements")) kind = TokenKind.IMPLEMENTS;
      else if (String_equalNew(text, "import")) kind = TokenKind.IMPORT;
      else if (String_equalNew(text, "interface")) kind = TokenKind.INTERFACE;
      else if (String_equalNew(text, "let")) kind = TokenKind.LET;
      else if (String_equalNew(text, "new")) kind = TokenKind.NEW;
      else if (String_equalNew(text, "null")) kind = TokenKind.NULL;
      else if (String_equalNew(text, "private")) kind = TokenKind.PRIVATE;
      else if (String_equalNew(text, "protected")) kind = TokenKind.PROTECTED;
      else if (String_equalNew(text, "public")) kind = TokenKind.PUBLIC;
      else if (String_equalNew(text, "return")) kind = TokenKind.RETURN;
      else if (String_equalNew(text, "sizeof")) kind = TokenKind.SIZEOF;
      else if (String_equalNew(text, "static")) kind = TokenKind.STATIC;
      else if (String_equalNew(text, "this")) kind = TokenKind.THIS;
      else if (String_equalNew(text, "true")) kind = TokenKind.TRUE;
      else if (String_equalNew(text, "unsafe")) kind = TokenKind.UNSAFE;
      else if (String_equalNew(text, "var")) kind = TokenKind.VAR;
      else if (String_equalNew(text, "while")) kind = TokenKind.WHILE;
    }

    // Integer
    else if (isNumber(c)) {
      kind = TokenKind.INT;

      if (i < limit) {
        var next = String_get(contents, i);
        var base = 10;

        // Handle binary, octal, and hexadecimal prefixes
        if (c == '0' && i + 1 < limit) {
          if (next == 'b' || next == 'B') base = 2;
          else if (next == 'o' || next == 'O') base = 8;
          else if (next == 'x' || next == 'X') base = 16;
          if (base != 10) {
            if (isDigit(String_get(contents, i + 1), base)) i = i + 2;
            else base = 10;
          }
        }

        // Scan the payload
        while (i < limit && isDigit(String_get(contents, i), base)) {
          i = i + 1;
        }

        // Extra letters after the end is an error
        if (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
          i = i + 1;

          while (i < limit && (isAlpha(String_get(contents, i)) || isNumber(String_get(contents, i)))) {
            i = i + 1;
          }

          log.error(createRange(source, start, i), String_appendNew(String_append(
            String_new("Invalid integer literal: '"),
            String_slice(contents, start, i)),
            "'"));
          return null;
        }
      }
    }

    // Character or string
    else if (c == '"' || c == '\'' || c == '`') {
      while (i < limit) {
        var next = String_get(contents, i);

        // Escape any character including newlines
        if (i + 1 < limit && next == '\\') {
          i = i + 2;
        }

        // Only allow newlines in template literals
        else if (next == '\n' && c != '`') {
          break;
        }

        // Handle a normal character
        else {
          i = i + 1;

          // End the string with a matching quote character
          if (next == c) {
            kind = c == '\'' ? TokenKind.CHARACTER : TokenKind.STRING;
            break;
          }
        }
      }

      // It's an error if we didn't find a matching quote character
      if (kind == TokenKind.END_OF_FILE) {
        log.error(createRange(source, start, i), String_new(
          c == '\'' ? "Unterminated character literal" :
          c == '`' ? "Unterminated template literal" :
          "Unterminated string literal"));
        return null;
      }
    }

    // Operators
    else if (c == '%') kind = TokenKind.REMAINDER;
    else if (c == '(') kind = TokenKind.LEFT_PARENTHESIS;
    else if (c == ')') kind = TokenKind.RIGHT_PARENTHESIS;
    else if (c == '*') kind = TokenKind.MULTIPLY;
    else if (c == ',') kind = TokenKind.COMMA;
    else if (c == '.') kind = TokenKind.DOT;
    else if (c == ':') kind = TokenKind.COLON;
    else if (c == ';') kind = TokenKind.SEMICOLON;
    else if (c == '?') kind = TokenKind.QUESTION_MARK;
    else if (c == '[') kind = TokenKind.LEFT_BRACKET;
    else if (c == ']') kind = TokenKind.RIGHT_BRACKET;
    else if (c == '^') kind = TokenKind.BITWISE_XOR;
    else if (c == '{') kind = TokenKind.LEFT_BRACE;
    else if (c == '}') kind = TokenKind.RIGHT_BRACE;
    else if (c == '~') kind = TokenKind.COMPLEMENT;

    // / or // or /*
    else if (c == '/') {
      kind = TokenKind.DIVIDE;

      // Single-line comments
      if (i < limit && String_get(contents, i) == '/') {
        i = i + 1;

        while (i < limit && String_get(contents, i) != '\n') {
          i = i + 1;
        }

        continue;
      }

      // Multi-line comments
      if (i < limit && String_get(contents, i) == '*') {
        i = i + 1;
        var foundEnd = false;

        while (i < limit) {
          var next = String_get(contents, i);

          if (next == '*' && i + 1 < limit && String_get(contents, i + 1) == '/') {
            foundEnd = true;
            i = i + 2;
            break;
          }

          i = i + 1;
        }

        if (!foundEnd) {
          log.error(createRange(source, start, start + 2), String_new("Unterminated multi-line comment"));
          return null;
        }

        continue;
      }
    }

    // ! or !=
    else if (c == '!') {
      kind = TokenKind.NOT;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.NOT_EQUAL;
        i = i + 1;

        // Recover from !==
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '!=' instead of '!=='"));
        }
      }
    }

    // = or ==
    else if (c == '=') {
      kind = TokenKind.ASSIGN;

      if (i < limit && String_get(contents, i) == '=') {
        kind = TokenKind.EQUAL;
        i = i + 1;

        // Recover from ===
        if (i < limit && String_get(contents, i) == '=') {
          i = i + 1;
          log.error(createRange(source, start, i), String_new("Use '==' instead of '==='"));
        }
      }
    }

    // + or ++
    else if (c == '+') {
      kind = TokenKind.PLUS;

      if (i < limit && String_get(contents, i) == '+') {
        kind = TokenKind.PLUS_PLUS;
        i = i + 1;
      }
    }

    // - or --
    else if (c == '-') {
      kind = TokenKind.MINUS;

      if (i < limit && String_get(contents, i) == '-') {
        kind = TokenKind.MINUS_MINUS;
        i = i + 1;
      }
    }

    // & or &&
    else if (c == '&') {
      kind = TokenKind.BITWISE_AND;

      if (i < limit && String_get(contents, i) == '&') {
        kind = TokenKind.LOGICAL_AND;
        i = i + 1;
      }
    }

    // | or ||
    else if (c == '|') {
      kind = TokenKind.BITWISE_OR;

      if (i < limit && String_get(contents, i) == '|') {
        kind = TokenKind.LOGICAL_OR;
        i = i + 1;
      }
    }

    // < or << or <=
    else if (c == '<') {
      kind = TokenKind.LESS_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '<') {
          kind = TokenKind.SHIFT_LEFT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.LESS_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    // > or >> or >=
    else if (c == '>') {
      kind = TokenKind.GREATER_THAN;

      if (i < limit) {
        c = String_get(contents, i);

        if (c == '>') {
          kind = TokenKind.SHIFT_RIGHT;
          i = i + 1;
        }

        else if (c == '=') {
          kind = TokenKind.GREATER_THAN_EQUAL;
          i = i + 1;
        }
      }
    }

    var range = createRange(source, start, i);

    if (kind == TokenKind.END_OF_FILE) {
      log.error(range,
        String_appendNew(
          String_append(
            String_new("Syntax error: '"),
            String_slice(contents, start, start + 1)),
          "'"));
      return null;
    }

    var token = new Token();
    token.kind = kind;
    token.range = range;

    if (first == null) first = token;
    else last.next = token;
    last = token;
  }

  var eof = new Token();
  eof.kind = TokenKind.END_OF_FILE;
  eof.range = createRange(source, limit, limit);

  if (first == null) first = eof;
  else last.next = eof;
  last = eof;

  return first;
}

class WasmModule2 {
  firstImport: WasmImport;
  lastImport: WasmImport;
  importCount: int;

  firstFunction: WasmFunction;
  lastFunction: WasmFunction;
  functionCount: int;

  firstSignature: WasmSignature;
  lastSignature: WasmSignature;
  signatureCount: int;

  memoryInitializer: ByteArray;
  currentHeapPointer: int;
  originalHeapPointer: int;
  mallocFunctionIndex: int;
  context: CheckContext;

  growMemoryInitializer(): void {
    var array = this.memoryInitializer;
    var current = array.length();
    var length = this.context.nextGlobalVariableOffset;

    while (current < length) {
      array.append(0);
      current = current + 1;
    }
  }

  allocateImport(signatureIndex: int, mod: String, name: String): WasmImport {
    var result = new WasmImport();
    result.signatureIndex = signatureIndex;
    result.module = mod;
    result.name = name;

    if (this.firstImport == null) this.firstImport = result;
    else this.lastImport.next = result;
    this.lastImport = result;

    this.importCount = this.importCount + 1;
    return result;
  }

  allocateFunction(name: String, signatureIndex: int, body: Node): WasmFunction {
    var fn = new WasmFunction();
    fn.name = name;
    fn.signatureIndex = signatureIndex;
    fn.body = body;

    if (this.firstFunction == null) this.firstFunction = fn;
    else this.lastFunction.next = fn;
    this.lastFunction = fn;

    this.functionCount = this.functionCount + 1;
    return fn;
  }

  allocateSignature(argumentTypes: WasmWrappedType, returnType: WasmWrappedType): int {
    assert(returnType != null);
    assert(returnType.next == null);

    var signature = new WasmSignature();
    signature.argumentTypes = argumentTypes;
    signature.returnType = returnType;

    var check = this.firstSignature;
    var i = 0;

    while (check != null) {
      if (wasmAreSignaturesEqual(signature, check)) {
        return i;
      }

      check = check.next;
      i = i + 1;
    }

    if (this.firstSignature == null) this.firstSignature = signature;
    else this.lastSignature.next = signature;
    this.lastSignature = signature;

    this.signatureCount = this.signatureCount + 1;
    return i;
  }

  emitModule(array: ByteArray): void {
    ByteArray_append32(array, WASM_MAGIC);
    ByteArray_append32(array, WASM_VERSION);

    this.emitSignatures(array);
    this.emitImportTable(array);
    this.emitFunctionSignatures(array);
    this.emitMemory(array);
    this.emitExportTable(array);
    this.emitFunctionBodies(array);
    this.emitDataSegments(array);
  }

  emitSignatures(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("signatures"));
    wasmWriteVarUnsigned(array, this.signatureCount);

    var signature = this.firstSignature;
    while (signature != null) {
      var count = 0;
      var type = signature.argumentTypes;

      while (type != null) {
        count = count + 1;
        type = type.next;
      }

      wasmWriteVarUnsigned(array, count);
      wasmWriteVarUnsigned(array, signature.returnType.id as int);

      type = signature.argumentTypes;
      while (type != null) {
        wasmWriteVarUnsigned(array, type.id as int);
        type = type.next;
      }

      signature = signature.next;
    }

    wasmFinishSection(array, section);
  }

  emitImportTable(array: ByteArray): void {
    if (this.firstImport == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("import_table"));
    wasmWriteVarUnsigned(array, this.importCount);

    var current = this.firstImport;
    while (current != null) {
      wasmWriteVarUnsigned(array, current.signatureIndex);
      wasmWriteLengthPrefixedString(array, current.module);
      wasmWriteLengthPrefixedString(array, current.name);
      current = current.next;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionSignatures(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_signatures"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      wasmWriteVarUnsigned(array, fn.signatureIndex);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitMemory(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("memory"));
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, 1); // The memory array is exported
    wasmFinishSection(array, section);
  }

  emitExportTable(array: ByteArray): void {
    var exportedCount = 0;
    var fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        exportedCount = exportedCount + 1;
      }
      fn = fn.next;
    }
    if (exportedCount == 0) {
      return;
    }

    var section = wasmStartSection(array, String_new("export_table"));
    wasmWriteVarUnsigned(array, exportedCount);

    var i = 0;
    fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        wasmWriteVarUnsigned(array, i);
        wasmWriteLengthPrefixedString(array, fn.name);
      }
      fn = fn.next;
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionBodies(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_bodies"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      var bodyLength = array.length();
      wasmWriteVarUnsigned(array, ~0); // This will be patched later

      if (fn.intLocalCount > 0) {
        wasmWriteVarUnsigned(array, 1);
        wasmWriteVarUnsigned(array, fn.intLocalCount);
        array.append(WasmType.I32);
      } else {
        wasmWriteVarUnsigned(array, 0);
      }

      var child = fn.body.firstChild;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }

      wasmPatchVarUnsigned(array, bodyLength, array.length() - bodyLength - 5, ~0);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitDataSegments(array: ByteArray): void {
    this.growMemoryInitializer();
    var memoryInitializer = this.memoryInitializer;
    var initializerLength = memoryInitializer.length();
    var initialHeapPointer = alignToNextMultipleOf(WASM_MEMORY_INITIALIZER_BASE + initializerLength, 8);

    // Pass the initial heap pointer to the "malloc" function
    ByteArray_set32(memoryInitializer, this.currentHeapPointer, initialHeapPointer);
    ByteArray_set32(memoryInitializer, this.originalHeapPointer, initialHeapPointer);

    var section = wasmStartSection(array, String_new("data_segments"));

    // This only writes one single section containing everything
    wasmWriteVarUnsigned(array, 1);

    // Emit the range of the memory initializer
    wasmWriteVarUnsigned(array, WASM_MEMORY_INITIALIZER_BASE);
    wasmWriteVarUnsigned(array, initializerLength);

    // Copy the entire memory initializer (also includes zero-initialized data for now)
    var i = 0;
    while (i < initializerLength) {
      array.append(memoryInitializer.get(i));
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  prepareToEmit(node: Node): void {
    if (node.kind == NodeKind.STRING) {
      var text = node.stringValue;
      var length = String_length(text);
      var offset = this.context.allocateGlobalVariableOffset(length + 1, 1);;
      this.growMemoryInitializer();
      var memoryInitializer = this.memoryInitializer;
      var i = 0;
      while (i < length) {
        memoryInitializer.set(offset + i, String_get(text, i) as byte);
        i = i + 1;
      }
      memoryInitializer.set(offset + length, 0);
      node.intValue = offset;
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        var sizeOf = symbol.resolvedType.variableSizeOf();
        var value = symbol.node.variableValue().intValue;
        var memoryInitializer = this.memoryInitializer;

        // Copy the inital value into the memory initializer
        this.growMemoryInitializer();
        if (sizeOf == 1) memoryInitializer.set(symbol.offset, value as byte);
        else if (sizeOf == 2) ByteArray_set16(memoryInitializer, symbol.offset, value);
        else if (sizeOf == 4) ByteArray_set32(memoryInitializer, symbol.offset, value);
        else assert(false);

        // Make sure the heap offset is tracked
        if (String_equalNew(symbol.name, "currentHeapPointer")) {
          assert(this.currentHeapPointer == -1);
          this.currentHeapPointer = symbol.offset;
        }

        // Make sure the heap offset is tracked
        else if (String_equalNew(symbol.name, "originalHeapPointer")) {
          assert(this.originalHeapPointer == -1);
          this.originalHeapPointer = symbol.offset;
        }
      }
    }

    else if (node.kind == NodeKind.FUNCTION) {
      var returnType = node.functionReturnType();
      var shared = new WasmSharedOffset();
      var argumentTypesFirst: WasmWrappedType = null;
      var argumentTypesLast: WasmWrappedType = null;

      // Make sure to include the implicit "this" variable as a normal argument
      var argument = node.firstChild;
      while (argument != returnType) {
        var type = wasmWrapType(this.getWasmType(argument.variableType().resolvedType));

        if (argumentTypesFirst == null) argumentTypesFirst = type;
        else argumentTypesLast.next = type;
        argumentTypesLast = type;

        shared.nextLocalOffset = shared.nextLocalOffset + 1;
        argument = argument.nextSibling;
      }
      var signatureIndex = this.allocateSignature(argumentTypesFirst, wasmWrapType(this.getWasmType(returnType.resolvedType)));
      var body = node.functionBody();
      var symbol = node.symbol;

      // Functions without bodies are imports
      if (body == null) {
        var moduleName = symbol.kind == SymbolKind.FUNCTION_INSTANCE ? symbol.parent().name : String_new("globals");
        symbol.offset = this.importCount;
        this.allocateImport(signatureIndex, moduleName, symbol.name);
        node = node.nextSibling;
        return;
      }

      symbol.offset = this.functionCount;
      var fn = this.allocateFunction(symbol.name, signatureIndex, body);

      // Make sure "malloc" is tracked
      if (symbol.kind == SymbolKind.FUNCTION_GLOBAL && String_equalNew(symbol.name, "malloc")) {
        assert(this.mallocFunctionIndex == -1);
        this.mallocFunctionIndex = symbol.offset;
      }

      // Only export "extern" functions
      if (node.isExtern()) {
        fn.isExported = true;
      }

      // Assign local variable offsets
      wasmAssignLocalVariableOffsets(body, shared);
      fn.intLocalCount = shared.intLocalCount;
    }

    var child = node.firstChild;
    while (child != null) {
      this.prepareToEmit(child);
      child = child.nextSibling;
    }
  }

  emitBinaryExpression(array: ByteArray, node: Node, opcode: byte): void {
    array.append(opcode);
    this.emitNode(array, node.binaryLeft());
    this.emitNode(array, node.binaryRight());
  }

  emitLoadFromMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD8_U : WASM_OPCODE_I32_LOAD8_S);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD16_U : WASM_OPCODE_I32_LOAD16_S);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_LOAD);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }
  }

  emitStoreToMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int, value: Node): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(WASM_OPCODE_I32_STORE8);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(WASM_OPCODE_I32_STORE16);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_STORE);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }

    this.emitNode(array, value);
  }

  emitNode(array: ByteArray, node: Node): int {
    assert(!isExpression(node) || node.resolvedType != null);

    if (node.kind == NodeKind.BLOCK) {
      array.append(WASM_OPCODE_BLOCK);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.WHILE) {
      var value = node.whileValue();
      var body = node.whileBody();

      // Ignore "while (false) { ... }"
      if (value.kind == NodeKind.BOOL && value.intValue == 0) {
        return 0;
      }

      array.append(WASM_OPCODE_LOOP);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;

      // Emit the condition as "loop { if (!condition) break; }" as long as it's not a "while (true)" loop
      if (value.kind != NodeKind.BOOL) {
        array.append(WASM_OPCODE_BR_IF);
        wasmWriteVarUnsigned(array, 1); // Break out of the immediately enclosing loop
        array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
        array.append(WASM_OPCODE_I32_EQZ); // The conditional is flipped
        this.emitNode(array, value);
        count = count + 1;
      }

      var child = body.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }

      // Jump back to the top (this doesn't happen automatically)
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, 0); // Continue back to the immediately enclosing loop
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
      count = count + 1;

      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.BREAK || node.kind == NodeKind.CONTINUE) {
      var label = 0;
      var parent = node.parent;

      while (parent != null && parent.kind != NodeKind.WHILE) {
        if (parent.kind == NodeKind.BLOCK) {
          label = label + 1;
        }
        parent = parent.parent;
      }

      assert(label > 0);
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, label - (node.kind == NodeKind.BREAK ? 0 : 1));
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
    }

    else if (node.kind == NodeKind.EMPTY) {
      return 0;
    }

    else if (node.kind == NodeKind.EXPRESSION) {
      this.emitNode(array, node.expressionValue());
    }

    else if (node.kind == NodeKind.RETURN) {
      var value = node.returnValue();
      array.append(WASM_OPCODE_RETURN);
      if (value != null) {
        this.emitNode(array, value);
      }
    }

    else if (node.kind == NodeKind.VARIABLES) {
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        assert(child.kind == NodeKind.VARIABLE);
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      return count;
    }

    else if (node.kind == NodeKind.IF) {
      var branch = node.ifFalse();
      array.append(branch == null ? WASM_OPCODE_IF : WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.ifValue());
      this.emitNode(array, node.ifTrue());
      if (branch != null) {
        this.emitNode(array, branch);
      }
    }

    else if (node.kind == NodeKind.HOOK) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.hookValue());
      this.emitNode(array, node.hookTrue());
      this.emitNode(array, node.hookFalse());
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var value = node.variableValue();

      if (node.symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, node.symbol.offset);

        if (value != null) {
          this.emitNode(array, value);
        }

        // Default initialization
        else {
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, 0);
        }
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NAME) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_GET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitLoadFromMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NULL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.INT || node.kind == NodeKind.BOOL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, node.intValue);
    }

    else if (node.kind == NodeKind.STRING) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, WASM_MEMORY_INITIALIZER_BASE + node.intValue);
    }

    else if (node.kind == NodeKind.CALL) {
      var value = node.callValue();
      var symbol = value.symbol;
      assert(isFunction(symbol.kind));

      array.append(symbol.node.functionBody() == null ? WASM_OPCODE_CALL_IMPORT : WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, symbol.offset);

      // Write out the implicit "this" argument
      if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
        this.emitNode(array, value.dotTarget());
      }

      var child = value.nextSibling;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }
    }

    else if (node.kind == NodeKind.NEW) {
      var type = node.newType();
      assert(type.symbol.kind == SymbolKind.TYPE_CLASS);

      array.append(WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, this.mallocFunctionIndex);

      // Pass the object size as the first argument
      assert(type.symbol.byteSize > 0);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, type.symbol.byteSize);
    }

    else if (node.kind == NodeKind.POSITIVE) {
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NEGATIVE) {
      array.append(WASM_OPCODE_I32_SUB);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.COMPLEMENT) {
      array.append(WASM_OPCODE_I32_XOR);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, ~0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NOT) {
      array.append(WASM_OPCODE_I32_EQZ);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.CAST) {
      var value = node.castValue();
      var context = this.context;
      var from = value.resolvedType.underlyingType(context);
      var type = node.resolvedType.underlyingType(context);

      // The cast isn't needed if it's to a wider integer type
      if (from == type || from.symbol.byteSize < type.symbol.byteSize) {
        this.emitNode(array, value);
      }

      else {
        // Sign-extend
        if (type == context.byteType || type == context.shortType) {
          var shift = 32 - type.symbol.byteSize * 8;
          array.append(WASM_OPCODE_I32_SHR_S);
          array.append(WASM_OPCODE_I32_SHL);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
        }

        // Mask
        else if (type == context.ubyteType || type == context.ushortType) {
          array.append(WASM_OPCODE_I32_AND);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, type.integerBitMask() as int);
        }

        // No cast needed
        else {
          this.emitNode(array, value);
        }
      }
    }

    else if (node.kind == NodeKind.DOT) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitLoadFromMemory(array, symbol.resolvedType, node.dotTarget(), symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.ASSIGN) {
      var left = node.binaryLeft();
      var symbol = left.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitStoreToMemory(array, symbol.resolvedType, left.dotTarget(), symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitStoreToMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
        this.emitNode(array, node.binaryRight());
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.LOGICAL_AND) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      this.emitNode(array, node.binaryRight());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.LOGICAL_OR) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 1);
      this.emitNode(array, node.binaryRight());
    }

    else {
      var isUnsigned = node.isUnsignedOperator();

      if (node.kind == NodeKind.ADD) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_ADD);
      else if (node.kind == NodeKind.BITWISE_AND) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_AND);
      else if (node.kind == NodeKind.BITWISE_OR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_OR);
      else if (node.kind == NodeKind.BITWISE_XOR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_XOR);
      else if (node.kind == NodeKind.EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_EQ);
      else if (node.kind == NodeKind.MULTIPLY) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_MUL);
      else if (node.kind == NodeKind.NOT_EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_NE);
      else if (node.kind == NodeKind.SHIFT_LEFT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SHL);
      else if (node.kind == NodeKind.SUBTRACT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SUB);

      else if (node.kind == NodeKind.DIVIDE) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_DIV_U : WASM_OPCODE_I32_DIV_S);
      else if (node.kind == NodeKind.GREATER_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GT_U : WASM_OPCODE_I32_GT_S);
      else if (node.kind == NodeKind.GREATER_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GE_U : WASM_OPCODE_I32_GE_S);
      else if (node.kind == NodeKind.LESS_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LT_U : WASM_OPCODE_I32_LT_S);
      else if (node.kind == NodeKind.LESS_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LE_U : WASM_OPCODE_I32_LE_S);
      else if (node.kind == NodeKind.REMAINDER) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_REM_U : WASM_OPCODE_I32_REM_S);
      else if (node.kind == NodeKind.SHIFT_RIGHT) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_SHR_U : WASM_OPCODE_I32_SHR_S);

      else {
        assert(false);
      }
    }

    return 1;
  }

  getWasmType(type: Type): WasmType {
    var context = this.context;

    if (type == context.boolType || type.isInteger() || type.isReference(context)) {
      return WasmType.I32;
    }

    if (type == context.voidType) {
      return WasmType.VOID;
    }

    assert(false);
    return WasmType.VOID;
  }
}
class WasmModule3 {
  firstImport: WasmImport;
  lastImport: WasmImport;
  importCount: int;

  firstFunction: WasmFunction;
  lastFunction: WasmFunction;
  functionCount: int;

  firstSignature: WasmSignature;
  lastSignature: WasmSignature;
  signatureCount: int;

  memoryInitializer: ByteArray;
  currentHeapPointer: int;
  originalHeapPointer: int;
  mallocFunctionIndex: int;
  context: CheckContext;

  growMemoryInitializer(): void {
    var array = this.memoryInitializer;
    var current = array.length();
    var length = this.context.nextGlobalVariableOffset;

    while (current < length) {
      array.append(0);
      current = current + 1;
    }
  }

  allocateImport(signatureIndex: int, mod: String, name: String): WasmImport {
    var result = new WasmImport();
    result.signatureIndex = signatureIndex;
    result.module = mod;
    result.name = name;

    if (this.firstImport == null) this.firstImport = result;
    else this.lastImport.next = result;
    this.lastImport = result;

    this.importCount = this.importCount + 1;
    return result;
  }

  allocateFunction(name: String, signatureIndex: int, body: Node): WasmFunction {
    var fn = new WasmFunction();
    fn.name = name;
    fn.signatureIndex = signatureIndex;
    fn.body = body;

    if (this.firstFunction == null) this.firstFunction = fn;
    else this.lastFunction.next = fn;
    this.lastFunction = fn;

    this.functionCount = this.functionCount + 1;
    return fn;
  }

  allocateSignature(argumentTypes: WasmWrappedType, returnType: WasmWrappedType): int {
    assert(returnType != null);
    assert(returnType.next == null);

    var signature = new WasmSignature();
    signature.argumentTypes = argumentTypes;
    signature.returnType = returnType;

    var check = this.firstSignature;
    var i = 0;

    while (check != null) {
      if (wasmAreSignaturesEqual(signature, check)) {
        return i;
      }

      check = check.next;
      i = i + 1;
    }

    if (this.firstSignature == null) this.firstSignature = signature;
    else this.lastSignature.next = signature;
    this.lastSignature = signature;

    this.signatureCount = this.signatureCount + 1;
    return i;
  }

  emitModule(array: ByteArray): void {
    ByteArray_append32(array, WASM_MAGIC);
    ByteArray_append32(array, WASM_VERSION);

    this.emitSignatures(array);
    this.emitImportTable(array);
    this.emitFunctionSignatures(array);
    this.emitMemory(array);
    this.emitExportTable(array);
    this.emitFunctionBodies(array);
    this.emitDataSegments(array);
  }

  emitSignatures(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("signatures"));
    wasmWriteVarUnsigned(array, this.signatureCount);

    var signature = this.firstSignature;
    while (signature != null) {
      var count = 0;
      var type = signature.argumentTypes;

      while (type != null) {
        count = count + 1;
        type = type.next;
      }

      wasmWriteVarUnsigned(array, count);
      wasmWriteVarUnsigned(array, signature.returnType.id as int);

      type = signature.argumentTypes;
      while (type != null) {
        wasmWriteVarUnsigned(array, type.id as int);
        type = type.next;
      }

      signature = signature.next;
    }

    wasmFinishSection(array, section);
  }

  emitImportTable(array: ByteArray): void {
    if (this.firstImport == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("import_table"));
    wasmWriteVarUnsigned(array, this.importCount);

    var current = this.firstImport;
    while (current != null) {
      wasmWriteVarUnsigned(array, current.signatureIndex);
      wasmWriteLengthPrefixedString(array, current.module);
      wasmWriteLengthPrefixedString(array, current.name);
      current = current.next;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionSignatures(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_signatures"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      wasmWriteVarUnsigned(array, fn.signatureIndex);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitMemory(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("memory"));
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, 1); // The memory array is exported
    wasmFinishSection(array, section);
  }

  emitExportTable(array: ByteArray): void {
    var exportedCount = 0;
    var fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        exportedCount = exportedCount + 1;
      }
      fn = fn.next;
    }
    if (exportedCount == 0) {
      return;
    }

    var section = wasmStartSection(array, String_new("export_table"));
    wasmWriteVarUnsigned(array, exportedCount);

    var i = 0;
    fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        wasmWriteVarUnsigned(array, i);
        wasmWriteLengthPrefixedString(array, fn.name);
      }
      fn = fn.next;
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionBodies(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_bodies"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      var bodyLength = array.length();
      wasmWriteVarUnsigned(array, ~0); // This will be patched later

      if (fn.intLocalCount > 0) {
        wasmWriteVarUnsigned(array, 1);
        wasmWriteVarUnsigned(array, fn.intLocalCount);
        array.append(WasmType.I32);
      } else {
        wasmWriteVarUnsigned(array, 0);
      }

      var child = fn.body.firstChild;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }

      wasmPatchVarUnsigned(array, bodyLength, array.length() - bodyLength - 5, ~0);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitDataSegments(array: ByteArray): void {
    this.growMemoryInitializer();
    var memoryInitializer = this.memoryInitializer;
    var initializerLength = memoryInitializer.length();
    var initialHeapPointer = alignToNextMultipleOf(WASM_MEMORY_INITIALIZER_BASE + initializerLength, 8);

    // Pass the initial heap pointer to the "malloc" function
    ByteArray_set32(memoryInitializer, this.currentHeapPointer, initialHeapPointer);
    ByteArray_set32(memoryInitializer, this.originalHeapPointer, initialHeapPointer);

    var section = wasmStartSection(array, String_new("data_segments"));

    // This only writes one single section containing everything
    wasmWriteVarUnsigned(array, 1);

    // Emit the range of the memory initializer
    wasmWriteVarUnsigned(array, WASM_MEMORY_INITIALIZER_BASE);
    wasmWriteVarUnsigned(array, initializerLength);

    // Copy the entire memory initializer (also includes zero-initialized data for now)
    var i = 0;
    while (i < initializerLength) {
      array.append(memoryInitializer.get(i));
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  prepareToEmit(node: Node): void {
    if (node.kind == NodeKind.STRING) {
      var text = node.stringValue;
      var length = String_length(text);
      var offset = this.context.allocateGlobalVariableOffset(length + 1, 1);;
      this.growMemoryInitializer();
      var memoryInitializer = this.memoryInitializer;
      var i = 0;
      while (i < length) {
        memoryInitializer.set(offset + i, String_get(text, i) as byte);
        i = i + 1;
      }
      memoryInitializer.set(offset + length, 0);
      node.intValue = offset;
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        var sizeOf = symbol.resolvedType.variableSizeOf();
        var value = symbol.node.variableValue().intValue;
        var memoryInitializer = this.memoryInitializer;

        // Copy the inital value into the memory initializer
        this.growMemoryInitializer();
        if (sizeOf == 1) memoryInitializer.set(symbol.offset, value as byte);
        else if (sizeOf == 2) ByteArray_set16(memoryInitializer, symbol.offset, value);
        else if (sizeOf == 4) ByteArray_set32(memoryInitializer, symbol.offset, value);
        else assert(false);

        // Make sure the heap offset is tracked
        if (String_equalNew(symbol.name, "currentHeapPointer")) {
          assert(this.currentHeapPointer == -1);
          this.currentHeapPointer = symbol.offset;
        }

        // Make sure the heap offset is tracked
        else if (String_equalNew(symbol.name, "originalHeapPointer")) {
          assert(this.originalHeapPointer == -1);
          this.originalHeapPointer = symbol.offset;
        }
      }
    }

    else if (node.kind == NodeKind.FUNCTION) {
      var returnType = node.functionReturnType();
      var shared = new WasmSharedOffset();
      var argumentTypesFirst: WasmWrappedType = null;
      var argumentTypesLast: WasmWrappedType = null;

      // Make sure to include the implicit "this" variable as a normal argument
      var argument = node.firstChild;
      while (argument != returnType) {
        var type = wasmWrapType(this.getWasmType(argument.variableType().resolvedType));

        if (argumentTypesFirst == null) argumentTypesFirst = type;
        else argumentTypesLast.next = type;
        argumentTypesLast = type;

        shared.nextLocalOffset = shared.nextLocalOffset + 1;
        argument = argument.nextSibling;
      }
      var signatureIndex = this.allocateSignature(argumentTypesFirst, wasmWrapType(this.getWasmType(returnType.resolvedType)));
      var body = node.functionBody();
      var symbol = node.symbol;

      // Functions without bodies are imports
      if (body == null) {
        var moduleName = symbol.kind == SymbolKind.FUNCTION_INSTANCE ? symbol.parent().name : String_new("globals");
        symbol.offset = this.importCount;
        this.allocateImport(signatureIndex, moduleName, symbol.name);
        node = node.nextSibling;
        return;
      }

      symbol.offset = this.functionCount;
      var fn = this.allocateFunction(symbol.name, signatureIndex, body);

      // Make sure "malloc" is tracked
      if (symbol.kind == SymbolKind.FUNCTION_GLOBAL && String_equalNew(symbol.name, "malloc")) {
        assert(this.mallocFunctionIndex == -1);
        this.mallocFunctionIndex = symbol.offset;
      }

      // Only export "extern" functions
      if (node.isExtern()) {
        fn.isExported = true;
      }

      // Assign local variable offsets
      wasmAssignLocalVariableOffsets(body, shared);
      fn.intLocalCount = shared.intLocalCount;
    }

    var child = node.firstChild;
    while (child != null) {
      this.prepareToEmit(child);
      child = child.nextSibling;
    }
  }

  emitBinaryExpression(array: ByteArray, node: Node, opcode: byte): void {
    array.append(opcode);
    this.emitNode(array, node.binaryLeft());
    this.emitNode(array, node.binaryRight());
  }

  emitLoadFromMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD8_U : WASM_OPCODE_I32_LOAD8_S);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD16_U : WASM_OPCODE_I32_LOAD16_S);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_LOAD);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }
  }

  emitStoreToMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int, value: Node): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(WASM_OPCODE_I32_STORE8);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(WASM_OPCODE_I32_STORE16);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_STORE);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }

    this.emitNode(array, value);
  }

  emitNode(array: ByteArray, node: Node): int {
    assert(!isExpression(node) || node.resolvedType != null);

    if (node.kind == NodeKind.BLOCK) {
      array.append(WASM_OPCODE_BLOCK);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.WHILE) {
      var value = node.whileValue();
      var body = node.whileBody();

      // Ignore "while (false) { ... }"
      if (value.kind == NodeKind.BOOL && value.intValue == 0) {
        return 0;
      }

      array.append(WASM_OPCODE_LOOP);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;

      // Emit the condition as "loop { if (!condition) break; }" as long as it's not a "while (true)" loop
      if (value.kind != NodeKind.BOOL) {
        array.append(WASM_OPCODE_BR_IF);
        wasmWriteVarUnsigned(array, 1); // Break out of the immediately enclosing loop
        array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
        array.append(WASM_OPCODE_I32_EQZ); // The conditional is flipped
        this.emitNode(array, value);
        count = count + 1;
      }

      var child = body.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }

      // Jump back to the top (this doesn't happen automatically)
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, 0); // Continue back to the immediately enclosing loop
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
      count = count + 1;

      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.BREAK || node.kind == NodeKind.CONTINUE) {
      var label = 0;
      var parent = node.parent;

      while (parent != null && parent.kind != NodeKind.WHILE) {
        if (parent.kind == NodeKind.BLOCK) {
          label = label + 1;
        }
        parent = parent.parent;
      }

      assert(label > 0);
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, label - (node.kind == NodeKind.BREAK ? 0 : 1));
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
    }

    else if (node.kind == NodeKind.EMPTY) {
      return 0;
    }

    else if (node.kind == NodeKind.EXPRESSION) {
      this.emitNode(array, node.expressionValue());
    }

    else if (node.kind == NodeKind.RETURN) {
      var value = node.returnValue();
      array.append(WASM_OPCODE_RETURN);
      if (value != null) {
        this.emitNode(array, value);
      }
    }

    else if (node.kind == NodeKind.VARIABLES) {
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        assert(child.kind == NodeKind.VARIABLE);
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      return count;
    }

    else if (node.kind == NodeKind.IF) {
      var branch = node.ifFalse();
      array.append(branch == null ? WASM_OPCODE_IF : WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.ifValue());
      this.emitNode(array, node.ifTrue());
      if (branch != null) {
        this.emitNode(array, branch);
      }
    }

    else if (node.kind == NodeKind.HOOK) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.hookValue());
      this.emitNode(array, node.hookTrue());
      this.emitNode(array, node.hookFalse());
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var value = node.variableValue();

      if (node.symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, node.symbol.offset);

        if (value != null) {
          this.emitNode(array, value);
        }

        // Default initialization
        else {
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, 0);
        }
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NAME) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_GET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitLoadFromMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NULL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.INT || node.kind == NodeKind.BOOL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, node.intValue);
    }

    else if (node.kind == NodeKind.STRING) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, WASM_MEMORY_INITIALIZER_BASE + node.intValue);
    }

    else if (node.kind == NodeKind.CALL) {
      var value = node.callValue();
      var symbol = value.symbol;
      assert(isFunction(symbol.kind));

      array.append(symbol.node.functionBody() == null ? WASM_OPCODE_CALL_IMPORT : WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, symbol.offset);

      // Write out the implicit "this" argument
      if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
        this.emitNode(array, value.dotTarget());
      }

      var child = value.nextSibling;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }
    }

    else if (node.kind == NodeKind.NEW) {
      var type = node.newType();
      assert(type.symbol.kind == SymbolKind.TYPE_CLASS);

      array.append(WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, this.mallocFunctionIndex);

      // Pass the object size as the first argument
      assert(type.symbol.byteSize > 0);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, type.symbol.byteSize);
    }

    else if (node.kind == NodeKind.POSITIVE) {
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NEGATIVE) {
      array.append(WASM_OPCODE_I32_SUB);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.COMPLEMENT) {
      array.append(WASM_OPCODE_I32_XOR);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, ~0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NOT) {
      array.append(WASM_OPCODE_I32_EQZ);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.CAST) {
      var value = node.castValue();
      var context = this.context;
      var from = value.resolvedType.underlyingType(context);
      var type = node.resolvedType.underlyingType(context);

      // The cast isn't needed if it's to a wider integer type
      if (from == type || from.symbol.byteSize < type.symbol.byteSize) {
        this.emitNode(array, value);
      }

      else {
        // Sign-extend
        if (type == context.byteType || type == context.shortType) {
          var shift = 32 - type.symbol.byteSize * 8;
          array.append(WASM_OPCODE_I32_SHR_S);
          array.append(WASM_OPCODE_I32_SHL);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
        }

        // Mask
        else if (type == context.ubyteType || type == context.ushortType) {
          array.append(WASM_OPCODE_I32_AND);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, type.integerBitMask() as int);
        }

        // No cast needed
        else {
          this.emitNode(array, value);
        }
      }
    }

    else if (node.kind == NodeKind.DOT) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitLoadFromMemory(array, symbol.resolvedType, node.dotTarget(), symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.ASSIGN) {
      var left = node.binaryLeft();
      var symbol = left.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitStoreToMemory(array, symbol.resolvedType, left.dotTarget(), symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitStoreToMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
        this.emitNode(array, node.binaryRight());
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.LOGICAL_AND) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      this.emitNode(array, node.binaryRight());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.LOGICAL_OR) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 1);
      this.emitNode(array, node.binaryRight());
    }

    else {
      var isUnsigned = node.isUnsignedOperator();

      if (node.kind == NodeKind.ADD) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_ADD);
      else if (node.kind == NodeKind.BITWISE_AND) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_AND);
      else if (node.kind == NodeKind.BITWISE_OR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_OR);
      else if (node.kind == NodeKind.BITWISE_XOR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_XOR);
      else if (node.kind == NodeKind.EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_EQ);
      else if (node.kind == NodeKind.MULTIPLY) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_MUL);
      else if (node.kind == NodeKind.NOT_EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_NE);
      else if (node.kind == NodeKind.SHIFT_LEFT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SHL);
      else if (node.kind == NodeKind.SUBTRACT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SUB);

      else if (node.kind == NodeKind.DIVIDE) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_DIV_U : WASM_OPCODE_I32_DIV_S);
      else if (node.kind == NodeKind.GREATER_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GT_U : WASM_OPCODE_I32_GT_S);
      else if (node.kind == NodeKind.GREATER_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GE_U : WASM_OPCODE_I32_GE_S);
      else if (node.kind == NodeKind.LESS_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LT_U : WASM_OPCODE_I32_LT_S);
      else if (node.kind == NodeKind.LESS_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LE_U : WASM_OPCODE_I32_LE_S);
      else if (node.kind == NodeKind.REMAINDER) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_REM_U : WASM_OPCODE_I32_REM_S);
      else if (node.kind == NodeKind.SHIFT_RIGHT) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_SHR_U : WASM_OPCODE_I32_SHR_S);

      else {
        assert(false);
      }
    }

    return 1;
  }

  getWasmType(type: Type): WasmType {
    var context = this.context;

    if (type == context.boolType || type.isInteger() || type.isReference(context)) {
      return WasmType.I32;
    }

    if (type == context.voidType) {
      return WasmType.VOID;
    }

    assert(false);
    return WasmType.VOID;
  }
}

class WasmModule4 {
  firstImport: WasmImport;
  lastImport: WasmImport;
  importCount: int;

  firstFunction: WasmFunction;
  lastFunction: WasmFunction;
  functionCount: int;

  firstSignature: WasmSignature;
  lastSignature: WasmSignature;
  signatureCount: int;

  memoryInitializer: ByteArray;
  currentHeapPointer: int;
  originalHeapPointer: int;
  mallocFunctionIndex: int;
  context: CheckContext;

  growMemoryInitializer(): void {
    var array = this.memoryInitializer;
    var current = array.length();
    var length = this.context.nextGlobalVariableOffset;

    while (current < length) {
      array.append(0);
      current = current + 1;
    }
  }

  allocateImport(signatureIndex: int, mod: String, name: String): WasmImport {
    var result = new WasmImport();
    result.signatureIndex = signatureIndex;
    result.module = mod;
    result.name = name;

    if (this.firstImport == null) this.firstImport = result;
    else this.lastImport.next = result;
    this.lastImport = result;

    this.importCount = this.importCount + 1;
    return result;
  }

  allocateFunction(name: String, signatureIndex: int, body: Node): WasmFunction {
    var fn = new WasmFunction();
    fn.name = name;
    fn.signatureIndex = signatureIndex;
    fn.body = body;

    if (this.firstFunction == null) this.firstFunction = fn;
    else this.lastFunction.next = fn;
    this.lastFunction = fn;

    this.functionCount = this.functionCount + 1;
    return fn;
  }

  allocateSignature(argumentTypes: WasmWrappedType, returnType: WasmWrappedType): int {
    assert(returnType != null);
    assert(returnType.next == null);

    var signature = new WasmSignature();
    signature.argumentTypes = argumentTypes;
    signature.returnType = returnType;

    var check = this.firstSignature;
    var i = 0;

    while (check != null) {
      if (wasmAreSignaturesEqual(signature, check)) {
        return i;
      }

      check = check.next;
      i = i + 1;
    }

    if (this.firstSignature == null) this.firstSignature = signature;
    else this.lastSignature.next = signature;
    this.lastSignature = signature;

    this.signatureCount = this.signatureCount + 1;
    return i;
  }

  emitModule(array: ByteArray): void {
    ByteArray_append32(array, WASM_MAGIC);
    ByteArray_append32(array, WASM_VERSION);

    this.emitSignatures(array);
    this.emitImportTable(array);
    this.emitFunctionSignatures(array);
    this.emitMemory(array);
    this.emitExportTable(array);
    this.emitFunctionBodies(array);
    this.emitDataSegments(array);
  }

  emitSignatures(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("signatures"));
    wasmWriteVarUnsigned(array, this.signatureCount);

    var signature = this.firstSignature;
    while (signature != null) {
      var count = 0;
      var type = signature.argumentTypes;

      while (type != null) {
        count = count + 1;
        type = type.next;
      }

      wasmWriteVarUnsigned(array, count);
      wasmWriteVarUnsigned(array, signature.returnType.id as int);

      type = signature.argumentTypes;
      while (type != null) {
        wasmWriteVarUnsigned(array, type.id as int);
        type = type.next;
      }

      signature = signature.next;
    }

    wasmFinishSection(array, section);
  }

  emitImportTable(array: ByteArray): void {
    if (this.firstImport == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("import_table"));
    wasmWriteVarUnsigned(array, this.importCount);

    var current = this.firstImport;
    while (current != null) {
      wasmWriteVarUnsigned(array, current.signatureIndex);
      wasmWriteLengthPrefixedString(array, current.module);
      wasmWriteLengthPrefixedString(array, current.name);
      current = current.next;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionSignatures(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_signatures"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      wasmWriteVarUnsigned(array, fn.signatureIndex);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitMemory(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("memory"));
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, 1); // The memory array is exported
    wasmFinishSection(array, section);
  }

  emitExportTable(array: ByteArray): void {
    var exportedCount = 0;
    var fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        exportedCount = exportedCount + 1;
      }
      fn = fn.next;
    }
    if (exportedCount == 0) {
      return;
    }

    var section = wasmStartSection(array, String_new("export_table"));
    wasmWriteVarUnsigned(array, exportedCount);

    var i = 0;
    fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        wasmWriteVarUnsigned(array, i);
        wasmWriteLengthPrefixedString(array, fn.name);
      }
      fn = fn.next;
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionBodies(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_bodies"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      var bodyLength = array.length();
      wasmWriteVarUnsigned(array, ~0); // This will be patched later

      if (fn.intLocalCount > 0) {
        wasmWriteVarUnsigned(array, 1);
        wasmWriteVarUnsigned(array, fn.intLocalCount);
        array.append(WasmType.I32);
      } else {
        wasmWriteVarUnsigned(array, 0);
      }

      var child = fn.body.firstChild;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }

      wasmPatchVarUnsigned(array, bodyLength, array.length() - bodyLength - 5, ~0);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitDataSegments(array: ByteArray): void {
    this.growMemoryInitializer();
    var memoryInitializer = this.memoryInitializer;
    var initializerLength = memoryInitializer.length();
    var initialHeapPointer = alignToNextMultipleOf(WASM_MEMORY_INITIALIZER_BASE + initializerLength, 8);

    // Pass the initial heap pointer to the "malloc" function
    ByteArray_set32(memoryInitializer, this.currentHeapPointer, initialHeapPointer);
    ByteArray_set32(memoryInitializer, this.originalHeapPointer, initialHeapPointer);

    var section = wasmStartSection(array, String_new("data_segments"));

    // This only writes one single section containing everything
    wasmWriteVarUnsigned(array, 1);

    // Emit the range of the memory initializer
    wasmWriteVarUnsigned(array, WASM_MEMORY_INITIALIZER_BASE);
    wasmWriteVarUnsigned(array, initializerLength);

    // Copy the entire memory initializer (also includes zero-initialized data for now)
    var i = 0;
    while (i < initializerLength) {
      array.append(memoryInitializer.get(i));
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  prepareToEmit(node: Node): void {
    if (node.kind == NodeKind.STRING) {
      var text = node.stringValue;
      var length = String_length(text);
      var offset = this.context.allocateGlobalVariableOffset(length + 1, 1);;
      this.growMemoryInitializer();
      var memoryInitializer = this.memoryInitializer;
      var i = 0;
      while (i < length) {
        memoryInitializer.set(offset + i, String_get(text, i) as byte);
        i = i + 1;
      }
      memoryInitializer.set(offset + length, 0);
      node.intValue = offset;
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        var sizeOf = symbol.resolvedType.variableSizeOf();
        var value = symbol.node.variableValue().intValue;
        var memoryInitializer = this.memoryInitializer;

        // Copy the inital value into the memory initializer
        this.growMemoryInitializer();
        if (sizeOf == 1) memoryInitializer.set(symbol.offset, value as byte);
        else if (sizeOf == 2) ByteArray_set16(memoryInitializer, symbol.offset, value);
        else if (sizeOf == 4) ByteArray_set32(memoryInitializer, symbol.offset, value);
        else assert(false);

        // Make sure the heap offset is tracked
        if (String_equalNew(symbol.name, "currentHeapPointer")) {
          assert(this.currentHeapPointer == -1);
          this.currentHeapPointer = symbol.offset;
        }

        // Make sure the heap offset is tracked
        else if (String_equalNew(symbol.name, "originalHeapPointer")) {
          assert(this.originalHeapPointer == -1);
          this.originalHeapPointer = symbol.offset;
        }
      }
    }

    else if (node.kind == NodeKind.FUNCTION) {
      var returnType = node.functionReturnType();
      var shared = new WasmSharedOffset();
      var argumentTypesFirst: WasmWrappedType = null;
      var argumentTypesLast: WasmWrappedType = null;

      // Make sure to include the implicit "this" variable as a normal argument
      var argument = node.firstChild;
      while (argument != returnType) {
        var type = wasmWrapType(this.getWasmType(argument.variableType().resolvedType));

        if (argumentTypesFirst == null) argumentTypesFirst = type;
        else argumentTypesLast.next = type;
        argumentTypesLast = type;

        shared.nextLocalOffset = shared.nextLocalOffset + 1;
        argument = argument.nextSibling;
      }
      var signatureIndex = this.allocateSignature(argumentTypesFirst, wasmWrapType(this.getWasmType(returnType.resolvedType)));
      var body = node.functionBody();
      var symbol = node.symbol;

      // Functions without bodies are imports
      if (body == null) {
        var moduleName = symbol.kind == SymbolKind.FUNCTION_INSTANCE ? symbol.parent().name : String_new("globals");
        symbol.offset = this.importCount;
        this.allocateImport(signatureIndex, moduleName, symbol.name);
        node = node.nextSibling;
        return;
      }

      symbol.offset = this.functionCount;
      var fn = this.allocateFunction(symbol.name, signatureIndex, body);

      // Make sure "malloc" is tracked
      if (symbol.kind == SymbolKind.FUNCTION_GLOBAL && String_equalNew(symbol.name, "malloc")) {
        assert(this.mallocFunctionIndex == -1);
        this.mallocFunctionIndex = symbol.offset;
      }

      // Only export "extern" functions
      if (node.isExtern()) {
        fn.isExported = true;
      }

      // Assign local variable offsets
      wasmAssignLocalVariableOffsets(body, shared);
      fn.intLocalCount = shared.intLocalCount;
    }

    var child = node.firstChild;
    while (child != null) {
      this.prepareToEmit(child);
      child = child.nextSibling;
    }
  }

  emitBinaryExpression(array: ByteArray, node: Node, opcode: byte): void {
    array.append(opcode);
    this.emitNode(array, node.binaryLeft());
    this.emitNode(array, node.binaryRight());
  }

  emitLoadFromMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD8_U : WASM_OPCODE_I32_LOAD8_S);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD16_U : WASM_OPCODE_I32_LOAD16_S);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_LOAD);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }
  }

  emitStoreToMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int, value: Node): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(WASM_OPCODE_I32_STORE8);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(WASM_OPCODE_I32_STORE16);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_STORE);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }

    this.emitNode(array, value);
  }

  emitNode(array: ByteArray, node: Node): int {
    assert(!isExpression(node) || node.resolvedType != null);

    if (node.kind == NodeKind.BLOCK) {
      array.append(WASM_OPCODE_BLOCK);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.WHILE) {
      var value = node.whileValue();
      var body = node.whileBody();

      // Ignore "while (false) { ... }"
      if (value.kind == NodeKind.BOOL && value.intValue == 0) {
        return 0;
      }

      array.append(WASM_OPCODE_LOOP);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;

      // Emit the condition as "loop { if (!condition) break; }" as long as it's not a "while (true)" loop
      if (value.kind != NodeKind.BOOL) {
        array.append(WASM_OPCODE_BR_IF);
        wasmWriteVarUnsigned(array, 1); // Break out of the immediately enclosing loop
        array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
        array.append(WASM_OPCODE_I32_EQZ); // The conditional is flipped
        this.emitNode(array, value);
        count = count + 1;
      }

      var child = body.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }

      // Jump back to the top (this doesn't happen automatically)
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, 0); // Continue back to the immediately enclosing loop
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
      count = count + 1;

      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.BREAK || node.kind == NodeKind.CONTINUE) {
      var label = 0;
      var parent = node.parent;

      while (parent != null && parent.kind != NodeKind.WHILE) {
        if (parent.kind == NodeKind.BLOCK) {
          label = label + 1;
        }
        parent = parent.parent;
      }

      assert(label > 0);
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, label - (node.kind == NodeKind.BREAK ? 0 : 1));
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
    }

    else if (node.kind == NodeKind.EMPTY) {
      return 0;
    }

    else if (node.kind == NodeKind.EXPRESSION) {
      this.emitNode(array, node.expressionValue());
    }

    else if (node.kind == NodeKind.RETURN) {
      var value = node.returnValue();
      array.append(WASM_OPCODE_RETURN);
      if (value != null) {
        this.emitNode(array, value);
      }
    }

    else if (node.kind == NodeKind.VARIABLES) {
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        assert(child.kind == NodeKind.VARIABLE);
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      return count;
    }

    else if (node.kind == NodeKind.IF) {
      var branch = node.ifFalse();
      array.append(branch == null ? WASM_OPCODE_IF : WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.ifValue());
      this.emitNode(array, node.ifTrue());
      if (branch != null) {
        this.emitNode(array, branch);
      }
    }

    else if (node.kind == NodeKind.HOOK) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.hookValue());
      this.emitNode(array, node.hookTrue());
      this.emitNode(array, node.hookFalse());
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var value = node.variableValue();

      if (node.symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, node.symbol.offset);

        if (value != null) {
          this.emitNode(array, value);
        }

        // Default initialization
        else {
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, 0);
        }
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NAME) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_GET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitLoadFromMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NULL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.INT || node.kind == NodeKind.BOOL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, node.intValue);
    }

    else if (node.kind == NodeKind.STRING) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, WASM_MEMORY_INITIALIZER_BASE + node.intValue);
    }

    else if (node.kind == NodeKind.CALL) {
      var value = node.callValue();
      var symbol = value.symbol;
      assert(isFunction(symbol.kind));

      array.append(symbol.node.functionBody() == null ? WASM_OPCODE_CALL_IMPORT : WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, symbol.offset);

      // Write out the implicit "this" argument
      if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
        this.emitNode(array, value.dotTarget());
      }

      var child = value.nextSibling;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }
    }

    else if (node.kind == NodeKind.NEW) {
      var type = node.newType();
      assert(type.symbol.kind == SymbolKind.TYPE_CLASS);

      array.append(WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, this.mallocFunctionIndex);

      // Pass the object size as the first argument
      assert(type.symbol.byteSize > 0);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, type.symbol.byteSize);
    }

    else if (node.kind == NodeKind.POSITIVE) {
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NEGATIVE) {
      array.append(WASM_OPCODE_I32_SUB);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.COMPLEMENT) {
      array.append(WASM_OPCODE_I32_XOR);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, ~0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NOT) {
      array.append(WASM_OPCODE_I32_EQZ);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.CAST) {
      var value = node.castValue();
      var context = this.context;
      var from = value.resolvedType.underlyingType(context);
      var type = node.resolvedType.underlyingType(context);

      // The cast isn't needed if it's to a wider integer type
      if (from == type || from.symbol.byteSize < type.symbol.byteSize) {
        this.emitNode(array, value);
      }

      else {
        // Sign-extend
        if (type == context.byteType || type == context.shortType) {
          var shift = 32 - type.symbol.byteSize * 8;
          array.append(WASM_OPCODE_I32_SHR_S);
          array.append(WASM_OPCODE_I32_SHL);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
        }

        // Mask
        else if (type == context.ubyteType || type == context.ushortType) {
          array.append(WASM_OPCODE_I32_AND);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, type.integerBitMask() as int);
        }

        // No cast needed
        else {
          this.emitNode(array, value);
        }
      }
    }

    else if (node.kind == NodeKind.DOT) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitLoadFromMemory(array, symbol.resolvedType, node.dotTarget(), symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.ASSIGN) {
      var left = node.binaryLeft();
      var symbol = left.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitStoreToMemory(array, symbol.resolvedType, left.dotTarget(), symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitStoreToMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
        this.emitNode(array, node.binaryRight());
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.LOGICAL_AND) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      this.emitNode(array, node.binaryRight());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.LOGICAL_OR) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 1);
      this.emitNode(array, node.binaryRight());
    }

    else {
      var isUnsigned = node.isUnsignedOperator();

      if (node.kind == NodeKind.ADD) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_ADD);
      else if (node.kind == NodeKind.BITWISE_AND) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_AND);
      else if (node.kind == NodeKind.BITWISE_OR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_OR);
      else if (node.kind == NodeKind.BITWISE_XOR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_XOR);
      else if (node.kind == NodeKind.EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_EQ);
      else if (node.kind == NodeKind.MULTIPLY) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_MUL);
      else if (node.kind == NodeKind.NOT_EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_NE);
      else if (node.kind == NodeKind.SHIFT_LEFT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SHL);
      else if (node.kind == NodeKind.SUBTRACT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SUB);

      else if (node.kind == NodeKind.DIVIDE) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_DIV_U : WASM_OPCODE_I32_DIV_S);
      else if (node.kind == NodeKind.GREATER_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GT_U : WASM_OPCODE_I32_GT_S);
      else if (node.kind == NodeKind.GREATER_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GE_U : WASM_OPCODE_I32_GE_S);
      else if (node.kind == NodeKind.LESS_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LT_U : WASM_OPCODE_I32_LT_S);
      else if (node.kind == NodeKind.LESS_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LE_U : WASM_OPCODE_I32_LE_S);
      else if (node.kind == NodeKind.REMAINDER) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_REM_U : WASM_OPCODE_I32_REM_S);
      else if (node.kind == NodeKind.SHIFT_RIGHT) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_SHR_U : WASM_OPCODE_I32_SHR_S);

      else {
        assert(false);
      }
    }

    return 1;
  }

  getWasmType(type: Type): WasmType {
    var context = this.context;

    if (type == context.boolType || type.isInteger() || type.isReference(context)) {
      return WasmType.I32;
    }

    if (type == context.voidType) {
      return WasmType.VOID;
    }

    assert(false);
    return WasmType.VOID;
  }
}
class WasmModule5 {
  firstImport: WasmImport;
  lastImport: WasmImport;
  importCount: int;

  firstFunction: WasmFunction;
  lastFunction: WasmFunction;
  functionCount: int;

  firstSignature: WasmSignature;
  lastSignature: WasmSignature;
  signatureCount: int;

  memoryInitializer: ByteArray;
  currentHeapPointer: int;
  originalHeapPointer: int;
  mallocFunctionIndex: int;
  context: CheckContext;

  growMemoryInitializer(): void {
    var array = this.memoryInitializer;
    var current = array.length();
    var length = this.context.nextGlobalVariableOffset;

    while (current < length) {
      array.append(0);
      current = current + 1;
    }
  }

  allocateImport(signatureIndex: int, mod: String, name: String): WasmImport {
    var result = new WasmImport();
    result.signatureIndex = signatureIndex;
    result.module = mod;
    result.name = name;

    if (this.firstImport == null) this.firstImport = result;
    else this.lastImport.next = result;
    this.lastImport = result;

    this.importCount = this.importCount + 1;
    return result;
  }

  allocateFunction(name: String, signatureIndex: int, body: Node): WasmFunction {
    var fn = new WasmFunction();
    fn.name = name;
    fn.signatureIndex = signatureIndex;
    fn.body = body;

    if (this.firstFunction == null) this.firstFunction = fn;
    else this.lastFunction.next = fn;
    this.lastFunction = fn;

    this.functionCount = this.functionCount + 1;
    return fn;
  }

  allocateSignature(argumentTypes: WasmWrappedType, returnType: WasmWrappedType): int {
    assert(returnType != null);
    assert(returnType.next == null);

    var signature = new WasmSignature();
    signature.argumentTypes = argumentTypes;
    signature.returnType = returnType;

    var check = this.firstSignature;
    var i = 0;

    while (check != null) {
      if (wasmAreSignaturesEqual(signature, check)) {
        return i;
      }

      check = check.next;
      i = i + 1;
    }

    if (this.firstSignature == null) this.firstSignature = signature;
    else this.lastSignature.next = signature;
    this.lastSignature = signature;

    this.signatureCount = this.signatureCount + 1;
    return i;
  }

  emitModule(array: ByteArray): void {
    ByteArray_append32(array, WASM_MAGIC);
    ByteArray_append32(array, WASM_VERSION);

    this.emitSignatures(array);
    this.emitImportTable(array);
    this.emitFunctionSignatures(array);
    this.emitMemory(array);
    this.emitExportTable(array);
    this.emitFunctionBodies(array);
    this.emitDataSegments(array);
  }

  emitSignatures(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("signatures"));
    wasmWriteVarUnsigned(array, this.signatureCount);

    var signature = this.firstSignature;
    while (signature != null) {
      var count = 0;
      var type = signature.argumentTypes;

      while (type != null) {
        count = count + 1;
        type = type.next;
      }

      wasmWriteVarUnsigned(array, count);
      wasmWriteVarUnsigned(array, signature.returnType.id as int);

      type = signature.argumentTypes;
      while (type != null) {
        wasmWriteVarUnsigned(array, type.id as int);
        type = type.next;
      }

      signature = signature.next;
    }

    wasmFinishSection(array, section);
  }

  emitImportTable(array: ByteArray): void {
    if (this.firstImport == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("import_table"));
    wasmWriteVarUnsigned(array, this.importCount);

    var current = this.firstImport;
    while (current != null) {
      wasmWriteVarUnsigned(array, current.signatureIndex);
      wasmWriteLengthPrefixedString(array, current.module);
      wasmWriteLengthPrefixedString(array, current.name);
      current = current.next;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionSignatures(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_signatures"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      wasmWriteVarUnsigned(array, fn.signatureIndex);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitMemory(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("memory"));
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, 1); // The memory array is exported
    wasmFinishSection(array, section);
  }

  emitExportTable(array: ByteArray): void {
    var exportedCount = 0;
    var fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        exportedCount = exportedCount + 1;
      }
      fn = fn.next;
    }
    if (exportedCount == 0) {
      return;
    }

    var section = wasmStartSection(array, String_new("export_table"));
    wasmWriteVarUnsigned(array, exportedCount);

    var i = 0;
    fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        wasmWriteVarUnsigned(array, i);
        wasmWriteLengthPrefixedString(array, fn.name);
      }
      fn = fn.next;
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionBodies(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_bodies"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      var bodyLength = array.length();
      wasmWriteVarUnsigned(array, ~0); // This will be patched later

      if (fn.intLocalCount > 0) {
        wasmWriteVarUnsigned(array, 1);
        wasmWriteVarUnsigned(array, fn.intLocalCount);
        array.append(WasmType.I32);
      } else {
        wasmWriteVarUnsigned(array, 0);
      }

      var child = fn.body.firstChild;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }

      wasmPatchVarUnsigned(array, bodyLength, array.length() - bodyLength - 5, ~0);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitDataSegments(array: ByteArray): void {
    this.growMemoryInitializer();
    var memoryInitializer = this.memoryInitializer;
    var initializerLength = memoryInitializer.length();
    var initialHeapPointer = alignToNextMultipleOf(WASM_MEMORY_INITIALIZER_BASE + initializerLength, 8);

    // Pass the initial heap pointer to the "malloc" function
    ByteArray_set32(memoryInitializer, this.currentHeapPointer, initialHeapPointer);
    ByteArray_set32(memoryInitializer, this.originalHeapPointer, initialHeapPointer);

    var section = wasmStartSection(array, String_new("data_segments"));

    // This only writes one single section containing everything
    wasmWriteVarUnsigned(array, 1);

    // Emit the range of the memory initializer
    wasmWriteVarUnsigned(array, WASM_MEMORY_INITIALIZER_BASE);
    wasmWriteVarUnsigned(array, initializerLength);

    // Copy the entire memory initializer (also includes zero-initialized data for now)
    var i = 0;
    while (i < initializerLength) {
      array.append(memoryInitializer.get(i));
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  prepareToEmit(node: Node): void {
    if (node.kind == NodeKind.STRING) {
      var text = node.stringValue;
      var length = String_length(text);
      var offset = this.context.allocateGlobalVariableOffset(length + 1, 1);;
      this.growMemoryInitializer();
      var memoryInitializer = this.memoryInitializer;
      var i = 0;
      while (i < length) {
        memoryInitializer.set(offset + i, String_get(text, i) as byte);
        i = i + 1;
      }
      memoryInitializer.set(offset + length, 0);
      node.intValue = offset;
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        var sizeOf = symbol.resolvedType.variableSizeOf();
        var value = symbol.node.variableValue().intValue;
        var memoryInitializer = this.memoryInitializer;

        // Copy the inital value into the memory initializer
        this.growMemoryInitializer();
        if (sizeOf == 1) memoryInitializer.set(symbol.offset, value as byte);
        else if (sizeOf == 2) ByteArray_set16(memoryInitializer, symbol.offset, value);
        else if (sizeOf == 4) ByteArray_set32(memoryInitializer, symbol.offset, value);
        else assert(false);

        // Make sure the heap offset is tracked
        if (String_equalNew(symbol.name, "currentHeapPointer")) {
          assert(this.currentHeapPointer == -1);
          this.currentHeapPointer = symbol.offset;
        }

        // Make sure the heap offset is tracked
        else if (String_equalNew(symbol.name, "originalHeapPointer")) {
          assert(this.originalHeapPointer == -1);
          this.originalHeapPointer = symbol.offset;
        }
      }
    }

    else if (node.kind == NodeKind.FUNCTION) {
      var returnType = node.functionReturnType();
      var shared = new WasmSharedOffset();
      var argumentTypesFirst: WasmWrappedType = null;
      var argumentTypesLast: WasmWrappedType = null;

      // Make sure to include the implicit "this" variable as a normal argument
      var argument = node.firstChild;
      while (argument != returnType) {
        var type = wasmWrapType(this.getWasmType(argument.variableType().resolvedType));

        if (argumentTypesFirst == null) argumentTypesFirst = type;
        else argumentTypesLast.next = type;
        argumentTypesLast = type;

        shared.nextLocalOffset = shared.nextLocalOffset + 1;
        argument = argument.nextSibling;
      }
      var signatureIndex = this.allocateSignature(argumentTypesFirst, wasmWrapType(this.getWasmType(returnType.resolvedType)));
      var body = node.functionBody();
      var symbol = node.symbol;

      // Functions without bodies are imports
      if (body == null) {
        var moduleName = symbol.kind == SymbolKind.FUNCTION_INSTANCE ? symbol.parent().name : String_new("globals");
        symbol.offset = this.importCount;
        this.allocateImport(signatureIndex, moduleName, symbol.name);
        node = node.nextSibling;
        return;
      }

      symbol.offset = this.functionCount;
      var fn = this.allocateFunction(symbol.name, signatureIndex, body);

      // Make sure "malloc" is tracked
      if (symbol.kind == SymbolKind.FUNCTION_GLOBAL && String_equalNew(symbol.name, "malloc")) {
        assert(this.mallocFunctionIndex == -1);
        this.mallocFunctionIndex = symbol.offset;
      }

      // Only export "extern" functions
      if (node.isExtern()) {
        fn.isExported = true;
      }

      // Assign local variable offsets
      wasmAssignLocalVariableOffsets(body, shared);
      fn.intLocalCount = shared.intLocalCount;
    }

    var child = node.firstChild;
    while (child != null) {
      this.prepareToEmit(child);
      child = child.nextSibling;
    }
  }

  emitBinaryExpression(array: ByteArray, node: Node, opcode: byte): void {
    array.append(opcode);
    this.emitNode(array, node.binaryLeft());
    this.emitNode(array, node.binaryRight());
  }

  emitLoadFromMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD8_U : WASM_OPCODE_I32_LOAD8_S);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD16_U : WASM_OPCODE_I32_LOAD16_S);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_LOAD);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }
  }

  emitStoreToMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int, value: Node): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(WASM_OPCODE_I32_STORE8);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(WASM_OPCODE_I32_STORE16);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_STORE);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }

    this.emitNode(array, value);
  }

  emitNode(array: ByteArray, node: Node): int {
    assert(!isExpression(node) || node.resolvedType != null);

    if (node.kind == NodeKind.BLOCK) {
      array.append(WASM_OPCODE_BLOCK);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.WHILE) {
      var value = node.whileValue();
      var body = node.whileBody();

      // Ignore "while (false) { ... }"
      if (value.kind == NodeKind.BOOL && value.intValue == 0) {
        return 0;
      }

      array.append(WASM_OPCODE_LOOP);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;

      // Emit the condition as "loop { if (!condition) break; }" as long as it's not a "while (true)" loop
      if (value.kind != NodeKind.BOOL) {
        array.append(WASM_OPCODE_BR_IF);
        wasmWriteVarUnsigned(array, 1); // Break out of the immediately enclosing loop
        array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
        array.append(WASM_OPCODE_I32_EQZ); // The conditional is flipped
        this.emitNode(array, value);
        count = count + 1;
      }

      var child = body.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }

      // Jump back to the top (this doesn't happen automatically)
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, 0); // Continue back to the immediately enclosing loop
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
      count = count + 1;

      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.BREAK || node.kind == NodeKind.CONTINUE) {
      var label = 0;
      var parent = node.parent;

      while (parent != null && parent.kind != NodeKind.WHILE) {
        if (parent.kind == NodeKind.BLOCK) {
          label = label + 1;
        }
        parent = parent.parent;
      }

      assert(label > 0);
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, label - (node.kind == NodeKind.BREAK ? 0 : 1));
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
    }

    else if (node.kind == NodeKind.EMPTY) {
      return 0;
    }

    else if (node.kind == NodeKind.EXPRESSION) {
      this.emitNode(array, node.expressionValue());
    }

    else if (node.kind == NodeKind.RETURN) {
      var value = node.returnValue();
      array.append(WASM_OPCODE_RETURN);
      if (value != null) {
        this.emitNode(array, value);
      }
    }

    else if (node.kind == NodeKind.VARIABLES) {
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        assert(child.kind == NodeKind.VARIABLE);
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      return count;
    }

    else if (node.kind == NodeKind.IF) {
      var branch = node.ifFalse();
      array.append(branch == null ? WASM_OPCODE_IF : WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.ifValue());
      this.emitNode(array, node.ifTrue());
      if (branch != null) {
        this.emitNode(array, branch);
      }
    }

    else if (node.kind == NodeKind.HOOK) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.hookValue());
      this.emitNode(array, node.hookTrue());
      this.emitNode(array, node.hookFalse());
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var value = node.variableValue();

      if (node.symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, node.symbol.offset);

        if (value != null) {
          this.emitNode(array, value);
        }

        // Default initialization
        else {
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, 0);
        }
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NAME) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_GET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitLoadFromMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NULL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.INT || node.kind == NodeKind.BOOL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, node.intValue);
    }

    else if (node.kind == NodeKind.STRING) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, WASM_MEMORY_INITIALIZER_BASE + node.intValue);
    }

    else if (node.kind == NodeKind.CALL) {
      var value = node.callValue();
      var symbol = value.symbol;
      assert(isFunction(symbol.kind));

      array.append(symbol.node.functionBody() == null ? WASM_OPCODE_CALL_IMPORT : WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, symbol.offset);

      // Write out the implicit "this" argument
      if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
        this.emitNode(array, value.dotTarget());
      }

      var child = value.nextSibling;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }
    }

    else if (node.kind == NodeKind.NEW) {
      var type = node.newType();
      assert(type.symbol.kind == SymbolKind.TYPE_CLASS);

      array.append(WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, this.mallocFunctionIndex);

      // Pass the object size as the first argument
      assert(type.symbol.byteSize > 0);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, type.symbol.byteSize);
    }

    else if (node.kind == NodeKind.POSITIVE) {
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NEGATIVE) {
      array.append(WASM_OPCODE_I32_SUB);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.COMPLEMENT) {
      array.append(WASM_OPCODE_I32_XOR);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, ~0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NOT) {
      array.append(WASM_OPCODE_I32_EQZ);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.CAST) {
      var value = node.castValue();
      var context = this.context;
      var from = value.resolvedType.underlyingType(context);
      var type = node.resolvedType.underlyingType(context);

      // The cast isn't needed if it's to a wider integer type
      if (from == type || from.symbol.byteSize < type.symbol.byteSize) {
        this.emitNode(array, value);
      }

      else {
        // Sign-extend
        if (type == context.byteType || type == context.shortType) {
          var shift = 32 - type.symbol.byteSize * 8;
          array.append(WASM_OPCODE_I32_SHR_S);
          array.append(WASM_OPCODE_I32_SHL);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
        }

        // Mask
        else if (type == context.ubyteType || type == context.ushortType) {
          array.append(WASM_OPCODE_I32_AND);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, type.integerBitMask() as int);
        }

        // No cast needed
        else {
          this.emitNode(array, value);
        }
      }
    }

    else if (node.kind == NodeKind.DOT) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitLoadFromMemory(array, symbol.resolvedType, node.dotTarget(), symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.ASSIGN) {
      var left = node.binaryLeft();
      var symbol = left.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitStoreToMemory(array, symbol.resolvedType, left.dotTarget(), symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitStoreToMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
        this.emitNode(array, node.binaryRight());
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.LOGICAL_AND) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      this.emitNode(array, node.binaryRight());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.LOGICAL_OR) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 1);
      this.emitNode(array, node.binaryRight());
    }

    else {
      var isUnsigned = node.isUnsignedOperator();

      if (node.kind == NodeKind.ADD) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_ADD);
      else if (node.kind == NodeKind.BITWISE_AND) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_AND);
      else if (node.kind == NodeKind.BITWISE_OR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_OR);
      else if (node.kind == NodeKind.BITWISE_XOR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_XOR);
      else if (node.kind == NodeKind.EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_EQ);
      else if (node.kind == NodeKind.MULTIPLY) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_MUL);
      else if (node.kind == NodeKind.NOT_EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_NE);
      else if (node.kind == NodeKind.SHIFT_LEFT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SHL);
      else if (node.kind == NodeKind.SUBTRACT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SUB);

      else if (node.kind == NodeKind.DIVIDE) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_DIV_U : WASM_OPCODE_I32_DIV_S);
      else if (node.kind == NodeKind.GREATER_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GT_U : WASM_OPCODE_I32_GT_S);
      else if (node.kind == NodeKind.GREATER_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GE_U : WASM_OPCODE_I32_GE_S);
      else if (node.kind == NodeKind.LESS_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LT_U : WASM_OPCODE_I32_LT_S);
      else if (node.kind == NodeKind.LESS_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LE_U : WASM_OPCODE_I32_LE_S);
      else if (node.kind == NodeKind.REMAINDER) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_REM_U : WASM_OPCODE_I32_REM_S);
      else if (node.kind == NodeKind.SHIFT_RIGHT) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_SHR_U : WASM_OPCODE_I32_SHR_S);

      else {
        assert(false);
      }
    }

    return 1;
  }

  getWasmType(type: Type): WasmType {
    var context = this.context;

    if (type == context.boolType || type.isInteger() || type.isReference(context)) {
      return WasmType.I32;
    }

    if (type == context.voidType) {
      return WasmType.VOID;
    }

    assert(false);
    return WasmType.VOID;
  }
}
class WasmModule6 {
  firstImport: WasmImport;
  lastImport: WasmImport;
  importCount: int;

  firstFunction: WasmFunction;
  lastFunction: WasmFunction;
  functionCount: int;

  firstSignature: WasmSignature;
  lastSignature: WasmSignature;
  signatureCount: int;

  memoryInitializer: ByteArray;
  currentHeapPointer: int;
  originalHeapPointer: int;
  mallocFunctionIndex: int;
  context: CheckContext;

  growMemoryInitializer(): void {
    var array = this.memoryInitializer;
    var current = array.length();
    var length = this.context.nextGlobalVariableOffset;

    while (current < length) {
      array.append(0);
      current = current + 1;
    }
  }

  allocateImport(signatureIndex: int, mod: String, name: String): WasmImport {
    var result = new WasmImport();
    result.signatureIndex = signatureIndex;
    result.module = mod;
    result.name = name;

    if (this.firstImport == null) this.firstImport = result;
    else this.lastImport.next = result;
    this.lastImport = result;

    this.importCount = this.importCount + 1;
    return result;
  }

  allocateFunction(name: String, signatureIndex: int, body: Node): WasmFunction {
    var fn = new WasmFunction();
    fn.name = name;
    fn.signatureIndex = signatureIndex;
    fn.body = body;

    if (this.firstFunction == null) this.firstFunction = fn;
    else this.lastFunction.next = fn;
    this.lastFunction = fn;

    this.functionCount = this.functionCount + 1;
    return fn;
  }

  allocateSignature(argumentTypes: WasmWrappedType, returnType: WasmWrappedType): int {
    assert(returnType != null);
    assert(returnType.next == null);

    var signature = new WasmSignature();
    signature.argumentTypes = argumentTypes;
    signature.returnType = returnType;

    var check = this.firstSignature;
    var i = 0;

    while (check != null) {
      if (wasmAreSignaturesEqual(signature, check)) {
        return i;
      }

      check = check.next;
      i = i + 1;
    }

    if (this.firstSignature == null) this.firstSignature = signature;
    else this.lastSignature.next = signature;
    this.lastSignature = signature;

    this.signatureCount = this.signatureCount + 1;
    return i;
  }

  emitModule(array: ByteArray): void {
    ByteArray_append32(array, WASM_MAGIC);
    ByteArray_append32(array, WASM_VERSION);

    this.emitSignatures(array);
    this.emitImportTable(array);
    this.emitFunctionSignatures(array);
    this.emitMemory(array);
    this.emitExportTable(array);
    this.emitFunctionBodies(array);
    this.emitDataSegments(array);
  }

  emitSignatures(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("signatures"));
    wasmWriteVarUnsigned(array, this.signatureCount);

    var signature = this.firstSignature;
    while (signature != null) {
      var count = 0;
      var type = signature.argumentTypes;

      while (type != null) {
        count = count + 1;
        type = type.next;
      }

      wasmWriteVarUnsigned(array, count);
      wasmWriteVarUnsigned(array, signature.returnType.id as int);

      type = signature.argumentTypes;
      while (type != null) {
        wasmWriteVarUnsigned(array, type.id as int);
        type = type.next;
      }

      signature = signature.next;
    }

    wasmFinishSection(array, section);
  }

  emitImportTable(array: ByteArray): void {
    if (this.firstImport == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("import_table"));
    wasmWriteVarUnsigned(array, this.importCount);

    var current = this.firstImport;
    while (current != null) {
      wasmWriteVarUnsigned(array, current.signatureIndex);
      wasmWriteLengthPrefixedString(array, current.module);
      wasmWriteLengthPrefixedString(array, current.name);
      current = current.next;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionSignatures(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_signatures"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      wasmWriteVarUnsigned(array, fn.signatureIndex);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitMemory(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("memory"));
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, 1); // The memory array is exported
    wasmFinishSection(array, section);
  }

  emitExportTable(array: ByteArray): void {
    var exportedCount = 0;
    var fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        exportedCount = exportedCount + 1;
      }
      fn = fn.next;
    }
    if (exportedCount == 0) {
      return;
    }

    var section = wasmStartSection(array, String_new("export_table"));
    wasmWriteVarUnsigned(array, exportedCount);

    var i = 0;
    fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        wasmWriteVarUnsigned(array, i);
        wasmWriteLengthPrefixedString(array, fn.name);
      }
      fn = fn.next;
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionBodies(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_bodies"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      var bodyLength = array.length();
      wasmWriteVarUnsigned(array, ~0); // This will be patched later

      if (fn.intLocalCount > 0) {
        wasmWriteVarUnsigned(array, 1);
        wasmWriteVarUnsigned(array, fn.intLocalCount);
        array.append(WasmType.I32);
      } else {
        wasmWriteVarUnsigned(array, 0);
      }

      var child = fn.body.firstChild;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }

      wasmPatchVarUnsigned(array, bodyLength, array.length() - bodyLength - 5, ~0);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitDataSegments(array: ByteArray): void {
    this.growMemoryInitializer();
    var memoryInitializer = this.memoryInitializer;
    var initializerLength = memoryInitializer.length();
    var initialHeapPointer = alignToNextMultipleOf(WASM_MEMORY_INITIALIZER_BASE + initializerLength, 8);

    // Pass the initial heap pointer to the "malloc" function
    ByteArray_set32(memoryInitializer, this.currentHeapPointer, initialHeapPointer);
    ByteArray_set32(memoryInitializer, this.originalHeapPointer, initialHeapPointer);

    var section = wasmStartSection(array, String_new("data_segments"));

    // This only writes one single section containing everything
    wasmWriteVarUnsigned(array, 1);

    // Emit the range of the memory initializer
    wasmWriteVarUnsigned(array, WASM_MEMORY_INITIALIZER_BASE);
    wasmWriteVarUnsigned(array, initializerLength);

    // Copy the entire memory initializer (also includes zero-initialized data for now)
    var i = 0;
    while (i < initializerLength) {
      array.append(memoryInitializer.get(i));
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  prepareToEmit(node: Node): void {
    if (node.kind == NodeKind.STRING) {
      var text = node.stringValue;
      var length = String_length(text);
      var offset = this.context.allocateGlobalVariableOffset(length + 1, 1);;
      this.growMemoryInitializer();
      var memoryInitializer = this.memoryInitializer;
      var i = 0;
      while (i < length) {
        memoryInitializer.set(offset + i, String_get(text, i) as byte);
        i = i + 1;
      }
      memoryInitializer.set(offset + length, 0);
      node.intValue = offset;
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        var sizeOf = symbol.resolvedType.variableSizeOf();
        var value = symbol.node.variableValue().intValue;
        var memoryInitializer = this.memoryInitializer;

        // Copy the initial value into the memory initializer
        this.growMemoryInitializer();
        if (sizeOf == 1) memoryInitializer.set(symbol.offset, value as byte);
        else if (sizeOf == 2) ByteArray_set16(memoryInitializer, symbol.offset, value);
        else if (sizeOf == 4) ByteArray_set32(memoryInitializer, symbol.offset, value);
        else assert(false);

        // Make sure the heap offset is tracked
        if (String_equalNew(symbol.name, "currentHeapPointer")) {
          assert(this.currentHeapPointer == -1);
          this.currentHeapPointer = symbol.offset;
        }

        // Make sure the heap offset is tracked
        else if (String_equalNew(symbol.name, "originalHeapPointer")) {
          assert(this.originalHeapPointer == -1);
          this.originalHeapPointer = symbol.offset;
        }
      }
    }

    else if (node.kind == NodeKind.FUNCTION) {
      var returnType = node.functionReturnType();
      var shared = new WasmSharedOffset();
      var argumentTypesFirst: WasmWrappedType = null;
      var argumentTypesLast: WasmWrappedType = null;

      // Make sure to include the implicit "this" variable as a normal argument
      var argument = node.firstChild;
      while (argument != returnType) {
        var type = wasmWrapType(this.getWasmType(argument.variableType().resolvedType));

        if (argumentTypesFirst == null) argumentTypesFirst = type;
        else argumentTypesLast.next = type;
        argumentTypesLast = type;

        shared.nextLocalOffset = shared.nextLocalOffset + 1;
        argument = argument.nextSibling;
      }
      var signatureIndex = this.allocateSignature(argumentTypesFirst, wasmWrapType(this.getWasmType(returnType.resolvedType)));
      var body = node.functionBody();
      var symbol = node.symbol;

      // Functions without bodies are imports
      if (body == null) {
        var moduleName = symbol.kind == SymbolKind.FUNCTION_INSTANCE ? symbol.parent().name : String_new("globals");
        symbol.offset = this.importCount;
        this.allocateImport(signatureIndex, moduleName, symbol.name);
        node = node.nextSibling;
        return;
      }

      symbol.offset = this.functionCount;
      var fn = this.allocateFunction(symbol.name, signatureIndex, body);

      // Make sure "malloc" is tracked
      if (symbol.kind == SymbolKind.FUNCTION_GLOBAL && String_equalNew(symbol.name, "malloc")) {
        assert(this.mallocFunctionIndex == -1);
        this.mallocFunctionIndex = symbol.offset;
      }

      // Only export "extern" functions
      if (node.isExtern()) {
        fn.isExported = true;
      }

      // Assign local variable offsets
      wasmAssignLocalVariableOffsets(body, shared);
      fn.intLocalCount = shared.intLocalCount;
    }

    var child = node.firstChild;
    while (child != null) {
      this.prepareToEmit(child);
      child = child.nextSibling;
    }
  }

  emitBinaryExpression(array: ByteArray, node: Node, opcode: byte): void {
    array.append(opcode);
    this.emitNode(array, node.binaryLeft());
    this.emitNode(array, node.binaryRight());
  }

  emitLoadFromMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD8_U : WASM_OPCODE_I32_LOAD8_S);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD16_U : WASM_OPCODE_I32_LOAD16_S);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_LOAD);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }
  }

  emitStoreToMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int, value: Node): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(WASM_OPCODE_I32_STORE8);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(WASM_OPCODE_I32_STORE16);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_STORE);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }

    this.emitNode(array, value);
  }

  emitNode(array: ByteArray, node: Node): int {
    assert(!isExpression(node) || node.resolvedType != null);

    if (node.kind == NodeKind.BLOCK) {
      array.append(WASM_OPCODE_BLOCK);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.WHILE) {
      var value = node.whileValue();
      var body = node.whileBody();

      // Ignore "while (false) { ... }"
      if (value.kind == NodeKind.BOOL && value.intValue == 0) {
        return 0;
      }

      array.append(WASM_OPCODE_LOOP);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;

      // Emit the condition as "loop { if (!condition) break; }" as long as it's not a "while (true)" loop
      if (value.kind != NodeKind.BOOL) {
        array.append(WASM_OPCODE_BR_IF);
        wasmWriteVarUnsigned(array, 1); // Break out of the immediately enclosing loop
        array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
        array.append(WASM_OPCODE_I32_EQZ); // The conditional is flipped
        this.emitNode(array, value);
        count = count + 1;
      }

      var child = body.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }

      // Jump back to the top (this doesn't happen automatically)
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, 0); // Continue back to the immediately enclosing loop
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
      count = count + 1;

      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.BREAK || node.kind == NodeKind.CONTINUE) {
      var label = 0;
      var parent = node.parent;

      while (parent != null && parent.kind != NodeKind.WHILE) {
        if (parent.kind == NodeKind.BLOCK) {
          label = label + 1;
        }
        parent = parent.parent;
      }

      assert(label > 0);
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, label - (node.kind == NodeKind.BREAK ? 0 : 1));
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
    }

    else if (node.kind == NodeKind.EMPTY) {
      return 0;
    }

    else if (node.kind == NodeKind.EXPRESSION) {
      this.emitNode(array, node.expressionValue());
    }

    else if (node.kind == NodeKind.RETURN) {
      var value = node.returnValue();
      array.append(WASM_OPCODE_RETURN);
      if (value != null) {
        this.emitNode(array, value);
      }
    }

    else if (node.kind == NodeKind.VARIABLES) {
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        assert(child.kind == NodeKind.VARIABLE);
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      return count;
    }

    else if (node.kind == NodeKind.IF) {
      var branch = node.ifFalse();
      array.append(branch == null ? WASM_OPCODE_IF : WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.ifValue());
      this.emitNode(array, node.ifTrue());
      if (branch != null) {
        this.emitNode(array, branch);
      }
    }

    else if (node.kind == NodeKind.HOOK) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.hookValue());
      this.emitNode(array, node.hookTrue());
      this.emitNode(array, node.hookFalse());
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var value = node.variableValue();

      if (node.symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, node.symbol.offset);

        if (value != null) {
          this.emitNode(array, value);
        }

        // Default initialization
        else {
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, 0);
        }
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NAME) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_GET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitLoadFromMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NULL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.INT || node.kind == NodeKind.BOOL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, node.intValue);
    }

    else if (node.kind == NodeKind.STRING) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, WASM_MEMORY_INITIALIZER_BASE + node.intValue);
    }

    else if (node.kind == NodeKind.CALL) {
      var value = node.callValue();
      var symbol = value.symbol;
      assert(isFunction(symbol.kind));

      array.append(symbol.node.functionBody() == null ? WASM_OPCODE_CALL_IMPORT : WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, symbol.offset);

      // Write out the implicit "this" argument
      if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
        this.emitNode(array, value.dotTarget());
      }

      var child = value.nextSibling;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }
    }

    else if (node.kind == NodeKind.NEW) {
      var type = node.newType();
      assert(type.symbol.kind == SymbolKind.TYPE_CLASS);

      array.append(WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, this.mallocFunctionIndex);

      // Pass the object size as the first argument
      assert(type.symbol.byteSize > 0);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, type.symbol.byteSize);
    }

    else if (node.kind == NodeKind.POSITIVE) {
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NEGATIVE) {
      array.append(WASM_OPCODE_I32_SUB);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.COMPLEMENT) {
      array.append(WASM_OPCODE_I32_XOR);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, ~0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NOT) {
      array.append(WASM_OPCODE_I32_EQZ);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.CAST) {
      var value = node.castValue();
      var context = this.context;
      var from = value.resolvedType.underlyingType(context);
      var type = node.resolvedType.underlyingType(context);

      // The cast isn't needed if it's to a wider integer type
      if (from == type || from.symbol.byteSize < type.symbol.byteSize) {
        this.emitNode(array, value);
      }

      else {
        // Sign-extend
        if (type == context.byteType || type == context.shortType) {
          var shift = 32 - type.symbol.byteSize * 8;
          array.append(WASM_OPCODE_I32_SHR_S);
          array.append(WASM_OPCODE_I32_SHL);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
        }

        // Mask
        else if (type == context.ubyteType || type == context.ushortType) {
          array.append(WASM_OPCODE_I32_AND);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, type.integerBitMask() as int);
        }

        // No cast needed
        else {
          this.emitNode(array, value);
        }
      }
    }

    else if (node.kind == NodeKind.DOT) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitLoadFromMemory(array, symbol.resolvedType, node.dotTarget(), symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.ASSIGN) {
      var left = node.binaryLeft();
      var symbol = left.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitStoreToMemory(array, symbol.resolvedType, left.dotTarget(), symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitStoreToMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
        this.emitNode(array, node.binaryRight());
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.LOGICAL_AND) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      this.emitNode(array, node.binaryRight());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.LOGICAL_OR) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 1);
      this.emitNode(array, node.binaryRight());
    }

    else {
      var isUnsigned = node.isUnsignedOperator();

      if (node.kind == NodeKind.ADD) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_ADD);
      else if (node.kind == NodeKind.BITWISE_AND) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_AND);
      else if (node.kind == NodeKind.BITWISE_OR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_OR);
      else if (node.kind == NodeKind.BITWISE_XOR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_XOR);
      else if (node.kind == NodeKind.EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_EQ);
      else if (node.kind == NodeKind.MULTIPLY) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_MUL);
      else if (node.kind == NodeKind.NOT_EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_NE);
      else if (node.kind == NodeKind.SHIFT_LEFT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SHL);
      else if (node.kind == NodeKind.SUBTRACT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SUB);

      else if (node.kind == NodeKind.DIVIDE) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_DIV_U : WASM_OPCODE_I32_DIV_S);
      else if (node.kind == NodeKind.GREATER_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GT_U : WASM_OPCODE_I32_GT_S);
      else if (node.kind == NodeKind.GREATER_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GE_U : WASM_OPCODE_I32_GE_S);
      else if (node.kind == NodeKind.LESS_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LT_U : WASM_OPCODE_I32_LT_S);
      else if (node.kind == NodeKind.LESS_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LE_U : WASM_OPCODE_I32_LE_S);
      else if (node.kind == NodeKind.REMAINDER) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_REM_U : WASM_OPCODE_I32_REM_S);
      else if (node.kind == NodeKind.SHIFT_RIGHT) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_SHR_U : WASM_OPCODE_I32_SHR_S);

      else {
        assert(false);
      }
    }

    return 1;
  }

  getWasmType(type: Type): WasmType {
    var context = this.context;

    if (type == context.boolType || type.isInteger() || type.isReference(context)) {
      return WasmType.I32;
    }

    if (type == context.voidType) {
      return WasmType.VOID;
    }

    assert(false);
    return WasmType.VOID;
  }
}
class WasmModule7 {
  firstImport: WasmImport;
  lastImport: WasmImport;
  importCount: int;

  firstFunction: WasmFunction;
  lastFunction: WasmFunction;
  functionCount: int;

  firstSignature: WasmSignature;
  lastSignature: WasmSignature;
  signatureCount: int;

  memoryInitializer: ByteArray;
  currentHeapPointer: int;
  originalHeapPointer: int;
  mallocFunctionIndex: int;
  context: CheckContext;

  growMemoryInitializer(): void {
    var array = this.memoryInitializer;
    var current = array.length();
    var length = this.context.nextGlobalVariableOffset;

    while (current < length) {
      array.append(0);
      current = current + 1;
    }
  }

  allocateImport(signatureIndex: int, mod: String, name: String): WasmImport {
    var result = new WasmImport();
    result.signatureIndex = signatureIndex;
    result.module = mod;
    result.name = name;

    if (this.firstImport == null) this.firstImport = result;
    else this.lastImport.next = result;
    this.lastImport = result;

    this.importCount = this.importCount + 1;
    return result;
  }

  allocateFunction(name: String, signatureIndex: int, body: Node): WasmFunction {
    var fn = new WasmFunction();
    fn.name = name;
    fn.signatureIndex = signatureIndex;
    fn.body = body;

    if (this.firstFunction == null) this.firstFunction = fn;
    else this.lastFunction.next = fn;
    this.lastFunction = fn;

    this.functionCount = this.functionCount + 1;
    return fn;
  }

  allocateSignature(argumentTypes: WasmWrappedType, returnType: WasmWrappedType): int {
    assert(returnType != null);
    assert(returnType.next == null);

    var signature = new WasmSignature();
    signature.argumentTypes = argumentTypes;
    signature.returnType = returnType;

    var check = this.firstSignature;
    var i = 0;

    while (check != null) {
      if (wasmAreSignaturesEqual(signature, check)) {
        return i;
      }

      check = check.next;
      i = i + 1;
    }

    if (this.firstSignature == null) this.firstSignature = signature;
    else this.lastSignature.next = signature;
    this.lastSignature = signature;

    this.signatureCount = this.signatureCount + 1;
    return i;
  }

  emitModule(array: ByteArray): void {
    ByteArray_append32(array, WASM_MAGIC);
    ByteArray_append32(array, WASM_VERSION);

    this.emitSignatures(array);
    this.emitImportTable(array);
    this.emitFunctionSignatures(array);
    this.emitMemory(array);
    this.emitExportTable(array);
    this.emitFunctionBodies(array);
    this.emitDataSegments(array);
  }

  emitSignatures(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("signatures"));
    wasmWriteVarUnsigned(array, this.signatureCount);

    var signature = this.firstSignature;
    while (signature != null) {
      var count = 0;
      var type = signature.argumentTypes;

      while (type != null) {
        count = count + 1;
        type = type.next;
      }

      wasmWriteVarUnsigned(array, count);
      wasmWriteVarUnsigned(array, signature.returnType.id as int);

      type = signature.argumentTypes;
      while (type != null) {
        wasmWriteVarUnsigned(array, type.id as int);
        type = type.next;
      }

      signature = signature.next;
    }

    wasmFinishSection(array, section);
  }

  emitImportTable(array: ByteArray): void {
    if (this.firstImport == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("import_table"));
    wasmWriteVarUnsigned(array, this.importCount);

    var current = this.firstImport;
    while (current != null) {
      wasmWriteVarUnsigned(array, current.signatureIndex);
      wasmWriteLengthPrefixedString(array, current.module);
      wasmWriteLengthPrefixedString(array, current.name);
      current = current.next;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionSignatures(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_signatures"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      wasmWriteVarUnsigned(array, fn.signatureIndex);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitMemory(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("memory"));
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, 1); // The memory array is exported
    wasmFinishSection(array, section);
  }

  emitExportTable(array: ByteArray): void {
    var exportedCount = 0;
    var fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        exportedCount = exportedCount + 1;
      }
      fn = fn.next;
    }
    if (exportedCount == 0) {
      return;
    }

    var section = wasmStartSection(array, String_new("export_table"));
    wasmWriteVarUnsigned(array, exportedCount);

    var i = 0;
    fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        wasmWriteVarUnsigned(array, i);
        wasmWriteLengthPrefixedString(array, fn.name);
      }
      fn = fn.next;
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionBodies(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_bodies"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      var bodyLength = array.length();
      wasmWriteVarUnsigned(array, ~0); // This will be patched later

      if (fn.intLocalCount > 0) {
        wasmWriteVarUnsigned(array, 1);
        wasmWriteVarUnsigned(array, fn.intLocalCount);
        array.append(WasmType.I32);
      } else {
        wasmWriteVarUnsigned(array, 0);
      }

      var child = fn.body.firstChild;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }

      wasmPatchVarUnsigned(array, bodyLength, array.length() - bodyLength - 5, ~0);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitDataSegments(array: ByteArray): void {
    this.growMemoryInitializer();
    var memoryInitializer = this.memoryInitializer;
    var initializerLength = memoryInitializer.length();
    var initialHeapPointer = alignToNextMultipleOf(WASM_MEMORY_INITIALIZER_BASE + initializerLength, 8);

    // Pass the initial heap pointer to the "malloc" function
    ByteArray_set32(memoryInitializer, this.currentHeapPointer, initialHeapPointer);
    ByteArray_set32(memoryInitializer, this.originalHeapPointer, initialHeapPointer);

    var section = wasmStartSection(array, String_new("data_segments"));

    // This only writes one single section containing everything
    wasmWriteVarUnsigned(array, 1);

    // Emit the range of the memory initializer
    wasmWriteVarUnsigned(array, WASM_MEMORY_INITIALIZER_BASE);
    wasmWriteVarUnsigned(array, initializerLength);

    // Copy the entire memory initializer (also includes zero-initialized data for now)
    var i = 0;
    while (i < initializerLength) {
      array.append(memoryInitializer.get(i));
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  prepareToEmit(node: Node): void {
    if (node.kind == NodeKind.STRING) {
      var text = node.stringValue;
      var length = String_length(text);
      var offset = this.context.allocateGlobalVariableOffset(length + 1, 1);;
      this.growMemoryInitializer();
      var memoryInitializer = this.memoryInitializer;
      var i = 0;
      while (i < length) {
        memoryInitializer.set(offset + i, String_get(text, i) as byte);
        i = i + 1;
      }
      memoryInitializer.set(offset + length, 0);
      node.intValue = offset;
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        var sizeOf = symbol.resolvedType.variableSizeOf();
        var value = symbol.node.variableValue().intValue;
        var memoryInitializer = this.memoryInitializer;

        // Copy the inital value into the memory initializer
        this.growMemoryInitializer();
        if (sizeOf == 1) memoryInitializer.set(symbol.offset, value as byte);
        else if (sizeOf == 2) ByteArray_set16(memoryInitializer, symbol.offset, value);
        else if (sizeOf == 4) ByteArray_set32(memoryInitializer, symbol.offset, value);
        else assert(false);

        // Make sure the heap offset is tracked
        if (String_equalNew(symbol.name, "currentHeapPointer")) {
          assert(this.currentHeapPointer == -1);
          this.currentHeapPointer = symbol.offset;
        }

        // Make sure the heap offset is tracked
        else if (String_equalNew(symbol.name, "originalHeapPointer")) {
          assert(this.originalHeapPointer == -1);
          this.originalHeapPointer = symbol.offset;
        }
      }
    }

    else if (node.kind == NodeKind.FUNCTION) {
      var returnType = node.functionReturnType();
      var shared = new WasmSharedOffset();
      var argumentTypesFirst: WasmWrappedType = null;
      var argumentTypesLast: WasmWrappedType = null;

      // Make sure to include the implicit "this" variable as a normal argument
      var argument = node.firstChild;
      while (argument != returnType) {
        var type = wasmWrapType(this.getWasmType(argument.variableType().resolvedType));

        if (argumentTypesFirst == null) argumentTypesFirst = type;
        else argumentTypesLast.next = type;
        argumentTypesLast = type;

        shared.nextLocalOffset = shared.nextLocalOffset + 1;
        argument = argument.nextSibling;
      }
      var signatureIndex = this.allocateSignature(argumentTypesFirst, wasmWrapType(this.getWasmType(returnType.resolvedType)));
      var body = node.functionBody();
      var symbol = node.symbol;

      // Functions without bodies are imports
      if (body == null) {
        var moduleName = symbol.kind == SymbolKind.FUNCTION_INSTANCE ? symbol.parent().name : String_new("globals");
        symbol.offset = this.importCount;
        this.allocateImport(signatureIndex, moduleName, symbol.name);
        node = node.nextSibling;
        return;
      }

      symbol.offset = this.functionCount;
      var fn = this.allocateFunction(symbol.name, signatureIndex, body);

      // Make sure "malloc" is tracked
      if (symbol.kind == SymbolKind.FUNCTION_GLOBAL && String_equalNew(symbol.name, "malloc")) {
        assert(this.mallocFunctionIndex == -1);
        this.mallocFunctionIndex = symbol.offset;
      }

      // Only export "extern" functions
      if (node.isExtern()) {
        fn.isExported = true;
      }

      // Assign local variable offsets
      wasmAssignLocalVariableOffsets(body, shared);
      fn.intLocalCount = shared.intLocalCount;
    }

    var child = node.firstChild;
    while (child != null) {
      this.prepareToEmit(child);
      child = child.nextSibling;
    }
  }

  emitBinaryExpression(array: ByteArray, node: Node, opcode: byte): void {
    array.append(opcode);
    this.emitNode(array, node.binaryLeft());
    this.emitNode(array, node.binaryRight());
  }

  emitLoadFromMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD8_U : WASM_OPCODE_I32_LOAD8_S);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD16_U : WASM_OPCODE_I32_LOAD16_S);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_LOAD);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }
  }

  emitStoreToMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int, value: Node): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(WASM_OPCODE_I32_STORE8);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(WASM_OPCODE_I32_STORE16);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_STORE);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }

    this.emitNode(array, value);
  }

  emitNode(array: ByteArray, node: Node): int {
    assert(!isExpression(node) || node.resolvedType != null);

    if (node.kind == NodeKind.BLOCK) {
      array.append(WASM_OPCODE_BLOCK);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.WHILE) {
      var value = node.whileValue();
      var body = node.whileBody();

      // Ignore "while (false) { ... }"
      if (value.kind == NodeKind.BOOL && value.intValue == 0) {
        return 0;
      }

      array.append(WASM_OPCODE_LOOP);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;

      // Emit the condition as "loop { if (!condition) break; }" as long as it's not a "while (true)" loop
      if (value.kind != NodeKind.BOOL) {
        array.append(WASM_OPCODE_BR_IF);
        wasmWriteVarUnsigned(array, 1); // Break out of the immediately enclosing loop
        array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
        array.append(WASM_OPCODE_I32_EQZ); // The conditional is flipped
        this.emitNode(array, value);
        count = count + 1;
      }

      var child = body.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }

      // Jump back to the top (this doesn't happen automatically)
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, 0); // Continue back to the immediately enclosing loop
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
      count = count + 1;

      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.BREAK || node.kind == NodeKind.CONTINUE) {
      var label = 0;
      var parent = node.parent;

      while (parent != null && parent.kind != NodeKind.WHILE) {
        if (parent.kind == NodeKind.BLOCK) {
          label = label + 1;
        }
        parent = parent.parent;
      }

      assert(label > 0);
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, label - (node.kind == NodeKind.BREAK ? 0 : 1));
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
    }

    else if (node.kind == NodeKind.EMPTY) {
      return 0;
    }

    else if (node.kind == NodeKind.EXPRESSION) {
      this.emitNode(array, node.expressionValue());
    }

    else if (node.kind == NodeKind.RETURN) {
      var value = node.returnValue();
      array.append(WASM_OPCODE_RETURN);
      if (value != null) {
        this.emitNode(array, value);
      }
    }

    else if (node.kind == NodeKind.VARIABLES) {
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        assert(child.kind == NodeKind.VARIABLE);
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      return count;
    }

    else if (node.kind == NodeKind.IF) {
      var branch = node.ifFalse();
      array.append(branch == null ? WASM_OPCODE_IF : WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.ifValue());
      this.emitNode(array, node.ifTrue());
      if (branch != null) {
        this.emitNode(array, branch);
      }
    }

    else if (node.kind == NodeKind.HOOK) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.hookValue());
      this.emitNode(array, node.hookTrue());
      this.emitNode(array, node.hookFalse());
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var value = node.variableValue();

      if (node.symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, node.symbol.offset);

        if (value != null) {
          this.emitNode(array, value);
        }

        // Default initialization
        else {
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, 0);
        }
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NAME) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_GET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitLoadFromMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NULL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.INT || node.kind == NodeKind.BOOL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, node.intValue);
    }

    else if (node.kind == NodeKind.STRING) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, WASM_MEMORY_INITIALIZER_BASE + node.intValue);
    }

    else if (node.kind == NodeKind.CALL) {
      var value = node.callValue();
      var symbol = value.symbol;
      assert(isFunction(symbol.kind));

      array.append(symbol.node.functionBody() == null ? WASM_OPCODE_CALL_IMPORT : WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, symbol.offset);

      // Write out the implicit "this" argument
      if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
        this.emitNode(array, value.dotTarget());
      }

      var child = value.nextSibling;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }
    }

    else if (node.kind == NodeKind.NEW) {
      var type = node.newType();
      assert(type.symbol.kind == SymbolKind.TYPE_CLASS);

      array.append(WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, this.mallocFunctionIndex);

      // Pass the object size as the first argument
      assert(type.symbol.byteSize > 0);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, type.symbol.byteSize);
    }

    else if (node.kind == NodeKind.POSITIVE) {
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NEGATIVE) {
      array.append(WASM_OPCODE_I32_SUB);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.COMPLEMENT) {
      array.append(WASM_OPCODE_I32_XOR);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, ~0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NOT) {
      array.append(WASM_OPCODE_I32_EQZ);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.CAST) {
      var value = node.castValue();
      var context = this.context;
      var from = value.resolvedType.underlyingType(context);
      var type = node.resolvedType.underlyingType(context);

      // The cast isn't needed if it's to a wider integer type
      if (from == type || from.symbol.byteSize < type.symbol.byteSize) {
        this.emitNode(array, value);
      }

      else {
        // Sign-extend
        if (type == context.byteType || type == context.shortType) {
          var shift = 32 - type.symbol.byteSize * 8;
          array.append(WASM_OPCODE_I32_SHR_S);
          array.append(WASM_OPCODE_I32_SHL);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
        }

        // Mask
        else if (type == context.ubyteType || type == context.ushortType) {
          array.append(WASM_OPCODE_I32_AND);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, type.integerBitMask() as int);
        }

        // No cast needed
        else {
          this.emitNode(array, value);
        }
      }
    }

    else if (node.kind == NodeKind.DOT) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitLoadFromMemory(array, symbol.resolvedType, node.dotTarget(), symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.ASSIGN) {
      var left = node.binaryLeft();
      var symbol = left.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitStoreToMemory(array, symbol.resolvedType, left.dotTarget(), symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitStoreToMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
        this.emitNode(array, node.binaryRight());
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.LOGICAL_AND) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      this.emitNode(array, node.binaryRight());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.LOGICAL_OR) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 1);
      this.emitNode(array, node.binaryRight());
    }

    else {
      var isUnsigned = node.isUnsignedOperator();

      if (node.kind == NodeKind.ADD) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_ADD);
      else if (node.kind == NodeKind.BITWISE_AND) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_AND);
      else if (node.kind == NodeKind.BITWISE_OR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_OR);
      else if (node.kind == NodeKind.BITWISE_XOR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_XOR);
      else if (node.kind == NodeKind.EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_EQ);
      else if (node.kind == NodeKind.MULTIPLY) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_MUL);
      else if (node.kind == NodeKind.NOT_EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_NE);
      else if (node.kind == NodeKind.SHIFT_LEFT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SHL);
      else if (node.kind == NodeKind.SUBTRACT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SUB);

      else if (node.kind == NodeKind.DIVIDE) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_DIV_U : WASM_OPCODE_I32_DIV_S);
      else if (node.kind == NodeKind.GREATER_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GT_U : WASM_OPCODE_I32_GT_S);
      else if (node.kind == NodeKind.GREATER_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GE_U : WASM_OPCODE_I32_GE_S);
      else if (node.kind == NodeKind.LESS_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LT_U : WASM_OPCODE_I32_LT_S);
      else if (node.kind == NodeKind.LESS_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LE_U : WASM_OPCODE_I32_LE_S);
      else if (node.kind == NodeKind.REMAINDER) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_REM_U : WASM_OPCODE_I32_REM_S);
      else if (node.kind == NodeKind.SHIFT_RIGHT) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_SHR_U : WASM_OPCODE_I32_SHR_S);

      else {
        assert(false);
      }
    }

    return 1;
  }

  getWasmType(type: Type): WasmType {
    var context = this.context;

    if (type == context.boolType || type.isInteger() || type.isReference(context)) {
      return WasmType.I32;
    }

    if (type == context.voidType) {
      return WasmType.VOID;
    }

    assert(false);
    return WasmType.VOID;
  }
}
class WasmModule8 {
  firstImport: WasmImport;
  lastImport: WasmImport;
  importCount: int;

  firstFunction: WasmFunction;
  lastFunction: WasmFunction;
  functionCount: int;

  firstSignature: WasmSignature;
  lastSignature: WasmSignature;
  signatureCount: int;

  memoryInitializer: ByteArray;
  currentHeapPointer: int;
  originalHeapPointer: int;
  mallocFunctionIndex: int;
  context: CheckContext;

  growMemoryInitializer(): void {
    var array = this.memoryInitializer;
    var current = array.length();
    var length = this.context.nextGlobalVariableOffset;

    while (current < length) {
      array.append(0);
      current = current + 1;
    }
  }

  allocateImport(signatureIndex: int, mod: String, name: String): WasmImport {
    var result = new WasmImport();
    result.signatureIndex = signatureIndex;
    result.module = mod;
    result.name = name;

    if (this.firstImport == null) this.firstImport = result;
    else this.lastImport.next = result;
    this.lastImport = result;

    this.importCount = this.importCount + 1;
    return result;
  }

  allocateFunction(name: String, signatureIndex: int, body: Node): WasmFunction {
    var fn = new WasmFunction();
    fn.name = name;
    fn.signatureIndex = signatureIndex;
    fn.body = body;

    if (this.firstFunction == null) this.firstFunction = fn;
    else this.lastFunction.next = fn;
    this.lastFunction = fn;

    this.functionCount = this.functionCount + 1;
    return fn;
  }

  allocateSignature(argumentTypes: WasmWrappedType, returnType: WasmWrappedType): int {
    assert(returnType != null);
    assert(returnType.next == null);

    var signature = new WasmSignature();
    signature.argumentTypes = argumentTypes;
    signature.returnType = returnType;

    var check = this.firstSignature;
    var i = 0;

    while (check != null) {
      if (wasmAreSignaturesEqual(signature, check)) {
        return i;
      }

      check = check.next;
      i = i + 1;
    }

    if (this.firstSignature == null) this.firstSignature = signature;
    else this.lastSignature.next = signature;
    this.lastSignature = signature;

    this.signatureCount = this.signatureCount + 1;
    return i;
  }

  emitModule(array: ByteArray): void {
    ByteArray_append32(array, WASM_MAGIC);
    ByteArray_append32(array, WASM_VERSION);

    this.emitSignatures(array);
    this.emitImportTable(array);
    this.emitFunctionSignatures(array);
    this.emitMemory(array);
    this.emitExportTable(array);
    this.emitFunctionBodies(array);
    this.emitDataSegments(array);
  }

  emitSignatures(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("signatures"));
    wasmWriteVarUnsigned(array, this.signatureCount);

    var signature = this.firstSignature;
    while (signature != null) {
      var count = 0;
      var type = signature.argumentTypes;

      while (type != null) {
        count = count + 1;
        type = type.next;
      }

      wasmWriteVarUnsigned(array, count);
      wasmWriteVarUnsigned(array, signature.returnType.id as int);

      type = signature.argumentTypes;
      while (type != null) {
        wasmWriteVarUnsigned(array, type.id as int);
        type = type.next;
      }

      signature = signature.next;
    }

    wasmFinishSection(array, section);
  }

  emitImportTable(array: ByteArray): void {
    if (this.firstImport == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("import_table"));
    wasmWriteVarUnsigned(array, this.importCount);

    var current = this.firstImport;
    while (current != null) {
      wasmWriteVarUnsigned(array, current.signatureIndex);
      wasmWriteLengthPrefixedString(array, current.module);
      wasmWriteLengthPrefixedString(array, current.name);
      current = current.next;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionSignatures(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_signatures"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      wasmWriteVarUnsigned(array, fn.signatureIndex);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitMemory(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("memory"));
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, 1); // The memory array is exported
    wasmFinishSection(array, section);
  }

  emitExportTable(array: ByteArray): void {
    var exportedCount = 0;
    var fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        exportedCount = exportedCount + 1;
      }
      fn = fn.next;
    }
    if (exportedCount == 0) {
      return;
    }

    var section = wasmStartSection(array, String_new("export_table"));
    wasmWriteVarUnsigned(array, exportedCount);

    var i = 0;
    fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        wasmWriteVarUnsigned(array, i);
        wasmWriteLengthPrefixedString(array, fn.name);
      }
      fn = fn.next;
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionBodies(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_bodies"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      var bodyLength = array.length();
      wasmWriteVarUnsigned(array, ~0); // This will be patched later

      if (fn.intLocalCount > 0) {
        wasmWriteVarUnsigned(array, 1);
        wasmWriteVarUnsigned(array, fn.intLocalCount);
        array.append(WasmType.I32);
      } else {
        wasmWriteVarUnsigned(array, 0);
      }

      var child = fn.body.firstChild;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }

      wasmPatchVarUnsigned(array, bodyLength, array.length() - bodyLength - 5, ~0);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitDataSegments(array: ByteArray): void {
    this.growMemoryInitializer();
    var memoryInitializer = this.memoryInitializer;
    var initializerLength = memoryInitializer.length();
    var initialHeapPointer = alignToNextMultipleOf(WASM_MEMORY_INITIALIZER_BASE + initializerLength, 8);

    // Pass the initial heap pointer to the "malloc" function
    ByteArray_set32(memoryInitializer, this.currentHeapPointer, initialHeapPointer);
    ByteArray_set32(memoryInitializer, this.originalHeapPointer, initialHeapPointer);

    var section = wasmStartSection(array, String_new("data_segments"));

    // This only writes one single section containing everything
    wasmWriteVarUnsigned(array, 1);

    // Emit the range of the memory initializer
    wasmWriteVarUnsigned(array, WASM_MEMORY_INITIALIZER_BASE);
    wasmWriteVarUnsigned(array, initializerLength);

    // Copy the entire memory initializer (also includes zero-initialized data for now)
    var i = 0;
    while (i < initializerLength) {
      array.append(memoryInitializer.get(i));
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  prepareToEmit(node: Node): void {
    if (node.kind == NodeKind.STRING) {
      var text = node.stringValue;
      var length = String_length(text);
      var offset = this.context.allocateGlobalVariableOffset(length + 1, 1);;
      this.growMemoryInitializer();
      var memoryInitializer = this.memoryInitializer;
      var i = 0;
      while (i < length) {
        memoryInitializer.set(offset + i, String_get(text, i) as byte);
        i = i + 1;
      }
      memoryInitializer.set(offset + length, 0);
      node.intValue = offset;
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        var sizeOf = symbol.resolvedType.variableSizeOf();
        var value = symbol.node.variableValue().intValue;
        var memoryInitializer = this.memoryInitializer;

        // Copy the inital value into the memory initializer
        this.growMemoryInitializer();
        if (sizeOf == 1) memoryInitializer.set(symbol.offset, value as byte);
        else if (sizeOf == 2) ByteArray_set16(memoryInitializer, symbol.offset, value);
        else if (sizeOf == 4) ByteArray_set32(memoryInitializer, symbol.offset, value);
        else assert(false);

        // Make sure the heap offset is tracked
        if (String_equalNew(symbol.name, "currentHeapPointer")) {
          assert(this.currentHeapPointer == -1);
          this.currentHeapPointer = symbol.offset;
        }

        // Make sure the heap offset is tracked
        else if (String_equalNew(symbol.name, "originalHeapPointer")) {
          assert(this.originalHeapPointer == -1);
          this.originalHeapPointer = symbol.offset;
        }
      }
    }

    else if (node.kind == NodeKind.FUNCTION) {
      var returnType = node.functionReturnType();
      var shared = new WasmSharedOffset();
      var argumentTypesFirst: WasmWrappedType = null;
      var argumentTypesLast: WasmWrappedType = null;

      // Make sure to include the implicit "this" variable as a normal argument
      var argument = node.firstChild;
      while (argument != returnType) {
        var type = wasmWrapType(this.getWasmType(argument.variableType().resolvedType));

        if (argumentTypesFirst == null) argumentTypesFirst = type;
        else argumentTypesLast.next = type;
        argumentTypesLast = type;

        shared.nextLocalOffset = shared.nextLocalOffset + 1;
        argument = argument.nextSibling;
      }
      var signatureIndex = this.allocateSignature(argumentTypesFirst, wasmWrapType(this.getWasmType(returnType.resolvedType)));
      var body = node.functionBody();
      var symbol = node.symbol;

      // Functions without bodies are imports
      if (body == null) {
        var moduleName = symbol.kind == SymbolKind.FUNCTION_INSTANCE ? symbol.parent().name : String_new("globals");
        symbol.offset = this.importCount;
        this.allocateImport(signatureIndex, moduleName, symbol.name);
        node = node.nextSibling;
        return;
      }

      symbol.offset = this.functionCount;
      var fn = this.allocateFunction(symbol.name, signatureIndex, body);

      // Make sure "malloc" is tracked
      if (symbol.kind == SymbolKind.FUNCTION_GLOBAL && String_equalNew(symbol.name, "malloc")) {
        assert(this.mallocFunctionIndex == -1);
        this.mallocFunctionIndex = symbol.offset;
      }

      // Only export "extern" functions
      if (node.isExtern()) {
        fn.isExported = true;
      }

      // Assign local variable offsets
      wasmAssignLocalVariableOffsets(body, shared);
      fn.intLocalCount = shared.intLocalCount;
    }

    var child = node.firstChild;
    while (child != null) {
      this.prepareToEmit(child);
      child = child.nextSibling;
    }
  }

  emitBinaryExpression(array: ByteArray, node: Node, opcode: byte): void {
    array.append(opcode);
    this.emitNode(array, node.binaryLeft());
    this.emitNode(array, node.binaryRight());
  }

  emitLoadFromMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD8_U : WASM_OPCODE_I32_LOAD8_S);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD16_U : WASM_OPCODE_I32_LOAD16_S);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_LOAD);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }
  }

  emitStoreToMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int, value: Node): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(WASM_OPCODE_I32_STORE8);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(WASM_OPCODE_I32_STORE16);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_STORE);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }

    this.emitNode(array, value);
  }

  emitNode(array: ByteArray, node: Node): int {
    assert(!isExpression(node) || node.resolvedType != null);

    if (node.kind == NodeKind.BLOCK) {
      array.append(WASM_OPCODE_BLOCK);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.WHILE) {
      var value = node.whileValue();
      var body = node.whileBody();

      // Ignore "while (false) { ... }"
      if (value.kind == NodeKind.BOOL && value.intValue == 0) {
        return 0;
      }

      array.append(WASM_OPCODE_LOOP);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;

      // Emit the condition as "loop { if (!condition) break; }" as long as it's not a "while (true)" loop
      if (value.kind != NodeKind.BOOL) {
        array.append(WASM_OPCODE_BR_IF);
        wasmWriteVarUnsigned(array, 1); // Break out of the immediately enclosing loop
        array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
        array.append(WASM_OPCODE_I32_EQZ); // The conditional is flipped
        this.emitNode(array, value);
        count = count + 1;
      }

      var child = body.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }

      // Jump back to the top (this doesn't happen automatically)
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, 0); // Continue back to the immediately enclosing loop
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
      count = count + 1;

      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.BREAK || node.kind == NodeKind.CONTINUE) {
      var label = 0;
      var parent = node.parent;

      while (parent != null && parent.kind != NodeKind.WHILE) {
        if (parent.kind == NodeKind.BLOCK) {
          label = label + 1;
        }
        parent = parent.parent;
      }

      assert(label > 0);
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, label - (node.kind == NodeKind.BREAK ? 0 : 1));
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
    }

    else if (node.kind == NodeKind.EMPTY) {
      return 0;
    }

    else if (node.kind == NodeKind.EXPRESSION) {
      this.emitNode(array, node.expressionValue());
    }

    else if (node.kind == NodeKind.RETURN) {
      var value = node.returnValue();
      array.append(WASM_OPCODE_RETURN);
      if (value != null) {
        this.emitNode(array, value);
      }
    }

    else if (node.kind == NodeKind.VARIABLES) {
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        assert(child.kind == NodeKind.VARIABLE);
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      return count;
    }

    else if (node.kind == NodeKind.IF) {
      var branch = node.ifFalse();
      array.append(branch == null ? WASM_OPCODE_IF : WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.ifValue());
      this.emitNode(array, node.ifTrue());
      if (branch != null) {
        this.emitNode(array, branch);
      }
    }

    else if (node.kind == NodeKind.HOOK) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.hookValue());
      this.emitNode(array, node.hookTrue());
      this.emitNode(array, node.hookFalse());
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var value = node.variableValue();

      if (node.symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, node.symbol.offset);

        if (value != null) {
          this.emitNode(array, value);
        }

        // Default initialization
        else {
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, 0);
        }
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NAME) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_GET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitLoadFromMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NULL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.INT || node.kind == NodeKind.BOOL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, node.intValue);
    }

    else if (node.kind == NodeKind.STRING) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, WASM_MEMORY_INITIALIZER_BASE + node.intValue);
    }

    else if (node.kind == NodeKind.CALL) {
      var value = node.callValue();
      var symbol = value.symbol;
      assert(isFunction(symbol.kind));

      array.append(symbol.node.functionBody() == null ? WASM_OPCODE_CALL_IMPORT : WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, symbol.offset);

      // Write out the implicit "this" argument
      if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
        this.emitNode(array, value.dotTarget());
      }

      var child = value.nextSibling;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }
    }

    else if (node.kind == NodeKind.NEW) {
      var type = node.newType();
      assert(type.symbol.kind == SymbolKind.TYPE_CLASS);

      array.append(WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, this.mallocFunctionIndex);

      // Pass the object size as the first argument
      assert(type.symbol.byteSize > 0);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, type.symbol.byteSize);
    }

    else if (node.kind == NodeKind.POSITIVE) {
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NEGATIVE) {
      array.append(WASM_OPCODE_I32_SUB);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.COMPLEMENT) {
      array.append(WASM_OPCODE_I32_XOR);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, ~0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NOT) {
      array.append(WASM_OPCODE_I32_EQZ);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.CAST) {
      var value = node.castValue();
      var context = this.context;
      var from = value.resolvedType.underlyingType(context);
      var type = node.resolvedType.underlyingType(context);

      // The cast isn't needed if it's to a wider integer type
      if (from == type || from.symbol.byteSize < type.symbol.byteSize) {
        this.emitNode(array, value);
      }

      else {
        // Sign-extend
        if (type == context.byteType || type == context.shortType) {
          var shift = 32 - type.symbol.byteSize * 8;
          array.append(WASM_OPCODE_I32_SHR_S);
          array.append(WASM_OPCODE_I32_SHL);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
        }

        // Mask
        else if (type == context.ubyteType || type == context.ushortType) {
          array.append(WASM_OPCODE_I32_AND);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, type.integerBitMask() as int);
        }

        // No cast needed
        else {
          this.emitNode(array, value);
        }
      }
    }

    else if (node.kind == NodeKind.DOT) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitLoadFromMemory(array, symbol.resolvedType, node.dotTarget(), symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.ASSIGN) {
      var left = node.binaryLeft();
      var symbol = left.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitStoreToMemory(array, symbol.resolvedType, left.dotTarget(), symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitStoreToMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
        this.emitNode(array, node.binaryRight());
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.LOGICAL_AND) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      this.emitNode(array, node.binaryRight());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.LOGICAL_OR) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 1);
      this.emitNode(array, node.binaryRight());
    }

    else {
      var isUnsigned = node.isUnsignedOperator();

      if (node.kind == NodeKind.ADD) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_ADD);
      else if (node.kind == NodeKind.BITWISE_AND) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_AND);
      else if (node.kind == NodeKind.BITWISE_OR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_OR);
      else if (node.kind == NodeKind.BITWISE_XOR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_XOR);
      else if (node.kind == NodeKind.EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_EQ);
      else if (node.kind == NodeKind.MULTIPLY) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_MUL);
      else if (node.kind == NodeKind.NOT_EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_NE);
      else if (node.kind == NodeKind.SHIFT_LEFT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SHL);
      else if (node.kind == NodeKind.SUBTRACT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SUB);

      else if (node.kind == NodeKind.DIVIDE) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_DIV_U : WASM_OPCODE_I32_DIV_S);
      else if (node.kind == NodeKind.GREATER_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GT_U : WASM_OPCODE_I32_GT_S);
      else if (node.kind == NodeKind.GREATER_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GE_U : WASM_OPCODE_I32_GE_S);
      else if (node.kind == NodeKind.LESS_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LT_U : WASM_OPCODE_I32_LT_S);
      else if (node.kind == NodeKind.LESS_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LE_U : WASM_OPCODE_I32_LE_S);
      else if (node.kind == NodeKind.REMAINDER) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_REM_U : WASM_OPCODE_I32_REM_S);
      else if (node.kind == NodeKind.SHIFT_RIGHT) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_SHR_U : WASM_OPCODE_I32_SHR_S);

      else {
        assert(false);
      }
    }

    return 1;
  }

  getWasmType(type: Type): WasmType {
    var context = this.context;

    if (type == context.boolType || type.isInteger() || type.isReference(context)) {
      return WasmType.I32;
    }

    if (type == context.voidType) {
      return WasmType.VOID;
    }

    assert(false);
    return WasmType.VOID;
  }
}
class WasmModule9 {
  firstImport: WasmImport;
  lastImport: WasmImport;
  importCount: int;

  firstFunction: WasmFunction;
  lastFunction: WasmFunction;
  functionCount: int;

  firstSignature: WasmSignature;
  lastSignature: WasmSignature;
  signatureCount: int;

  memoryInitializer: ByteArray;
  currentHeapPointer: int;
  originalHeapPointer: int;
  mallocFunctionIndex: int;
  context: CheckContext;

  growMemoryInitializer(): void {
    var array = this.memoryInitializer;
    var current = array.length();
    var length = this.context.nextGlobalVariableOffset;

    while (current < length) {
      array.append(0);
      current = current + 1;
    }
  }

  allocateImport(signatureIndex: int, mod: String, name: String): WasmImport {
    var result = new WasmImport();
    result.signatureIndex = signatureIndex;
    result.module = mod;
    result.name = name;

    if (this.firstImport == null) this.firstImport = result;
    else this.lastImport.next = result;
    this.lastImport = result;

    this.importCount = this.importCount + 1;
    return result;
  }

  allocateFunction(name: String, signatureIndex: int, body: Node): WasmFunction {
    var fn = new WasmFunction();
    fn.name = name;
    fn.signatureIndex = signatureIndex;
    fn.body = body;

    if (this.firstFunction == null) this.firstFunction = fn;
    else this.lastFunction.next = fn;
    this.lastFunction = fn;

    this.functionCount = this.functionCount + 1;
    return fn;
  }

  allocateSignature(argumentTypes: WasmWrappedType, returnType: WasmWrappedType): int {
    assert(returnType != null);
    assert(returnType.next == null);

    var signature = new WasmSignature();
    signature.argumentTypes = argumentTypes;
    signature.returnType = returnType;

    var check = this.firstSignature;
    var i = 0;

    while (check != null) {
      if (wasmAreSignaturesEqual(signature, check)) {
        return i;
      }

      check = check.next;
      i = i + 1;
    }

    if (this.firstSignature == null) this.firstSignature = signature;
    else this.lastSignature.next = signature;
    this.lastSignature = signature;

    this.signatureCount = this.signatureCount + 1;
    return i;
  }

  emitModule(array: ByteArray): void {
    ByteArray_append32(array, WASM_MAGIC);
    ByteArray_append32(array, WASM_VERSION);

    this.emitSignatures(array);
    this.emitImportTable(array);
    this.emitFunctionSignatures(array);
    this.emitMemory(array);
    this.emitExportTable(array);
    this.emitFunctionBodies(array);
    this.emitDataSegments(array);
  }

  emitSignatures(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("signatures"));
    wasmWriteVarUnsigned(array, this.signatureCount);

    var signature = this.firstSignature;
    while (signature != null) {
      var count = 0;
      var type = signature.argumentTypes;

      while (type != null) {
        count = count + 1;
        type = type.next;
      }

      wasmWriteVarUnsigned(array, count);
      wasmWriteVarUnsigned(array, signature.returnType.id as int);

      type = signature.argumentTypes;
      while (type != null) {
        wasmWriteVarUnsigned(array, type.id as int);
        type = type.next;
      }

      signature = signature.next;
    }

    wasmFinishSection(array, section);
  }

  emitImportTable(array: ByteArray): void {
    if (this.firstImport == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("import_table"));
    wasmWriteVarUnsigned(array, this.importCount);

    var current = this.firstImport;
    while (current != null) {
      wasmWriteVarUnsigned(array, current.signatureIndex);
      wasmWriteLengthPrefixedString(array, current.module);
      wasmWriteLengthPrefixedString(array, current.name);
      current = current.next;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionSignatures(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_signatures"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      wasmWriteVarUnsigned(array, fn.signatureIndex);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitMemory(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("memory"));
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, 1); // The memory array is exported
    wasmFinishSection(array, section);
  }

  emitExportTable(array: ByteArray): void {
    var exportedCount = 0;
    var fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        exportedCount = exportedCount + 1;
      }
      fn = fn.next;
    }
    if (exportedCount == 0) {
      return;
    }

    var section = wasmStartSection(array, String_new("export_table"));
    wasmWriteVarUnsigned(array, exportedCount);

    var i = 0;
    fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        wasmWriteVarUnsigned(array, i);
        wasmWriteLengthPrefixedString(array, fn.name);
      }
      fn = fn.next;
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionBodies(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_bodies"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      var bodyLength = array.length();
      wasmWriteVarUnsigned(array, ~0); // This will be patched later

      if (fn.intLocalCount > 0) {
        wasmWriteVarUnsigned(array, 1);
        wasmWriteVarUnsigned(array, fn.intLocalCount);
        array.append(WasmType.I32);
      } else {
        wasmWriteVarUnsigned(array, 0);
      }

      var child = fn.body.firstChild;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }

      wasmPatchVarUnsigned(array, bodyLength, array.length() - bodyLength - 5, ~0);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitDataSegments(array: ByteArray): void {
    this.growMemoryInitializer();
    var memoryInitializer = this.memoryInitializer;
    var initializerLength = memoryInitializer.length();
    var initialHeapPointer = alignToNextMultipleOf(WASM_MEMORY_INITIALIZER_BASE + initializerLength, 8);

    // Pass the initial heap pointer to the "malloc" function
    ByteArray_set32(memoryInitializer, this.currentHeapPointer, initialHeapPointer);
    ByteArray_set32(memoryInitializer, this.originalHeapPointer, initialHeapPointer);

    var section = wasmStartSection(array, String_new("data_segments"));

    // This only writes one single section containing everything
    wasmWriteVarUnsigned(array, 1);

    // Emit the range of the memory initializer
    wasmWriteVarUnsigned(array, WASM_MEMORY_INITIALIZER_BASE);
    wasmWriteVarUnsigned(array, initializerLength);

    // Copy the entire memory initializer (also includes zero-initialized data for now)
    var i = 0;
    while (i < initializerLength) {
      array.append(memoryInitializer.get(i));
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  prepareToEmit(node: Node): void {
    if (node.kind == NodeKind.STRING) {
      var text = node.stringValue;
      var length = String_length(text);
      var offset = this.context.allocateGlobalVariableOffset(length + 1, 1);;
      this.growMemoryInitializer();
      var memoryInitializer = this.memoryInitializer;
      var i = 0;
      while (i < length) {
        memoryInitializer.set(offset + i, String_get(text, i) as byte);
        i = i + 1;
      }
      memoryInitializer.set(offset + length, 0);
      node.intValue = offset;
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        var sizeOf = symbol.resolvedType.variableSizeOf();
        var value = symbol.node.variableValue().intValue;
        var memoryInitializer = this.memoryInitializer;

        // Copy the inital value into the memory initializer
        this.growMemoryInitializer();
        if (sizeOf == 1) memoryInitializer.set(symbol.offset, value as byte);
        else if (sizeOf == 2) ByteArray_set16(memoryInitializer, symbol.offset, value);
        else if (sizeOf == 4) ByteArray_set32(memoryInitializer, symbol.offset, value);
        else assert(false);

        // Make sure the heap offset is tracked
        if (String_equalNew(symbol.name, "currentHeapPointer")) {
          assert(this.currentHeapPointer == -1);
          this.currentHeapPointer = symbol.offset;
        }

        // Make sure the heap offset is tracked
        else if (String_equalNew(symbol.name, "originalHeapPointer")) {
          assert(this.originalHeapPointer == -1);
          this.originalHeapPointer = symbol.offset;
        }
      }
    }

    else if (node.kind == NodeKind.FUNCTION) {
      var returnType = node.functionReturnType();
      var shared = new WasmSharedOffset();
      var argumentTypesFirst: WasmWrappedType = null;
      var argumentTypesLast: WasmWrappedType = null;

      // Make sure to include the implicit "this" variable as a normal argument
      var argument = node.firstChild;
      while (argument != returnType) {
        var type = wasmWrapType(this.getWasmType(argument.variableType().resolvedType));

        if (argumentTypesFirst == null) argumentTypesFirst = type;
        else argumentTypesLast.next = type;
        argumentTypesLast = type;

        shared.nextLocalOffset = shared.nextLocalOffset + 1;
        argument = argument.nextSibling;
      }
      var signatureIndex = this.allocateSignature(argumentTypesFirst, wasmWrapType(this.getWasmType(returnType.resolvedType)));
      var body = node.functionBody();
      var symbol = node.symbol;

      // Functions without bodies are imports
      if (body == null) {
        var moduleName = symbol.kind == SymbolKind.FUNCTION_INSTANCE ? symbol.parent().name : String_new("globals");
        symbol.offset = this.importCount;
        this.allocateImport(signatureIndex, moduleName, symbol.name);
        node = node.nextSibling;
        return;
      }

      symbol.offset = this.functionCount;
      var fn = this.allocateFunction(symbol.name, signatureIndex, body);

      // Make sure "malloc" is tracked
      if (symbol.kind == SymbolKind.FUNCTION_GLOBAL && String_equalNew(symbol.name, "malloc")) {
        assert(this.mallocFunctionIndex == -1);
        this.mallocFunctionIndex = symbol.offset;
      }

      // Only export "extern" functions
      if (node.isExtern()) {
        fn.isExported = true;
      }

      // Assign local variable offsets
      wasmAssignLocalVariableOffsets(body, shared);
      fn.intLocalCount = shared.intLocalCount;
    }

    var child = node.firstChild;
    while (child != null) {
      this.prepareToEmit(child);
      child = child.nextSibling;
    }
  }

  emitBinaryExpression(array: ByteArray, node: Node, opcode: byte): void {
    array.append(opcode);
    this.emitNode(array, node.binaryLeft());
    this.emitNode(array, node.binaryRight());
  }

  emitLoadFromMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD8_U : WASM_OPCODE_I32_LOAD8_S);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD16_U : WASM_OPCODE_I32_LOAD16_S);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_LOAD);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }
  }

  emitStoreToMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int, value: Node): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(WASM_OPCODE_I32_STORE8);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(WASM_OPCODE_I32_STORE16);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_STORE);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }

    this.emitNode(array, value);
  }

  emitNode(array: ByteArray, node: Node): int {
    assert(!isExpression(node) || node.resolvedType != null);

    if (node.kind == NodeKind.BLOCK) {
      array.append(WASM_OPCODE_BLOCK);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.WHILE) {
      var value = node.whileValue();
      var body = node.whileBody();

      // Ignore "while (false) { ... }"
      if (value.kind == NodeKind.BOOL && value.intValue == 0) {
        return 0;
      }

      array.append(WASM_OPCODE_LOOP);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;

      // Emit the condition as "loop { if (!condition) break; }" as long as it's not a "while (true)" loop
      if (value.kind != NodeKind.BOOL) {
        array.append(WASM_OPCODE_BR_IF);
        wasmWriteVarUnsigned(array, 1); // Break out of the immediately enclosing loop
        array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
        array.append(WASM_OPCODE_I32_EQZ); // The conditional is flipped
        this.emitNode(array, value);
        count = count + 1;
      }

      var child = body.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }

      // Jump back to the top (this doesn't happen automatically)
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, 0); // Continue back to the immediately enclosing loop
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
      count = count + 1;

      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.BREAK || node.kind == NodeKind.CONTINUE) {
      var label = 0;
      var parent = node.parent;

      while (parent != null && parent.kind != NodeKind.WHILE) {
        if (parent.kind == NodeKind.BLOCK) {
          label = label + 1;
        }
        parent = parent.parent;
      }

      assert(label > 0);
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, label - (node.kind == NodeKind.BREAK ? 0 : 1));
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
    }

    else if (node.kind == NodeKind.EMPTY) {
      return 0;
    }

    else if (node.kind == NodeKind.EXPRESSION) {
      this.emitNode(array, node.expressionValue());
    }

    else if (node.kind == NodeKind.RETURN) {
      var value = node.returnValue();
      array.append(WASM_OPCODE_RETURN);
      if (value != null) {
        this.emitNode(array, value);
      }
    }

    else if (node.kind == NodeKind.VARIABLES) {
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        assert(child.kind == NodeKind.VARIABLE);
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      return count;
    }

    else if (node.kind == NodeKind.IF) {
      var branch = node.ifFalse();
      array.append(branch == null ? WASM_OPCODE_IF : WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.ifValue());
      this.emitNode(array, node.ifTrue());
      if (branch != null) {
        this.emitNode(array, branch);
      }
    }

    else if (node.kind == NodeKind.HOOK) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.hookValue());
      this.emitNode(array, node.hookTrue());
      this.emitNode(array, node.hookFalse());
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var value = node.variableValue();

      if (node.symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, node.symbol.offset);

        if (value != null) {
          this.emitNode(array, value);
        }

        // Default initialization
        else {
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, 0);
        }
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NAME) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_GET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitLoadFromMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NULL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.INT || node.kind == NodeKind.BOOL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, node.intValue);
    }

    else if (node.kind == NodeKind.STRING) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, WASM_MEMORY_INITIALIZER_BASE + node.intValue);
    }

    else if (node.kind == NodeKind.CALL) {
      var value = node.callValue();
      var symbol = value.symbol;
      assert(isFunction(symbol.kind));

      array.append(symbol.node.functionBody() == null ? WASM_OPCODE_CALL_IMPORT : WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, symbol.offset);

      // Write out the implicit "this" argument
      if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
        this.emitNode(array, value.dotTarget());
      }

      var child = value.nextSibling;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }
    }

    else if (node.kind == NodeKind.NEW) {
      var type = node.newType();
      assert(type.symbol.kind == SymbolKind.TYPE_CLASS);

      array.append(WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, this.mallocFunctionIndex);

      // Pass the object size as the first argument
      assert(type.symbol.byteSize > 0);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, type.symbol.byteSize);
    }

    else if (node.kind == NodeKind.POSITIVE) {
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NEGATIVE) {
      array.append(WASM_OPCODE_I32_SUB);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.COMPLEMENT) {
      array.append(WASM_OPCODE_I32_XOR);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, ~0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NOT) {
      array.append(WASM_OPCODE_I32_EQZ);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.CAST) {
      var value = node.castValue();
      var context = this.context;
      var from = value.resolvedType.underlyingType(context);
      var type = node.resolvedType.underlyingType(context);

      // The cast isn't needed if it's to a wider integer type
      if (from == type || from.symbol.byteSize < type.symbol.byteSize) {
        this.emitNode(array, value);
      }

      else {
        // Sign-extend
        if (type == context.byteType || type == context.shortType) {
          var shift = 32 - type.symbol.byteSize * 8;
          array.append(WASM_OPCODE_I32_SHR_S);
          array.append(WASM_OPCODE_I32_SHL);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
        }

        // Mask
        else if (type == context.ubyteType || type == context.ushortType) {
          array.append(WASM_OPCODE_I32_AND);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, type.integerBitMask() as int);
        }

        // No cast needed
        else {
          this.emitNode(array, value);
        }
      }
    }

    else if (node.kind == NodeKind.DOT) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitLoadFromMemory(array, symbol.resolvedType, node.dotTarget(), symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.ASSIGN) {
      var left = node.binaryLeft();
      var symbol = left.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitStoreToMemory(array, symbol.resolvedType, left.dotTarget(), symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitStoreToMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
        this.emitNode(array, node.binaryRight());
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.LOGICAL_AND) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      this.emitNode(array, node.binaryRight());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.LOGICAL_OR) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 1);
      this.emitNode(array, node.binaryRight());
    }

    else {
      var isUnsigned = node.isUnsignedOperator();

      if (node.kind == NodeKind.ADD) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_ADD);
      else if (node.kind == NodeKind.BITWISE_AND) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_AND);
      else if (node.kind == NodeKind.BITWISE_OR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_OR);
      else if (node.kind == NodeKind.BITWISE_XOR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_XOR);
      else if (node.kind == NodeKind.EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_EQ);
      else if (node.kind == NodeKind.MULTIPLY) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_MUL);
      else if (node.kind == NodeKind.NOT_EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_NE);
      else if (node.kind == NodeKind.SHIFT_LEFT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SHL);
      else if (node.kind == NodeKind.SUBTRACT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SUB);

      else if (node.kind == NodeKind.DIVIDE) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_DIV_U : WASM_OPCODE_I32_DIV_S);
      else if (node.kind == NodeKind.GREATER_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GT_U : WASM_OPCODE_I32_GT_S);
      else if (node.kind == NodeKind.GREATER_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GE_U : WASM_OPCODE_I32_GE_S);
      else if (node.kind == NodeKind.LESS_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LT_U : WASM_OPCODE_I32_LT_S);
      else if (node.kind == NodeKind.LESS_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LE_U : WASM_OPCODE_I32_LE_S);
      else if (node.kind == NodeKind.REMAINDER) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_REM_U : WASM_OPCODE_I32_REM_S);
      else if (node.kind == NodeKind.SHIFT_RIGHT) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_SHR_U : WASM_OPCODE_I32_SHR_S);

      else {
        assert(false);
      }
    }

    return 1;
  }

  getWasmType(type: Type): WasmType {
    var context = this.context;

    if (type == context.boolType || type.isInteger() || type.isReference(context)) {
      return WasmType.I32;
    }

    if (type == context.voidType) {
      return WasmType.VOID;
    }

    assert(false);
    return WasmType.VOID;
  }
}
class WasmModule10 {
  firstImport: WasmImport;
  lastImport: WasmImport;
  importCount: int;

  firstFunction: WasmFunction;
  lastFunction: WasmFunction;
  functionCount: int;

  firstSignature: WasmSignature;
  lastSignature: WasmSignature;
  signatureCount: int;

  memoryInitializer: ByteArray;
  currentHeapPointer: int;
  originalHeapPointer: int;
  mallocFunctionIndex: int;
  context: CheckContext;

  growMemoryInitializer(): void {
    var array = this.memoryInitializer;
    var current = array.length();
    var length = this.context.nextGlobalVariableOffset;

    while (current < length) {
      array.append(0);
      current = current + 1;
    }
  }

  allocateImport(signatureIndex: int, mod: String, name: String): WasmImport {
    var result = new WasmImport();
    result.signatureIndex = signatureIndex;
    result.module = mod;
    result.name = name;

    if (this.firstImport == null) this.firstImport = result;
    else this.lastImport.next = result;
    this.lastImport = result;

    this.importCount = this.importCount + 1;
    return result;
  }

  allocateFunction(name: String, signatureIndex: int, body: Node): WasmFunction {
    var fn = new WasmFunction();
    fn.name = name;
    fn.signatureIndex = signatureIndex;
    fn.body = body;

    if (this.firstFunction == null) this.firstFunction = fn;
    else this.lastFunction.next = fn;
    this.lastFunction = fn;

    this.functionCount = this.functionCount + 1;
    return fn;
  }

  allocateSignature(argumentTypes: WasmWrappedType, returnType: WasmWrappedType): int {
    assert(returnType != null);
    assert(returnType.next == null);

    var signature = new WasmSignature();
    signature.argumentTypes = argumentTypes;
    signature.returnType = returnType;

    var check = this.firstSignature;
    var i = 0;

    while (check != null) {
      if (wasmAreSignaturesEqual(signature, check)) {
        return i;
      }

      check = check.next;
      i = i + 1;
    }

    if (this.firstSignature == null) this.firstSignature = signature;
    else this.lastSignature.next = signature;
    this.lastSignature = signature;

    this.signatureCount = this.signatureCount + 1;
    return i;
  }

  emitModule(array: ByteArray): void {
    ByteArray_append32(array, WASM_MAGIC);
    ByteArray_append32(array, WASM_VERSION);

    this.emitSignatures(array);
    this.emitImportTable(array);
    this.emitFunctionSignatures(array);
    this.emitMemory(array);
    this.emitExportTable(array);
    this.emitFunctionBodies(array);
    this.emitDataSegments(array);
  }

  emitSignatures(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("signatures"));
    wasmWriteVarUnsigned(array, this.signatureCount);

    var signature = this.firstSignature;
    while (signature != null) {
      var count = 0;
      var type = signature.argumentTypes;

      while (type != null) {
        count = count + 1;
        type = type.next;
      }

      wasmWriteVarUnsigned(array, count);
      wasmWriteVarUnsigned(array, signature.returnType.id as int);

      type = signature.argumentTypes;
      while (type != null) {
        wasmWriteVarUnsigned(array, type.id as int);
        type = type.next;
      }

      signature = signature.next;
    }

    wasmFinishSection(array, section);
  }

  emitImportTable(array: ByteArray): void {
    if (this.firstImport == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("import_table"));
    wasmWriteVarUnsigned(array, this.importCount);

    var current = this.firstImport;
    while (current != null) {
      wasmWriteVarUnsigned(array, current.signatureIndex);
      wasmWriteLengthPrefixedString(array, current.module);
      wasmWriteLengthPrefixedString(array, current.name);
      current = current.next;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionSignatures(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_signatures"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      wasmWriteVarUnsigned(array, fn.signatureIndex);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitMemory(array: ByteArray): void {
    var section = wasmStartSection(array, String_new("memory"));
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, WASM_SIZE_IN_PAGES);
    wasmWriteVarUnsigned(array, 1); // The memory array is exported
    wasmFinishSection(array, section);
  }

  emitExportTable(array: ByteArray): void {
    var exportedCount = 0;
    var fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        exportedCount = exportedCount + 1;
      }
      fn = fn.next;
    }
    if (exportedCount == 0) {
      return;
    }

    var section = wasmStartSection(array, String_new("export_table"));
    wasmWriteVarUnsigned(array, exportedCount);

    var i = 0;
    fn = this.firstFunction;
    while (fn != null) {
      if (fn.isExported) {
        wasmWriteVarUnsigned(array, i);
        wasmWriteLengthPrefixedString(array, fn.name);
      }
      fn = fn.next;
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  emitFunctionBodies(array: ByteArray): void {
    if (this.firstFunction == null) {
      return;
    }

    var section = wasmStartSection(array, String_new("function_bodies"));
    wasmWriteVarUnsigned(array, this.functionCount);

    var fn = this.firstFunction;
    while (fn != null) {
      var bodyLength = array.length();
      wasmWriteVarUnsigned(array, ~0); // This will be patched later

      if (fn.intLocalCount > 0) {
        wasmWriteVarUnsigned(array, 1);
        wasmWriteVarUnsigned(array, fn.intLocalCount);
        array.append(WasmType.I32);
      } else {
        wasmWriteVarUnsigned(array, 0);
      }

      var child = fn.body.firstChild;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }

      wasmPatchVarUnsigned(array, bodyLength, array.length() - bodyLength - 5, ~0);
      fn = fn.next;
    }

    wasmFinishSection(array, section);
  }

  emitDataSegments(array: ByteArray): void {
    this.growMemoryInitializer();
    var memoryInitializer = this.memoryInitializer;
    var initializerLength = memoryInitializer.length();
    var initialHeapPointer = alignToNextMultipleOf(WASM_MEMORY_INITIALIZER_BASE + initializerLength, 8);

    // Pass the initial heap pointer to the "malloc" function
    ByteArray_set32(memoryInitializer, this.currentHeapPointer, initialHeapPointer);
    ByteArray_set32(memoryInitializer, this.originalHeapPointer, initialHeapPointer);

    var section = wasmStartSection(array, String_new("data_segments"));

    // This only writes one single section containing everything
    wasmWriteVarUnsigned(array, 1);

    // Emit the range of the memory initializer
    wasmWriteVarUnsigned(array, WASM_MEMORY_INITIALIZER_BASE);
    wasmWriteVarUnsigned(array, initializerLength);

    // Copy the entire memory initializer (also includes zero-initialized data for now)
    var i = 0;
    while (i < initializerLength) {
      array.append(memoryInitializer.get(i));
      i = i + 1;
    }

    wasmFinishSection(array, section);
  }

  prepareToEmit(node: Node): void {
    if (node.kind == NodeKind.STRING) {
      var text = node.stringValue;
      var length = String_length(text);
      var offset = this.context.allocateGlobalVariableOffset(length + 1, 1);;
      this.growMemoryInitializer();
      var memoryInitializer = this.memoryInitializer;
      var i = 0;
      while (i < length) {
        memoryInitializer.set(offset + i, String_get(text, i) as byte);
        i = i + 1;
      }
      memoryInitializer.set(offset + length, 0);
      node.intValue = offset;
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        var sizeOf = symbol.resolvedType.variableSizeOf();
        var value = symbol.node.variableValue().intValue;
        var memoryInitializer = this.memoryInitializer;

        // Copy the inital value into the memory initializer
        this.growMemoryInitializer();
        if (sizeOf == 1) memoryInitializer.set(symbol.offset, value as byte);
        else if (sizeOf == 2) ByteArray_set16(memoryInitializer, symbol.offset, value);
        else if (sizeOf == 4) ByteArray_set32(memoryInitializer, symbol.offset, value);
        else assert(false);

        // Make sure the heap offset is tracked
        if (String_equalNew(symbol.name, "currentHeapPointer")) {
          assert(this.currentHeapPointer == -1);
          this.currentHeapPointer = symbol.offset;
        }

        // Make sure the heap offset is tracked
        else if (String_equalNew(symbol.name, "originalHeapPointer")) {
          assert(this.originalHeapPointer == -1);
          this.originalHeapPointer = symbol.offset;
        }
      }
    }

    else if (node.kind == NodeKind.FUNCTION) {
      var returnType = node.functionReturnType();
      var shared = new WasmSharedOffset();
      var argumentTypesFirst: WasmWrappedType = null;
      var argumentTypesLast: WasmWrappedType = null;

      // Make sure to include the implicit "this" variable as a normal argument
      var argument = node.firstChild;
      while (argument != returnType) {
        var type = wasmWrapType(this.getWasmType(argument.variableType().resolvedType));

        if (argumentTypesFirst == null) argumentTypesFirst = type;
        else argumentTypesLast.next = type;
        argumentTypesLast = type;

        shared.nextLocalOffset = shared.nextLocalOffset + 1;
        argument = argument.nextSibling;
      }
      var signatureIndex = this.allocateSignature(argumentTypesFirst, wasmWrapType(this.getWasmType(returnType.resolvedType)));
      var body = node.functionBody();
      var symbol = node.symbol;

      // Functions without bodies are imports
      if (body == null) {
        var moduleName = symbol.kind == SymbolKind.FUNCTION_INSTANCE ? symbol.parent().name : String_new("globals");
        symbol.offset = this.importCount;
        this.allocateImport(signatureIndex, moduleName, symbol.name);
        node = node.nextSibling;
        return;
      }

      symbol.offset = this.functionCount;
      var fn = this.allocateFunction(symbol.name, signatureIndex, body);

      // Make sure "malloc" is tracked
      if (symbol.kind == SymbolKind.FUNCTION_GLOBAL && String_equalNew(symbol.name, "malloc")) {
        assert(this.mallocFunctionIndex == -1);
        this.mallocFunctionIndex = symbol.offset;
      }

      // Only export "extern" functions
      if (node.isExtern()) {
        fn.isExported = true;
      }

      // Assign local variable offsets
      wasmAssignLocalVariableOffsets(body, shared);
      fn.intLocalCount = shared.intLocalCount;
    }

    var child = node.firstChild;
    while (child != null) {
      this.prepareToEmit(child);
      child = child.nextSibling;
    }
  }

  emitBinaryExpression(array: ByteArray, node: Node, opcode: byte): void {
    array.append(opcode);
    this.emitNode(array, node.binaryLeft());
    this.emitNode(array, node.binaryRight());
  }

  emitLoadFromMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD8_U : WASM_OPCODE_I32_LOAD8_S);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(type.isUnsigned() ? WASM_OPCODE_I32_LOAD16_U : WASM_OPCODE_I32_LOAD16_S);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_LOAD);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }
  }

  emitStoreToMemory(array: ByteArray, type: Type, relativeBase: Node, offset: int, value: Node): void {
    var sizeOf = type.variableSizeOf();

    if (sizeOf == 1) {
      array.append(WASM_OPCODE_I32_STORE8);
      wasmWriteVarUnsigned(array, 0);
    }

    else if (sizeOf == 2) {
      array.append(WASM_OPCODE_I32_STORE16);
      wasmWriteVarUnsigned(array, 1);
    }

    else if (sizeOf == 4) {
      array.append(WASM_OPCODE_I32_STORE);
      wasmWriteVarUnsigned(array, 2);
    }

    else {
      assert(false);
    }

    wasmWriteVarUnsigned(array, offset);

    // Relative address
    if (relativeBase != null) {
      this.emitNode(array, relativeBase);
    }

    // Absolute address
    else {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarUnsigned(array, 0);
    }

    this.emitNode(array, value);
  }

  emitNode(array: ByteArray, node: Node): int {
    assert(!isExpression(node) || node.resolvedType != null);

    if (node.kind == NodeKind.BLOCK) {
      array.append(WASM_OPCODE_BLOCK);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.WHILE) {
      var value = node.whileValue();
      var body = node.whileBody();

      // Ignore "while (false) { ... }"
      if (value.kind == NodeKind.BOOL && value.intValue == 0) {
        return 0;
      }

      array.append(WASM_OPCODE_LOOP);
      var offset = array.length();
      wasmWriteVarUnsigned(array, ~0);
      var count = 0;

      // Emit the condition as "loop { if (!condition) break; }" as long as it's not a "while (true)" loop
      if (value.kind != NodeKind.BOOL) {
        array.append(WASM_OPCODE_BR_IF);
        wasmWriteVarUnsigned(array, 1); // Break out of the immediately enclosing loop
        array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
        array.append(WASM_OPCODE_I32_EQZ); // The conditional is flipped
        this.emitNode(array, value);
        count = count + 1;
      }

      var child = body.firstChild;
      while (child != null) {
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }

      // Jump back to the top (this doesn't happen automatically)
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, 0); // Continue back to the immediately enclosing loop
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
      count = count + 1;

      wasmPatchVarUnsigned(array, offset, count, ~0);
    }

    else if (node.kind == NodeKind.BREAK || node.kind == NodeKind.CONTINUE) {
      var label = 0;
      var parent = node.parent;

      while (parent != null && parent.kind != NodeKind.WHILE) {
        if (parent.kind == NodeKind.BLOCK) {
          label = label + 1;
        }
        parent = parent.parent;
      }

      assert(label > 0);
      array.append(WASM_OPCODE_BR);
      wasmWriteVarUnsigned(array, label - (node.kind == NodeKind.BREAK ? 0 : 1));
      array.append(WASM_OPCODE_NOP); // This is a statement, not an expression
    }

    else if (node.kind == NodeKind.EMPTY) {
      return 0;
    }

    else if (node.kind == NodeKind.EXPRESSION) {
      this.emitNode(array, node.expressionValue());
    }

    else if (node.kind == NodeKind.RETURN) {
      var value = node.returnValue();
      array.append(WASM_OPCODE_RETURN);
      if (value != null) {
        this.emitNode(array, value);
      }
    }

    else if (node.kind == NodeKind.VARIABLES) {
      var count = 0;
      var child = node.firstChild;
      while (child != null) {
        assert(child.kind == NodeKind.VARIABLE);
        count = count + this.emitNode(array, child);
        child = child.nextSibling;
      }
      return count;
    }

    else if (node.kind == NodeKind.IF) {
      var branch = node.ifFalse();
      array.append(branch == null ? WASM_OPCODE_IF : WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.ifValue());
      this.emitNode(array, node.ifTrue());
      if (branch != null) {
        this.emitNode(array, branch);
      }
    }

    else if (node.kind == NodeKind.HOOK) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.hookValue());
      this.emitNode(array, node.hookTrue());
      this.emitNode(array, node.hookFalse());
    }

    else if (node.kind == NodeKind.VARIABLE) {
      var value = node.variableValue();

      if (node.symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, node.symbol.offset);

        if (value != null) {
          this.emitNode(array, value);
        }

        // Default initialization
        else {
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, 0);
        }
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NAME) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_GET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitLoadFromMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.NULL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.INT || node.kind == NodeKind.BOOL) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, node.intValue);
    }

    else if (node.kind == NodeKind.STRING) {
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, WASM_MEMORY_INITIALIZER_BASE + node.intValue);
    }

    else if (node.kind == NodeKind.CALL) {
      var value = node.callValue();
      var symbol = value.symbol;
      assert(isFunction(symbol.kind));

      array.append(symbol.node.functionBody() == null ? WASM_OPCODE_CALL_IMPORT : WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, symbol.offset);

      // Write out the implicit "this" argument
      if (symbol.kind == SymbolKind.FUNCTION_INSTANCE) {
        this.emitNode(array, value.dotTarget());
      }

      var child = value.nextSibling;
      while (child != null) {
        this.emitNode(array, child);
        child = child.nextSibling;
      }
    }

    else if (node.kind == NodeKind.NEW) {
      var type = node.newType();
      assert(type.symbol.kind == SymbolKind.TYPE_CLASS);

      array.append(WASM_OPCODE_CALL);
      wasmWriteVarUnsigned(array, this.mallocFunctionIndex);

      // Pass the object size as the first argument
      assert(type.symbol.byteSize > 0);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, type.symbol.byteSize);
    }

    else if (node.kind == NodeKind.POSITIVE) {
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NEGATIVE) {
      array.append(WASM_OPCODE_I32_SUB);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.COMPLEMENT) {
      array.append(WASM_OPCODE_I32_XOR);
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, ~0);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.NOT) {
      array.append(WASM_OPCODE_I32_EQZ);
      this.emitNode(array, node.unaryValue());
    }

    else if (node.kind == NodeKind.CAST) {
      var value = node.castValue();
      var context = this.context;
      var from = value.resolvedType.underlyingType(context);
      var type = node.resolvedType.underlyingType(context);

      // The cast isn't needed if it's to a wider integer type
      if (from == type || from.symbol.byteSize < type.symbol.byteSize) {
        this.emitNode(array, value);
      }

      else {
        // Sign-extend
        if (type == context.byteType || type == context.shortType) {
          var shift = 32 - type.symbol.byteSize * 8;
          array.append(WASM_OPCODE_I32_SHR_S);
          array.append(WASM_OPCODE_I32_SHL);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, shift);
        }

        // Mask
        else if (type == context.ubyteType || type == context.ushortType) {
          array.append(WASM_OPCODE_I32_AND);
          this.emitNode(array, value);
          array.append(WASM_OPCODE_I32_CONST);
          wasmWriteVarSigned(array, type.integerBitMask() as int);
        }

        // No cast needed
        else {
          this.emitNode(array, value);
        }
      }
    }

    else if (node.kind == NodeKind.DOT) {
      var symbol = node.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitLoadFromMemory(array, symbol.resolvedType, node.dotTarget(), symbol.offset);
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.ASSIGN) {
      var left = node.binaryLeft();
      var symbol = left.symbol;

      if (symbol.kind == SymbolKind.VARIABLE_INSTANCE) {
        this.emitStoreToMemory(array, symbol.resolvedType, left.dotTarget(), symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_GLOBAL) {
        this.emitStoreToMemory(array, symbol.resolvedType, null, WASM_MEMORY_INITIALIZER_BASE + symbol.offset, node.binaryRight());
      }

      else if (symbol.kind == SymbolKind.VARIABLE_ARGUMENT || symbol.kind == SymbolKind.VARIABLE_LOCAL) {
        array.append(WASM_OPCODE_SET_LOCAL);
        wasmWriteVarUnsigned(array, symbol.offset);
        this.emitNode(array, node.binaryRight());
      }

      else {
        assert(false);
      }
    }

    else if (node.kind == NodeKind.LOGICAL_AND) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      this.emitNode(array, node.binaryRight());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 0);
    }

    else if (node.kind == NodeKind.LOGICAL_OR) {
      array.append(WASM_OPCODE_IF_ELSE);
      this.emitNode(array, node.binaryLeft());
      array.append(WASM_OPCODE_I32_CONST);
      wasmWriteVarSigned(array, 1);
      this.emitNode(array, node.binaryRight());
    }

    else {
      var isUnsigned = node.isUnsignedOperator();

      if (node.kind == NodeKind.ADD) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_ADD);
      else if (node.kind == NodeKind.BITWISE_AND) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_AND);
      else if (node.kind == NodeKind.BITWISE_OR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_OR);
      else if (node.kind == NodeKind.BITWISE_XOR) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_XOR);
      else if (node.kind == NodeKind.EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_EQ);
      else if (node.kind == NodeKind.MULTIPLY) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_MUL);
      else if (node.kind == NodeKind.NOT_EQUAL) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_NE);
      else if (node.kind == NodeKind.SHIFT_LEFT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SHL);
      else if (node.kind == NodeKind.SUBTRACT) this.emitBinaryExpression(array, node, WASM_OPCODE_I32_SUB);

      else if (node.kind == NodeKind.DIVIDE) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_DIV_U : WASM_OPCODE_I32_DIV_S);
      else if (node.kind == NodeKind.GREATER_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GT_U : WASM_OPCODE_I32_GT_S);
      else if (node.kind == NodeKind.GREATER_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_GE_U : WASM_OPCODE_I32_GE_S);
      else if (node.kind == NodeKind.LESS_THAN) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LT_U : WASM_OPCODE_I32_LT_S);
      else if (node.kind == NodeKind.LESS_THAN_EQUAL) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_LE_U : WASM_OPCODE_I32_LE_S);
      else if (node.kind == NodeKind.REMAINDER) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_REM_U : WASM_OPCODE_I32_REM_S);
      else if (node.kind == NodeKind.SHIFT_RIGHT) this.emitBinaryExpression(array, node, isUnsigned ? WASM_OPCODE_I32_SHR_U : WASM_OPCODE_I32_SHR_S);

      else {
        assert(false);
      }
    }

    return 1;
  }

  getWasmType(type: Type): WasmType {
    var context = this.context;

    if (type == context.boolType || type.isInteger() || type.isReference(context)) {
      return WasmType.I32;
    }

    if (type == context.voidType) {
      return WasmType.VOID;
    }

    assert(false);
    return WasmType.VOID;
  }
}
